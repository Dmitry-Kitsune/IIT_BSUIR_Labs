using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Drawing;
using System.Windows.Forms;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.IO;
using System.Drawing.Drawing2D;
using System.Drawing.Text;
using DiplomGeoDLL;
using System.Drawing.Printing;
using System.Runtime.InteropServices;

namespace DiplomGeoDLL
{
    public class DllClass1
    {
        public readonly string dirKey = "Diplom_Geo";
        public string projectKey = "Diplom_Projs";
        public string pathKey = "";
        public string comPath = "";

        public string curProject = "";
        public string curDirectory = "";

        public string fileProj = "";
        public string fileAllProj = "";

        public string driveKey;
        public string[] nameDrive;


        private static int ToInt32(double value)
        {
            return value >= Int32.MaxValue ? Int32.MaxValue
             : value <= Int32.MinValue ? Int32.MinValue
              : Convert.ToInt32(value);
        }

            public static void CheckDrive(string dirName, out string strPath)
        {
            string sTmp = "";
            strPath = "";
            DriveInfo[] allDrives = DriveInfo.GetDrives();
            foreach (DriveInfo d in allDrives)
            {
                if ((d.Name[0] == 'A') || (d.Name[0] == 'a'))
                    continue;
                if ((d.Name[0] == 'B') || (d.Name[0] == 'b'))
                    continue;
                if (d.IsReady == false)
                    continue;
                if (d.DriveFormat == "CDUDF")
                    continue;
                sTmp = d.Name + dirName;
                if (Directory.Exists(sTmp))
                {
                    strPath = d.Name;
                    break;
                }
            }
        }

        public static void DriveList(out int kDrive, out string[] sDrive)
        {
            // initialization of outgoing parameters
            kDrive = 0;
            sDrive = new string[] { "", "", "", "", "", "", "", "", "", "" };
            // Using stndsrt program System.IO library
            DriveInfo[] allDrives = DriveInfo.GetDrives();

            //Organization of the loops by the number of all disks
            foreach (DriveInfo d in allDrives)
            {
                //Исключение дисков А и Б
                if ((d.Name[0] == 'A') || (d.Name[0] == 'a'))
                    continue;
                if ((d.Name[0] == 'B') || (d.Name[0] == 'b'))
                    continue;
                //Test of Disc Ready
                if (d.IsReady == false)
                    continue;
                // Exclude CD drive
                if (d.DriveFormat == "CDUDF")
                    continue;
                // Формирование выходных параметров

                kDrive++;
                sDrive[kDrive] = d.Name;
            }
        }

        public static void KeepPath(string strCom, string strKey, string strFile)
        {
            Console.WriteLine($"[DEBUG] MyGeodesy.KeepPath mySel.comPath: '{strCom}'");
            Console.WriteLine($"[DEBUG] MyGeodesy.KeepPath sTemp1: '{strKey}'");
            Console.WriteLine($"[DEBUG] MyGeodesy.KeepPath sTemp2: '{strFile}'");

            //Создание директории "Diplom_Geo" на выбранном диске
            try
            {
                if (!Directory.Exists(strKey))
                {
                    Directory.CreateDirectory(strKey);
                }
            }
            catch (Exception)
            {
                //Console.WriteLine("The CreateDirectory operation failed as expected.");
                Console.WriteLine("Операция CreateDirectory завершилась неудачно, как и ожидалось...");
            }
            finally
            {
            }

            // запись в файл brdrv.dat путь к директории с проектами
            if (File.Exists(strFile))
            {
                File.Delete(strFile);
            }

            FileStream f1 = new FileStream(strFile, FileMode.CreateNew);
            BinaryWriter f2 = new BinaryWriter(f1);
            f2.Write(strCom);
            f2.Close();
            f1.Close();
        }

        //public string fileProj { get; set; }
        //void CheckOpenProj() : base ()
        //{
        //}
        public static void CheckOpenProj(string fileProj, out string curProject, out string curDirectory)
        //public static void CheckOpenProj() : base ()
        {
            // fileProj = ""; // перенесено из MyGeodesy.cs
            string sTmp = ""; // перенесено из MyGeodesy.cs

            // инициализация выходных параметров

            curProject = ""; // перенесено из MyGeodesy.cs
            curDirectory = ""; // перенесено из MyGeodesy.cs

            if (File.Exists(fileProj))
            {
                FileStream fb = new FileStream(fileProj, FileMode.Open, FileAccess.Read);
                BinaryReader fbb = new BinaryReader(fb);
                try
                {
                    sTmp = fbb.ReadString();
                    curProject = fbb.ReadString();
                    curDirectory = fbb.ReadString();
                }
                catch (Exception)
                {
                    Console.WriteLine($"Ошибка операции чтения CheckOpenProj. sTmp = {sTmp}");
                    Console.WriteLine($"Ошибка операции чтения CheckOpenProj. fileProj = {fileProj}");
                }
                finally
                {
                    fb.Close();
                    fbb.Close();
                }
            }
        }

        // Доработать методы
        public static void FormLineStyle(
         int nColor,
         int iStyle,
         int iWid,
         int kr,
         double[] xr,
         double[] yr,
         double[] x,
         double[] y,
         double scaleWin,
         double xBegX,
         double yBegY,
         int xBegWin,
         int yBegWin,
         ref int kLinePart,
         double[] xPart1,
         double[] yPart1,
         double[] xPart2,
         double[] yPart2,
         int[] iLineWid,
         int[] nPenPart,
         ref int kPntPart,
         double[] xPntPart,
         double[] yPntPart,
         int[] nBruPnt,
         double scaleToGeo)
        {
            double num1 = 3.1415926;
            double num2;
            double num3 = num2 = 0.0;
            int num4;
            int num5 = num4 = 0;
            int yWin = num4;
            int xWin = num4;
            int kArray = 999999;
            doubleArray(xr, ref kArray);
            doubleArray(yr, ref kArray);
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            if (kr > kArray)
            {
                int num6 = (int)MessageBox.Show("Индекс массива FormLineStyle");
            }
            else
            {
                if (iStyle > 7)
                    return;
                int iLine;
                int iBlank;
                int iDop;
                StyleParameters(iStyle, out iLine, out iBlank, out iDop);
                double num7 = 1.0 * (double)iLine;
                double num8 = 1.0 * (double)iBlank;
                double num9 = 1.0 * (double)iDop;
                int num10 = kr;
                for (int i = 0; i <= kr; ++i)
                {
                    XYtoWIN(xr[i], yr[i], scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin, out yWin);
                    x[i] = (double)xWin;
                    y[i] = (double)yWin;
                }
                for (int i = 1; i <= num10; ++i)
                {
                    double xCur = x[i] - x[i - 1];
                    double yCur = y[i] - y[i - 1];
                    double num11 = Math.Sqrt(xCur * xCur + yCur * yCur);
                    double num12 = Math.Atan2(yCur, xCur);
                    if (num12 < 0.0)
                        num12 += 2.0 * num1;
                    if (iStyle == 1 || iStyle == 2)
                    {
                        int int32_1 = Convert.ToInt32(x[i - 1]);
                        int int32_2 = Convert.ToInt32(y[i - 1]);
                        int int32_3 = Convert.ToInt32(x[i]);
                        int int32_4 = Convert.ToInt32(y[i]);
                        WINtoXY(int32_1, int32_2, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                        ++kLinePart;
                        xPart1[kLinePart] = xCur;
                        yPart1[kLinePart] = yCur;
                        WINtoXY(int32_3, int32_4, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                        xPart2[kLinePart] = xCur;
                        yPart2[kLinePart] = yCur;
                        iLineWid[kLinePart] = iWid;
                        nPenPart[kLinePart] = nColor;
                    }
                    else
                    {
                        if (iStyle == 3 || iStyle == 4)
                        {
                            double num13 = x[i - 1];
                            double num14 = y[i - 1];
                            double num15 = 0.0;
                            do
                            {
                                double num16 = num15 + num7;
                                if (num16 >= num11)
                                {
                                    num3 = x[i];
                                    num2 = y[i];
                                    int int32_5 = Convert.ToInt32(num13);
                                    int int32_6 = Convert.ToInt32(num14);
                                    int int32_7 = Convert.ToInt32(num3);
                                    int int32_8 = Convert.ToInt32(num2);
                                    WINtoXY(int32_5, int32_6, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    ++kLinePart;
                                    xPart1[kLinePart] = xCur;
                                    yPart1[kLinePart] = yCur;
                                    WINtoXY(int32_7, int32_8, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    xPart2[kLinePart] = xCur;
                                    yPart2[kLinePart] = yCur;
                                    iLineWid[kLinePart] = iWid;
                                    nPenPart[kLinePart] = nColor;
                                    break;
                                }
                                if (num16 < num11)
                                {
                                    num3 = num13 + num7 * Math.Cos(num12);
                                    num2 = num14 + num7 * Math.Sin(num12);
                                    int int32_9 = Convert.ToInt32(num13);
                                    int int32_10 = Convert.ToInt32(num14);
                                    int int32_11 = Convert.ToInt32(num3);
                                    int int32_12 = Convert.ToInt32(num2);
                                    WINtoXY(int32_9, int32_10, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    ++kLinePart;
                                    xPart1[kLinePart] = xCur;
                                    yPart1[kLinePart] = yCur;
                                    WINtoXY(int32_11, int32_12, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    xPart2[kLinePart] = xCur;
                                    yPart2[kLinePart] = yCur;
                                    iLineWid[kLinePart] = iWid;
                                    nPenPart[kLinePart] = nColor;
                                }
                                num15 = num16 + num8;
                                if (num15 < num11)
                                {
                                    num13 = num3 + num8 * Math.Cos(num12);
                                    num14 = num2 + num8 * Math.Sin(num12);
                                }
                                else
                                    break;
                            }
                            while (num15 < num11);
                        }
                        if (iStyle == 5)
                        {
                            double num17 = x[i - 1];
                            double num18 = y[i - 1];
                            double num19 = 0.0;
                            do
                            {
                                double num20 = num19 + num7;
                                if (num20 >= num11)
                                {
                                    num3 = x[i];
                                    num2 = y[i];
                                    int int32_13 = Convert.ToInt32(num17);
                                    int int32_14 = Convert.ToInt32(num18);
                                    int int32_15 = Convert.ToInt32(num3);
                                    int int32_16 = Convert.ToInt32(num2);
                                    WINtoXY(int32_13, int32_14, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    ++kLinePart;
                                    xPart1[kLinePart] = xCur;
                                    yPart1[kLinePart] = yCur;
                                    WINtoXY(int32_15, int32_16, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    xPart2[kLinePart] = xCur;
                                    yPart2[kLinePart] = yCur;
                                    iLineWid[kLinePart] = iWid;
                                    nPenPart[kLinePart] = nColor;
                                    break;
                                }
                                if (num20 < num11)
                                {
                                    num3 = num17 + num7 * Math.Cos(num12);
                                    num2 = num18 + num7 * Math.Sin(num12);
                                    int int32_17 = Convert.ToInt32(num17);
                                    int int32_18 = Convert.ToInt32(num18);
                                    int int32_19 = Convert.ToInt32(num3);
                                    int int32_20 = Convert.ToInt32(num2);
                                    WINtoXY(int32_17, int32_18, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    ++kLinePart;
                                    xPart1[kLinePart] = xCur;
                                    yPart1[kLinePart] = yCur;
                                    WINtoXY(int32_19, int32_20, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    xPart2[kLinePart] = xCur;
                                    yPart2[kLinePart] = yCur;
                                    iLineWid[kLinePart] = iWid;
                                    nPenPart[kLinePart] = nColor;
                                }
                                double num21 = num20 + num8;
                                if (num21 < num11)
                                {
                                    double num22 = num3 + num8 * Math.Cos(num12);
                                    double num23 = num2 + num8 * Math.Sin(num12);
                                    double num24 = num21 + num9;
                                    if (num24 >= num11)
                                    {
                                        num3 = x[i];
                                        num2 = y[i];
                                        int int32_21 = Convert.ToInt32(num22);
                                        int int32_22 = Convert.ToInt32(num23);
                                        int int32_23 = Convert.ToInt32(num3);
                                        int int32_24 = Convert.ToInt32(num2);
                                        WINtoXY(int32_21, int32_22, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                        ++kLinePart;
                                        xPart1[kLinePart] = xCur;
                                        yPart1[kLinePart] = yCur;
                                        WINtoXY(int32_23, int32_24, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                        xPart2[kLinePart] = xCur;
                                        yPart2[kLinePart] = yCur;
                                        iLineWid[kLinePart] = iWid;
                                        nPenPart[kLinePart] = nColor;
                                        break;
                                    }
                                    if (num24 < num11)
                                    {
                                        num3 = num22 + num9 * Math.Cos(num12);
                                        num2 = num23 + num9 * Math.Sin(num12);
                                        int int32_25 = Convert.ToInt32(num22);
                                        int int32_26 = Convert.ToInt32(num23);
                                        int int32_27 = Convert.ToInt32(num3);
                                        int int32_28 = Convert.ToInt32(num2);
                                        WINtoXY(int32_25, int32_26, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                        ++kLinePart;
                                        xPart1[kLinePart] = xCur;
                                        yPart1[kLinePart] = yCur;
                                        WINtoXY(int32_27, int32_28, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                        xPart2[kLinePart] = xCur;
                                        yPart2[kLinePart] = yCur;
                                        iLineWid[kLinePart] = iWid;
                                        nPenPart[kLinePart] = nColor;
                                    }
                                    num19 = num24 + num8;
                                    if (num19 < num11)
                                    {
                                        num17 = num3 + num8 * Math.Cos(num12);
                                        num18 = num2 + num8 * Math.Sin(num12);
                                    }
                                    else
                                        break;
                                }
                                else
                                    break;
                            }
                            while (num19 < num11);
                        }
                        if (iStyle == 6)
                        {
                            double num25 = x[i - 1];
                            double num26 = y[i - 1];
                            double num27 = 0.0;
                            do
                            {
                                double num28 = num27 + num7;
                                if (num28 >= num11)
                                {
                                    num3 = x[i];
                                    num2 = y[i];
                                    int int32_29 = Convert.ToInt32(num25);
                                    int int32_30 = Convert.ToInt32(num26);
                                    int int32_31 = Convert.ToInt32(num3);
                                    int int32_32 = Convert.ToInt32(num2);
                                    WINtoXY(int32_29, int32_30, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    ++kLinePart;
                                    xPart1[kLinePart] = xCur;
                                    yPart1[kLinePart] = yCur;
                                    WINtoXY(int32_31, int32_32, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    xPart2[kLinePart] = xCur;
                                    yPart2[kLinePart] = yCur;
                                    iLineWid[kLinePart] = iWid;
                                    nPenPart[kLinePart] = nColor;
                                    break;
                                }
                                if (num28 < num11)
                                {
                                    num3 = num25 + num7 * Math.Cos(num12);
                                    num2 = num26 + num7 * Math.Sin(num12);
                                    int int32_33 = Convert.ToInt32(num25);
                                    int int32_34 = Convert.ToInt32(num26);
                                    int int32_35 = Convert.ToInt32(num3);
                                    int int32_36 = Convert.ToInt32(num2);
                                    WINtoXY(int32_33, int32_34, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    ++kLinePart;
                                    xPart1[kLinePart] = xCur;
                                    yPart1[kLinePart] = yCur;
                                    WINtoXY(int32_35, int32_36, scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    xPart2[kLinePart] = xCur;
                                    yPart2[kLinePart] = yCur;
                                    iLineWid[kLinePart] = iWid;
                                    nPenPart[kLinePart] = nColor;
                                }
                                double num29 = num28 + num8;
                                if (num29 < num11)
                                {
                                    double num30 = num3 + num8 * Math.Cos(num12);
                                    double num31 = num2 + num8 * Math.Sin(num12);
                                    num3 = num30;
                                    num2 = num31;
                                    WINtoXY(Convert.ToInt32(num30), Convert.ToInt32(num31), scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    ++kPntPart;
                                    xPntPart[kPntPart] = xCur;
                                    yPntPart[kPntPart] = yCur;
                                    nBruPnt[kPntPart] = nColor;
                                    num27 = num29 + num8;
                                    if (num27 < num11)
                                    {
                                        num25 = num3 + num8 * Math.Cos(num12);
                                        num26 = num2 + num8 * Math.Sin(num12);
                                    }
                                    else
                                        break;
                                }
                                else
                                    break;
                            }
                            while (num27 < num11);
                        }
                        if (iStyle == 7)
                        {
                            double num32 = x[i - 1];
                            double num33 = y[i - 1];
                            double num34 = 0.0;
                            do
                            {
                                num34 += num8;
                                if (num34 < num11)
                                {
                                    num3 = num32 + num8 * Math.Cos(num12);
                                    num2 = num33 + num8 * Math.Sin(num12);
                                    num32 = num3;
                                    num33 = num2;
                                    WINtoXY(Convert.ToInt32(num32), Convert.ToInt32(num33), scaleToGeo, xBegX, yBegY, xBegWin, yBegWin, out xCur, out yCur);
                                    ++kPntPart;
                                    xPntPart[kPntPart] = xCur;
                                    yPntPart[kPntPart] = yCur;
                                    nBruPnt[kPntPart] = nColor;
                                }
                                else
                                    break;
                            }
                            while (num34 < num11);
                        }
                    }
                }
            }
        }

        public static void FormInputLine(
          int kLine,
          int[] k1,
          int[] k2,
          double[] xLin,
          double[] yLin,
          int[] nSymb,
          double[] dstLine,
          double[] rRad,
          double[] xRad,
          double[] yRad,
          double scaleWin,
          double xBeg,
          double yBeg,
          int xWin,
          int yWin,
          int[] nColLine,
          int[] iWd1,
          int[] iWd2,
          int[] iSt1,
          int[] iSt2,
          int[] nBase,
          double[] x,
          double[] y,
          double[] xit,
          double[] yit,
          double[] xr,
          double[] yr,
          int kSymbLine,
          int[] n1Sign,
          int[] n2Sign,
          out int kLinePart,
          double[] xPart1,
          double[] yPart1,
          double[] xPart2,
          double[] yPart2,
          int[] iLineWid,
          int[] nPenPart,
          out int kPntPart,
          double[] xPntPart,
          double[] yPntPart,
          int[] nBruPnt,
          double scaleToGeo)
        {
            double num1 = 3.1415926;
            double Dist = 0.0;
            kLinePart = 0;
            kPntPart = 0;
            double rd1 = 0.0;
            if (kLine == 0)
                return;
            int kArray = 999999;
            intArray(k1, ref kArray);
            intArray(k2, ref kArray);
            intArray(nSymb, ref kArray);
            doubleArray(dstLine, ref kArray);
            doubleArray(rRad, ref kArray);
            doubleArray(xRad, ref kArray);
            doubleArray(yRad, ref kArray);
            if (kLine > kArray)
            {
                int num2 = (int)MessageBox.Show("Индекс массива DrawInputLine");
            }
            else
            {
                int num3 = k2[kLine];
                kArray = 999999;
                doubleArray(xLin, ref kArray);
                doubleArray(yLin, ref kArray);
                doubleArray(x, ref kArray);
                doubleArray(y, ref kArray);
                doubleArray(xr, ref kArray);
                doubleArray(yr, ref kArray);
                doubleArray(xit, ref kArray);
                doubleArray(yit, ref kArray);
                if (num3 > kArray)
                {
                    int num4 = (int)MessageBox.Show("Индекс массива DrawInputLine");
                }
                else
                {
                    for (int i1 = 1; i1 <= kLine; ++i1)
                    {
                        int i2 = 0;
                        for (int i3 = 1; i3 <= kSymbLine; ++i3)
                        {
                            if (n2Sign[i3] > 0 && n2Sign[i3] == nSymb[i1])
                            {
                                i2 = n1Sign[i3];
                                break;
                            }
                        }
                        if (i2 == 0)
                        {
                            for (int i4 = 1; i4 <= kSymbLine; ++i4)
                            {
                                if (n1Sign[i4] > 0 && n1Sign[i4] == nSymb[i1])
                                {
                                    i2 = n1Sign[i4];
                                    break;
                                }
                            }
                        }
                        int nColor = nColLine[i2];
                        int iWid1 = iWd1[i2];
                        int iWid2 = iWd2[i2];
                        int iStyle1 = iSt1[i2];
                        int iStyle2 = iSt2[i2];
                        int num5 = nBase[i2];
                        double num6 = dstLine[i1];
                        if (num6 == 0.0)
                            Dist = 1.0;
                        if (num6 > 0.0)
                            Dist = 0.5 * num6;
                        int num7 = k1[i1];
                        int num8 = k2[i1];
                        int k = -1;
                        int i5 = -1;
                        int xWin1;
                        int yWin1;
                        for (int i6 = num7; i6 <= num8; ++i6)
                        {
                            XYtoWIN(xLin[i6], yLin[i6], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                            ++k;
                            x[k] = (double)xWin1;
                            y[k] = (double)yWin1;
                            ++i5;
                            xr[i5] = xLin[i6];
                            yr[i5] = yLin[i6];
                        }
                        int iStyle3 = iStyle1;
                        int num9 = iWid1;
                        int iLine;
                        int iBlank;
                        int iDop;
                        StyleParameters(iStyle3, out iLine, out iBlank, out iDop);
                        double xCur;
                        double yCur;
                        if (rRad[i1] > 0.0)
                        {
                            if (rRad[i1] == 1.0)
                            {
                                SplineToSpl(i5, xr, yr, out k, xit, yit);
                                for (int i7 = 0; i7 <= k; ++i7)
                                {
                                    XYtoWIN(xit[i7], yit[i7], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                                    x[i7] = (double)xWin1;
                                    y[i7] = (double)yWin1;
                                }
                            }
                            int num10 = 0;
                            for (int i8 = 1; i8 <= k; ++i8)
                            {
                                xCur = x[i8] - x[i8 - 1];
                                yCur = y[i8] - y[i8 - 1];
                                int int32 = Convert.ToInt32(Math.Sqrt(xCur * xCur + yCur * yCur));
                                num10 += int32;
                                if (num10 >= iLine)
                                {
                                    num10 = i8;
                                    break;
                                }
                            }
                            int num11 = 0;
                            for (int i9 = 1; i9 <= k; ++i9)
                            {
                                xCur = x[i9] - x[i9 - 1];
                                yCur = y[i9] - y[i9 - 1];
                                int int32 = Convert.ToInt32(Math.Sqrt(xCur * xCur + yCur * yCur));
                                num11 += int32;
                                if (num11 >= iBlank)
                                {
                                    num11 = i9;
                                    break;
                                }
                            }
                            int num12 = 0;
                            for (int i10 = 1; i10 <= k; ++i10)
                            {
                                xCur = x[i10] - x[i10 - 1];
                                yCur = y[i10] - y[i10 - 1];
                                int int32 = Convert.ToInt32(Math.Sqrt(xCur * xCur + yCur * yCur));
                                num12 += int32;
                                if (num12 >= iDop)
                                {
                                    num12 = i10;
                                    break;
                                }
                            }
                            if (num5 < 8)
                            {
                                if (iStyle3 == 1 || iStyle3 == 2)
                                {
                                    WINtoXY(Convert.ToInt32(x[1]), Convert.ToInt32(y[1]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                    ++kLinePart;
                                    xPart1[kLinePart] = xCur;
                                    yPart1[kLinePart] = yCur;
                                    double num13 = 0.0;
                                    double num14 = (double)(iLine / 2);
                                    for (int i11 = 1; i11 <= k; ++i11)
                                    {
                                        xCur = x[i11] - x[i11 - 1];
                                        yCur = y[i11] - y[i11 - 1];
                                        num13 += Math.Sqrt(xCur * xCur + yCur * yCur);
                                        if (i11 == k)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i11]), Convert.ToInt32(y[i11]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            xPart2[kLinePart] = xCur;
                                            yPart2[kLinePart] = yCur;
                                            iLineWid[kLinePart] = num9;
                                            nPenPart[kLinePart] = nColor;
                                            break;
                                        }
                                        if (num13 >= num14)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i11]), Convert.ToInt32(y[i11]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            xPart2[kLinePart] = xCur;
                                            yPart2[kLinePart] = yCur;
                                            iLineWid[kLinePart] = num9;
                                            nPenPart[kLinePart] = nColor;
                                            num14 = num13 + (double)(iLine / 2);
                                            ++kLinePart;
                                            xPart1[kLinePart] = xCur;
                                            yPart1[kLinePart] = yCur;
                                        }
                                    }
                                }
                                if (iStyle3 == 3 || iStyle3 == 4)
                                {
                                    int num15 = iLine + iBlank + iDop;
                                    WINtoXY(Convert.ToInt32(x[1]), Convert.ToInt32(y[1]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                    ++kLinePart;
                                    xPart1[kLinePart] = xCur;
                                    yPart1[kLinePart] = yCur;
                                    double num16 = 0.0;
                                    double num17 = (double)iLine;
                                    double num18 = (double)num15;
                                    for (int i12 = 1; i12 <= k; ++i12)
                                    {
                                        xCur = x[i12] - x[i12 - 1];
                                        yCur = y[i12] - y[i12 - 1];
                                        num16 += Math.Sqrt(xCur * xCur + yCur * yCur);
                                        if (i12 == k)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i12]), Convert.ToInt32(y[i12]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            xPart2[kLinePart] = xCur;
                                            yPart2[kLinePart] = yCur;
                                            iLineWid[kLinePart] = num9;
                                            nPenPart[kLinePart] = nColor;
                                            break;
                                        }
                                        if (num16 >= num17)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i12]), Convert.ToInt32(y[i12]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            xPart2[kLinePart] = xCur;
                                            yPart2[kLinePart] = yCur;
                                            iLineWid[kLinePart] = num9;
                                            nPenPart[kLinePart] = nColor;
                                            num17 = num16 + (double)iBlank + (double)iLine;
                                            num18 = num16 + (double)iBlank;
                                        }
                                        if (num16 >= num18)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i12]), Convert.ToInt32(y[i12]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            ++kLinePart;
                                            xPart1[kLinePart] = xCur;
                                            yPart1[kLinePart] = yCur;
                                            num17 = num16 + (double)iLine;
                                            num18 = num16 + (double)iLine + (double)iBlank;
                                        }
                                    }
                                }
                                if (iStyle3 == 5)
                                {
                                    double num19 = 0.0;
                                    for (int i13 = 1; i13 <= k; ++i13)
                                    {
                                        xCur = x[i13] - x[i13 - 1];
                                        yCur = y[i13] - y[i13 - 1];
                                        num19 += Math.Sqrt(xCur * xCur + yCur * yCur);
                                    }
                                    WINtoXY(Convert.ToInt32(x[1]), Convert.ToInt32(y[1]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                    ++kLinePart;
                                    xPart1[kLinePart] = xCur;
                                    yPart1[kLinePart] = yCur;
                                    double num20 = 0.0;
                                    double num21 = (double)iLine;
                                    double num22 = num19;
                                    double num23 = num19;
                                    double num24 = num19;
                                    for (int i14 = 1; i14 <= k; ++i14)
                                    {
                                        xCur = x[i14] - x[i14 - 1];
                                        yCur = y[i14] - y[i14 - 1];
                                        num20 += Math.Sqrt(xCur * xCur + yCur * yCur);
                                        if (i14 == k)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i14]), Convert.ToInt32(y[i14]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            xPart2[kLinePart] = xCur;
                                            yPart2[kLinePart] = yCur;
                                            iLineWid[kLinePart] = num9;
                                            nPenPart[kLinePart] = nColor;
                                            break;
                                        }
                                        if (num20 >= num21)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i14]), Convert.ToInt32(y[i14]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            xPart2[kLinePart] = xCur;
                                            yPart2[kLinePart] = yCur;
                                            iLineWid[kLinePart] = num9;
                                            nPenPart[kLinePart] = nColor;
                                            num21 = num19;
                                            num22 = num20 + (double)iBlank;
                                            num23 = num19;
                                            num24 = num19;
                                        }
                                        if (num20 >= num22)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i14]), Convert.ToInt32(y[i14]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            ++kLinePart;
                                            xPart1[kLinePart] = xCur;
                                            yPart1[kLinePart] = yCur;
                                            num21 = num19;
                                            num22 = num19;
                                            num23 = num20 + (double)iDop;
                                            num24 = num19;
                                        }
                                        if (num20 >= num23)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i14]), Convert.ToInt32(y[i14]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            xPart2[kLinePart] = xCur;
                                            yPart2[kLinePart] = yCur;
                                            iLineWid[kLinePart] = num9;
                                            nPenPart[kLinePart] = nColor;
                                            num21 = num19;
                                            num22 = num19;
                                            num23 = num19;
                                            num24 = num20 + (double)iBlank;
                                        }
                                        if (num20 >= num24)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i14]), Convert.ToInt32(y[i14]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            ++kLinePart;
                                            xPart1[kLinePart] = xCur;
                                            yPart1[kLinePart] = yCur;
                                            num21 = num20 + (double)iLine;
                                            num22 = num19;
                                            num23 = num19;
                                            num24 = num19;
                                        }
                                    }
                                }
                                if (iStyle3 == 6)
                                {
                                    double num25 = 0.0;
                                    for (int i15 = 1; i15 <= k; ++i15)
                                    {
                                        xCur = x[i15] - x[i15 - 1];
                                        yCur = y[i15] - y[i15 - 1];
                                        num25 += Math.Sqrt(xCur * xCur + yCur * yCur);
                                    }
                                    WINtoXY(Convert.ToInt32(x[1]), Convert.ToInt32(y[1]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                    ++kLinePart;
                                    xPart1[kLinePart] = xCur;
                                    yPart1[kLinePart] = yCur;
                                    double num26 = 0.0;
                                    double num27 = (double)iLine;
                                    double num28 = num25;
                                    double num29 = num25;
                                    double num30 = num25;
                                    for (int i16 = 1; i16 <= k; ++i16)
                                    {
                                        xCur = x[i16] - x[i16 - 1];
                                        yCur = y[i16] - y[i16 - 1];
                                        num26 += Math.Sqrt(xCur * xCur + yCur * yCur);
                                        if (i16 == k)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i16]), Convert.ToInt32(y[i16]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            xPart2[kLinePart] = xCur;
                                            yPart2[kLinePart] = yCur;
                                            iLineWid[kLinePart] = num9;
                                            nPenPart[kLinePart] = nColor;
                                            break;
                                        }
                                        if (num26 >= num27)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i16]), Convert.ToInt32(y[i16]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            xPart2[kLinePart] = xCur;
                                            yPart2[kLinePart] = yCur;
                                            iLineWid[kLinePart] = num9;
                                            nPenPart[kLinePart] = nColor;
                                            num27 = num25;
                                            num28 = num26 + (double)iBlank;
                                            num29 = num25;
                                            num30 = num25;
                                        }
                                        if (num26 >= num28)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i16]), Convert.ToInt32(y[i16]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            ++kLinePart;
                                            xPart1[kLinePart] = xCur;
                                            yPart1[kLinePart] = yCur;
                                            num27 = num25;
                                            num28 = num25;
                                            num29 = num26 + (double)iDop;
                                            num30 = num25;
                                        }
                                        if (num26 >= num29)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i16]), Convert.ToInt32(y[i16]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            xPart2[kLinePart] = xCur;
                                            yPart2[kLinePart] = yCur;
                                            iLineWid[kLinePart] = num9;
                                            nPenPart[kLinePart] = nColor;
                                            num27 = num25;
                                            num28 = num25;
                                            num29 = num25;
                                            num30 = num26 + (double)iBlank;
                                        }
                                        if (num26 >= num30)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i16]), Convert.ToInt32(y[i16]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            ++kLinePart;
                                            xPart1[kLinePart] = xCur;
                                            yPart1[kLinePart] = yCur;
                                            num27 = num26 + (double)iLine;
                                            num28 = num25;
                                            num29 = num25;
                                            num30 = num25;
                                        }
                                    }
                                }
                                if (iStyle3 == 7)
                                {
                                    int i17 = 0;
                                    do
                                    {
                                        i17 += num11;
                                        if (i17 < k)
                                        {
                                            WINtoXY(Convert.ToInt32(x[i17]), Convert.ToInt32(y[i17]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            ++kPntPart;
                                            xPntPart[kPntPart] = xCur;
                                            yPntPart[kPntPart] = yCur;
                                            nBruPnt[kPntPart] = nColor;
                                        }
                                        else
                                            break;
                                    }
                                    while (i17 < k);
                                }
                            }
                            if (num5 == 8)
                            {
                                for (int i18 = 1; i18 <= 2; ++i18)
                                {
                                    if (rRad[i1] > 1.0)
                                    {
                                        if (i18 == 1)
                                        {
                                            rd1 = rRad[i1] - Dist;
                                            iStyle3 = iStyle1;
                                            num9 = iWid1;
                                        }
                                        if (i18 == 2)
                                        {
                                            rd1 = rRad[i1] + Dist;
                                            iStyle3 = iStyle2;
                                            num9 = iWid2;
                                        }
                                        double xrd1 = xRad[i1];
                                        double yrd1 = yRad[i1];
                                        ParallelArcCircle(i5, ref xr, ref yr, ref rd1, ref xrd1, ref yrd1, out k, ref x, ref y, out double _, out double _, out double _, ref xit, ref yit);
                                        if (k < 2)
                                            continue;
                                    }
                                    if (rRad[i1] == 1.0)
                                    {
                                        double ySel;
                                        double xSel = ySel = 0.0;
                                        if (i18 == 1)
                                        {
                                            xCur = xr[1] - xr[0];
                                            yCur = yr[1] - yr[0];
                                            double num31 = Math.Atan2(yCur, xCur);
                                            if (num31 < 0.0)
                                                num31 += 2.0 * num1;
                                            double num32 = num31 - 0.5 * num1;
                                            if (num32 < 0.0)
                                                num32 += 2.0 * num1;
                                            double num33 = 0.5 * (xr[1] + xr[0]);
                                            double num34 = 0.5 * (yr[1] + yr[0]);
                                            xSel = num33 + Dist * Math.Cos(num32);
                                            ySel = num34 + Dist * Math.Sin(num32);
                                            iStyle3 = iStyle1;
                                            num9 = iWid1;
                                        }
                                        if (i18 == 2)
                                        {
                                            xCur = xr[1] - xr[0];
                                            yCur = yr[1] - yr[0];
                                            double num35 = Math.Atan2(yCur, xCur);
                                            if (num35 < 0.0)
                                                num35 += 2.0 * num1;
                                            double num36 = num35 - 0.5 * num1;
                                            if (num36 < 0.0)
                                                num36 += 2.0 * num1;
                                            double num37 = 0.5 * (xr[1] + xr[0]);
                                            double num38 = 0.5 * (yr[1] + yr[0]);
                                            xSel = num37 - Dist * Math.Cos(num36);
                                            ySel = num38 - Dist * Math.Sin(num36);
                                            iStyle3 = iStyle2;
                                            num9 = iWid2;
                                        }
                                        ParallelLine(xSel, ySel, Dist, i5, ref xr, ref yr, out k, ref x, ref y);
                                        int ks;
                                        SplineToSpl(k, x, y, out ks, xit, yit);
                                        k = ks;
                                        for (int i19 = 0; i19 <= k; ++i19)
                                        {
                                            x[i19] = xit[i19];
                                            y[i19] = yit[i19];
                                        }
                                    }
                                    for (int i20 = 0; i20 <= k; ++i20)
                                    {
                                        XYtoWIN(x[i20], y[i20], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                                        x[i20] = (double)xWin1;
                                        y[i20] = (double)yWin1;
                                    }
                                    if (iStyle3 == 1 || iStyle3 == 2)
                                    {
                                        for (int i21 = 1; i21 <= k; ++i21)
                                        {
                                            int int32_1 = Convert.ToInt32(x[i21 - 1]);
                                            int int32_2 = Convert.ToInt32(y[i21 - 1]);
                                            int int32_3 = Convert.ToInt32(x[i21]);
                                            int int32_4 = Convert.ToInt32(y[i21]);
                                            WINtoXY(int32_1, int32_2, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            ++kLinePart;
                                            xPart1[kLinePart] = xCur;
                                            yPart1[kLinePart] = yCur;
                                            WINtoXY(int32_3, int32_4, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            xPart2[kLinePart] = xCur;
                                            yPart2[kLinePart] = yCur;
                                            iLineWid[kLinePart] = num9;
                                            nPenPart[kLinePart] = nColor;
                                        }
                                    }
                                    int num39;
                                    if (iStyle3 == 3 || iStyle3 == 4)
                                    {
                                        int num40 = 0;
                                        num39 = 0;
                                        int num41;
                                        do
                                        {
                                            num41 = num40 + num10;
                                            if (num40 < k && num41 >= k)
                                            {
                                                if (k - num40 >= 2)
                                                {
                                                    for (int i22 = num40 + 1; i22 <= k; ++i22)
                                                    {
                                                        int int32_5 = Convert.ToInt32(x[i22 - 1]);
                                                        int int32_6 = Convert.ToInt32(y[i22 - 1]);
                                                        int int32_7 = Convert.ToInt32(x[i22]);
                                                        int int32_8 = Convert.ToInt32(y[i22]);
                                                        WINtoXY(int32_5, int32_6, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                        ++kLinePart;
                                                        xPart1[kLinePart] = xCur;
                                                        yPart1[kLinePart] = yCur;
                                                        WINtoXY(int32_7, int32_8, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                        xPart2[kLinePart] = xCur;
                                                        yPart2[kLinePart] = yCur;
                                                        iLineWid[kLinePart] = num9;
                                                        nPenPart[kLinePart] = nColor;
                                                    }
                                                    break;
                                                }
                                                break;
                                            }
                                            for (int i23 = num40 + 1; i23 <= num41; ++i23)
                                            {
                                                int int32_9 = Convert.ToInt32(x[i23 - 1]);
                                                int int32_10 = Convert.ToInt32(y[i23 - 1]);
                                                int int32_11 = Convert.ToInt32(x[i23]);
                                                int int32_12 = Convert.ToInt32(y[i23]);
                                                WINtoXY(int32_9, int32_10, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                ++kLinePart;
                                                xPart1[kLinePart] = xCur;
                                                yPart1[kLinePart] = yCur;
                                                WINtoXY(int32_11, int32_12, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                xPart2[kLinePart] = xCur;
                                                yPart2[kLinePart] = yCur;
                                                iLineWid[kLinePart] = num9;
                                                nPenPart[kLinePart] = nColor;
                                            }
                                            num40 = num41 + num11;
                                        }
                                        while (num40 < k && num41 < k);
                                    }
                                    if (iStyle3 == 5)
                                    {
                                        int num42 = 0;
                                        num39 = 0;
                                        int num43;
                                        do
                                        {
                                            int num44 = num42 + num10;
                                            if (num42 < k && num44 >= k)
                                            {
                                                if (k - num42 >= 2)
                                                {
                                                    for (int i24 = num42 + 1; i24 <= k; ++i24)
                                                    {
                                                        int int32_13 = Convert.ToInt32(x[i24 - 1]);
                                                        int int32_14 = Convert.ToInt32(y[i24 - 1]);
                                                        int int32_15 = Convert.ToInt32(x[i24]);
                                                        int int32_16 = Convert.ToInt32(y[i24]);
                                                        WINtoXY(int32_13, int32_14, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                        ++kLinePart;
                                                        xPart1[kLinePart] = xCur;
                                                        yPart1[kLinePart] = yCur;
                                                        WINtoXY(int32_15, int32_16, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                        xPart2[kLinePart] = xCur;
                                                        yPart2[kLinePart] = yCur;
                                                        iLineWid[kLinePart] = num9;
                                                        nPenPart[kLinePart] = nColor;
                                                    }
                                                    break;
                                                }
                                                break;
                                            }
                                            for (int i25 = num42 + 1; i25 <= num44; ++i25)
                                            {
                                                int int32_17 = Convert.ToInt32(x[i25 - 1]);
                                                int int32_18 = Convert.ToInt32(y[i25 - 1]);
                                                int int32_19 = Convert.ToInt32(x[i25]);
                                                int int32_20 = Convert.ToInt32(y[i25]);
                                                WINtoXY(int32_17, int32_18, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                ++kLinePart;
                                                xPart1[kLinePart] = xCur;
                                                yPart1[kLinePart] = yCur;
                                                WINtoXY(int32_19, int32_20, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                xPart2[kLinePart] = xCur;
                                                yPart2[kLinePart] = yCur;
                                                iLineWid[kLinePart] = num9;
                                                nPenPart[kLinePart] = nColor;
                                            }
                                            int num45 = num44 + num11;
                                            if (num45 < k)
                                            {
                                                num43 = num45 + num12;
                                                if (num43 <= k)
                                                {
                                                    for (int i26 = num45 + 1; i26 <= num43; ++i26)
                                                    {
                                                        int int32_21 = Convert.ToInt32(x[i26 - 1]);
                                                        int int32_22 = Convert.ToInt32(y[i26 - 1]);
                                                        int int32_23 = Convert.ToInt32(x[i26]);
                                                        int int32_24 = Convert.ToInt32(y[i26]);
                                                        WINtoXY(int32_21, int32_22, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                        ++kLinePart;
                                                        xPart1[kLinePart] = xCur;
                                                        yPart1[kLinePart] = yCur;
                                                        WINtoXY(int32_23, int32_24, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                        xPart2[kLinePart] = xCur;
                                                        yPart2[kLinePart] = yCur;
                                                        iLineWid[kLinePart] = num9;
                                                        nPenPart[kLinePart] = nColor;
                                                    }
                                                    num42 = num43 + num11;
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                        while (num42 < k && num43 < k);
                                    }
                                    if (iStyle3 == 6)
                                    {
                                        int num46 = 0;
                                        num39 = 0;
                                        int num47;
                                        do
                                        {
                                            num47 = num46 + num10;
                                            if (num46 < k && num47 >= k)
                                            {
                                                if (k - num46 >= 2)
                                                {
                                                    for (int i27 = num46 + 1; i27 <= k; ++i27)
                                                    {
                                                        int int32_25 = Convert.ToInt32(x[i27 - 1]);
                                                        int int32_26 = Convert.ToInt32(y[i27 - 1]);
                                                        int int32_27 = Convert.ToInt32(x[i27]);
                                                        int int32_28 = Convert.ToInt32(y[i27]);
                                                        WINtoXY(int32_25, int32_26, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                        ++kLinePart;
                                                        xPart1[kLinePart] = xCur;
                                                        yPart1[kLinePart] = yCur;
                                                        WINtoXY(int32_27, int32_28, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                        xPart2[kLinePart] = xCur;
                                                        yPart2[kLinePart] = yCur;
                                                        iLineWid[kLinePart] = num9;
                                                        nPenPart[kLinePart] = nColor;
                                                    }
                                                    break;
                                                }
                                                break;
                                            }
                                            for (int i28 = num46 + 1; i28 <= num47; ++i28)
                                            {
                                                int int32_29 = Convert.ToInt32(x[i28 - 1]);
                                                int int32_30 = Convert.ToInt32(y[i28 - 1]);
                                                int int32_31 = Convert.ToInt32(x[i28]);
                                                int int32_32 = Convert.ToInt32(y[i28]);
                                                WINtoXY(int32_29, int32_30, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                ++kLinePart;
                                                xPart1[kLinePart] = xCur;
                                                yPart1[kLinePart] = yCur;
                                                WINtoXY(int32_31, int32_32, scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                xPart2[kLinePart] = xCur;
                                                yPart2[kLinePart] = yCur;
                                                iLineWid[kLinePart] = num9;
                                                nPenPart[kLinePart] = nColor;
                                            }
                                            int i29 = num47 + num11 + num12;
                                            if (i29 < k)
                                            {
                                                WINtoXY(Convert.ToInt32(x[i29]), Convert.ToInt32(y[i29]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                ++kPntPart;
                                                xPntPart[kPntPart] = xCur;
                                                yPntPart[kPntPart] = yCur;
                                                nBruPnt[kPntPart] = nColor;
                                                num46 = i29 + 2 * num11;
                                            }
                                            else
                                                break;
                                        }
                                        while (num46 < k && num47 < k);
                                    }
                                    if (iStyle3 == 7)
                                    {
                                        int i30 = 0;
                                        do
                                        {
                                            i30 += num11;
                                            if (i30 < k)
                                            {
                                                WINtoXY(Convert.ToInt32(x[i30]), Convert.ToInt32(y[i30]), scaleToGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                ++kPntPart;
                                                xPntPart[kPntPart] = xCur;
                                                yPntPart[kPntPart] = yCur;
                                                nBruPnt[kPntPart] = nColor;
                                            }
                                            else
                                                break;
                                        }
                                        while (i30 < k);
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (num5 < 8)
                                FormLineStyle(nColor, iStyle1, iWid1, i5, xr, yr, x, y, scaleWin, xBeg, yBeg, xWin, yWin, ref kLinePart, xPart1, yPart1, xPart2, yPart2, iLineWid, nPenPart, ref kPntPart, xPntPart, yPntPart, nBruPnt, scaleToGeo);
                            if (num5 == 8)
                            {
                                xCur = xr[1] - xr[0];
                                yCur = yr[1] - yr[0];
                                double num48 = Math.Atan2(yCur, xCur);
                                if (num48 < 0.0)
                                    num48 += 2.0 * num1;
                                double num49 = num48 - 0.5 * num1;
                                if (num49 < 0.0)
                                    num49 += 2.0 * num1;
                                double num50 = 0.5 * (xr[1] + xr[0]);
                                double num51 = 0.5 * (yr[1] + yr[0]);
                                double xSel1 = num50 + Dist * Math.Cos(num49);
                                double ySel1 = num51 + Dist * Math.Sin(num49);
                                int k2_1 = 0;
                                ParallelLine(xSel1, ySel1, Dist, i5, ref xr, ref yr, out k2_1, ref xit, ref yit);
                                if (k2_1 >= 1)
                                {
                                    FormLineStyle(nColor, iStyle1, iWid1, k2_1, xit, yit, x, y, scaleWin, xBeg, yBeg, xWin, yWin, ref kLinePart, xPart1, yPart1, xPart2, yPart2, iLineWid, nPenPart, ref kPntPart, xPntPart, yPntPart, nBruPnt, scaleToGeo);
                                    double xSel2 = num50 - Dist * Math.Cos(num49);
                                    double ySel2 = num51 - Dist * Math.Sin(num49);
                                    k2_1 = 0;
                                    ParallelLine(xSel2, ySel2, Dist, i5, ref xr, ref yr, out k2_1, ref xit, ref yit);
                                    if (k2_1 >= 1)
                                        FormLineStyle(nColor, iStyle2, iWid2, k2_1, xit, yit, x, y, scaleWin, xBeg, yBeg, xWin, yWin, ref kLinePart, xPart1, yPart1, xPart2, yPart2, iLineWid, nPenPart, ref kPntPart, xPntPart, yPntPart, nBruPnt, scaleToGeo);
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void InputLineItem(
          int kPnt,
          double[] xPnt,
          double[] yPnt,
          int kLine,
          int[] k1,
          int[] k2,
          double[] xLin,
          double[] yLin,
          int[] nSymb,
          double[] rRad,
          ref int kItem,
          int[] numSign,
          int[] numItem,
          double[] xItem,
          double[] yItem,
          double[] az,
          double[] xr,
          double[] yr,
          double[] x,
          double[] y,
          int kSymbLine,
          int[] nItem,
          int[] n1Sign,
          int[] n2Sign,
          int[] iDensity,
          int[] iSt1,
          int[] iSt2,
          string[] sInscr,
          double[] hInscr,
          double scaleWin,
          double xBeg,
          double yBeg,
          int xWin,
          int yWin,
          double scaleGeo)
        {
            double num1 = 3.1415926;
            double num2 = 0.254;
            string str1 = "";
            double num3 = 0.0;
            Cursor.Current = Cursors.WaitCursor;
            int kArray1 = 999999;
            int num4 = k2[kLine];
            doubleArray(xLin, ref kArray1);
            doubleArray(yLin, ref kArray1);
            if (num4 > kArray1)
            {
                int num5 = (int)MessageBox.Show("Индекс массива InputLineItem");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(xItem, ref kArray2);
                doubleArray(yItem, ref kArray2);
                doubleArray(az, ref kArray2);
                kArray2 -= 2;
                if (kLine == 0)
                    return;
                for (int i1 = 1; i1 <= kLine; ++i1)
                {
                    str1 = "";
                    int num6 = 0;
                    int i2 = 0;
                    for (int i3 = 1; i3 <= kSymbLine; ++i3)
                    {
                        if (n2Sign[i3] > 0 && n2Sign[i3] == nSymb[i1])
                        {
                            i2 = n1Sign[i3];
                            break;
                        }
                    }
                    if (i2 == 0)
                    {
                        for (int i4 = 1; i4 <= kSymbLine; ++i4)
                        {
                            if (n1Sign[i4] > 0 && n1Sign[i4] == nSymb[i1])
                            {
                                i2 = n1Sign[i4];
                                break;
                            }
                        }
                    }
                    string text = string.Format("{0}", (object)nSymb[i1]);
                    if (i2 == 0)
                    {
                        int num7 = (int)MessageBox.Show(text, "Ошибка строки кода пользователя", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                        break;
                    }
                    int iStyle = iSt1[i2];
                    int num8 = nItem[i2];
                    string str2 = sInscr[i2];
                    if (iDensity[i2] <= 1 && num8 != 0)
                    {
                        if (str2 != "")
                        {
                            double num9 = hInscr[i2] * (double)str2.Length;
                            num6 = Convert.ToInt32(num9 / num2);
                            num3 = num9 / num2;
                        }
                        int iLine;
                        int iBlank;
                        int iDop;
                        StyleParameters(iStyle, out iLine, out iBlank, out iDop);
                        int num10 = k1[i1];
                        int num11 = k2[i1];
                        int ks = -1;
                        int k = -1;
                        int xWin1;
                        int yWin1;
                        for (int i5 = num10; i5 <= num11; ++i5)
                        {
                            ++k;
                            xr[k] = xLin[i5];
                            yr[k] = yLin[i5];
                            XYtoWIN(xLin[i5], yLin[i5], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                            ++ks;
                            x[ks] = (double)xWin1;
                            y[ks] = (double)yWin1;
                        }
                        double xCur;
                        double yCur;
                        if (rRad[i1] > 0.0)
                        {
                            if (rRad[i1] > 1.0 && num6 > 0)
                            {
                                if (ks >= num6)
                                {
                                    int i6 = ks / 2;
                                    int i7 = i6 - num6 / 2;
                                    int i8 = i6 + num6 / 2;
                                    if (i7 >= 0 && i8 < ks)
                                    {
                                        xWin1 = Convert.ToInt32(x[i6]);
                                        yWin1 = Convert.ToInt32(y[i6]);
                                        WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                        ++kItem;
                                        numSign[kItem] = i2;
                                        numItem[kItem] = num8;
                                        xItem[kItem] = xCur;
                                        yItem[kItem] = yCur;
                                        double x1 = x[i8] - x[i7];
                                        double num12 = Math.Atan2(y[i8] - y[i7], x1);
                                        if (num12 < 0.0)
                                            num12 += 2.0 * num1;
                                        az[kItem] = num12;
                                    }
                                }
                            }
                            else
                            {
                                if (rRad[i1] == 1.0)
                                {
                                    SplineToSpl(k, xr, yr, out ks, x, y);
                                    for (int i9 = 0; i9 <= ks; ++i9)
                                    {
                                        XYtoWIN(x[i9], y[i9], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                                        x[i9] = (double)xWin1;
                                        y[i9] = (double)yWin1;
                                    }
                                    if (num6 > 0)
                                    {
                                        if (ks >= num6)
                                        {
                                            int num13 = 1;
                                            int num14;
                                            int num15 = num14 = 0;
                                            for (int i10 = 1; i10 <= ks; ++i10)
                                            {
                                                int num16 = 0;
                                                for (int i11 = 0; i11 <= kPnt; ++i11)
                                                {
                                                    XYtoWIN(xPnt[i11], yPnt[i11], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                                                    xCur = 1.0 * (double)xWin1;
                                                    yCur = 1.0 * (double)yWin1;
                                                    double num17 = x[i10] - xCur;
                                                    double num18 = y[i10] - yCur;
                                                    if (Math.Sqrt(num17 * num17 + num18 * num18) < 0.1)
                                                    {
                                                        num16 = i10;
                                                        break;
                                                    }
                                                }
                                                if (num16 != 0 && num16 - num13 >= num6)
                                                {
                                                    int i12 = (num13 + num16) / 2;
                                                    int i13 = i12 - num6 / 2;
                                                    int i14 = i12 + num6 / 2;
                                                    double x2 = x[i14] - x[i13];
                                                    double num19 = Math.Atan2(y[i14] - y[i13], x2);
                                                    if (num19 < 0.0)
                                                        num19 += 2.0 * num1;
                                                    xWin1 = Convert.ToInt32(x[i12]);
                                                    yWin1 = Convert.ToInt32(y[i12]);
                                                    WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                    ++kItem;
                                                    numSign[kItem] = i2;
                                                    numItem[kItem] = num8;
                                                    xItem[kItem] = xCur;
                                                    yItem[kItem] = yCur;
                                                    az[kItem] = num19;
                                                    num13 = num16 + 1;
                                                }
                                            }
                                            continue;
                                        }
                                        continue;
                                    }
                                }
                                int num20 = 0;
                                for (int i15 = 1; i15 <= ks; ++i15)
                                {
                                    double num21 = x[i15] - x[i15 - 1];
                                    double num22 = y[i15] - y[i15 - 1];
                                    int int32 = Convert.ToInt32(Math.Sqrt(num21 * num21 + num22 * num22));
                                    num20 += int32;
                                    if (num20 >= iLine)
                                    {
                                        num20 = i15;
                                        break;
                                    }
                                }
                                int num23 = 0;
                                for (int i16 = 1; i16 <= ks; ++i16)
                                {
                                    double num24 = x[i16] - x[i16 - 1];
                                    double num25 = y[i16] - y[i16 - 1];
                                    int int32 = Convert.ToInt32(Math.Sqrt(num24 * num24 + num25 * num25));
                                    num23 += int32;
                                    if (num23 >= iBlank)
                                    {
                                        num23 = i16;
                                        break;
                                    }
                                }
                                int num26 = 0;
                                for (int i17 = 1; i17 <= ks; ++i17)
                                {
                                    double num27 = x[i17] - x[i17 - 1];
                                    double num28 = y[i17] - y[i17 - 1];
                                    int int32 = Convert.ToInt32(Math.Sqrt(num27 * num27 + num28 * num28));
                                    num26 += int32;
                                    if (num26 >= iDop)
                                    {
                                        num26 = i17;
                                        break;
                                    }
                                }
                                int num29;
                                if (iStyle == 1 || iStyle == 2 || iStyle == 7)
                                {
                                    int i18 = 0;
                                    num29 = 0;
                                    int i19;
                                    do
                                    {
                                        i19 = i18 + num20;
                                        if (i19 <= ks)
                                        {
                                            int i20 = (i18 + i19) / 2;
                                            xWin1 = Convert.ToInt32(x[i20]);
                                            yWin1 = Convert.ToInt32(y[i20]);
                                            WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            ++kItem;
                                            numSign[kItem] = i2;
                                            numItem[kItem] = num8;
                                            xItem[kItem] = xCur;
                                            yItem[kItem] = yCur;
                                            double x3 = x[i19] - x[i18];
                                            double num30 = Math.Atan2(y[i19] - y[i18], x3);
                                            if (num30 < 0.0)
                                                num30 += 2.0 * num1;
                                            az[kItem] = num30;
                                            i18 = i19 + num20;
                                        }
                                        else
                                            break;
                                    }
                                    while (i18 < ks && i19 < ks);
                                }
                                if (iStyle == 3)
                                {
                                    int i21 = 0;
                                    num29 = 0;
                                    int i22;
                                    do
                                    {
                                        i22 = i21 + num20;
                                        if (i22 <= ks)
                                        {
                                            int i23 = (i21 + i22) / 2;
                                            xWin1 = Convert.ToInt32(x[i23]);
                                            yWin1 = Convert.ToInt32(y[i23]);
                                            WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            ++kItem;
                                            numSign[kItem] = i2;
                                            numItem[kItem] = num8;
                                            xItem[kItem] = xCur;
                                            yItem[kItem] = yCur;
                                            double x4 = x[i22] - x[i21];
                                            double num31 = Math.Atan2(y[i22] - y[i21], x4);
                                            if (num31 < 0.0)
                                                num31 += 2.0 * num1;
                                            az[kItem] = num31;
                                            i21 = i22 + num23;
                                        }
                                        else
                                            break;
                                    }
                                    while (i21 < ks && i22 < ks);
                                }
                                if (iStyle == 4)
                                {
                                    int i24 = 0;
                                    num29 = 0;
                                    int num32 = 0;
                                    int i25;
                                    do
                                    {
                                        i25 = i24 + num20;
                                        if (i25 <= ks)
                                        {
                                            ++num32;
                                            int num33 = num32 / 2;
                                            if (num32 - 2 * num33 == 0)
                                            {
                                                int i26 = (i24 + i25) / 2;
                                                xWin1 = Convert.ToInt32(x[i26]);
                                                yWin1 = Convert.ToInt32(y[i26]);
                                                WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                ++kItem;
                                                numSign[kItem] = i2;
                                                numItem[kItem] = num8;
                                                xItem[kItem] = xCur;
                                                yItem[kItem] = yCur;
                                                double x5 = x[i25] - x[i24];
                                                double num34 = Math.Atan2(y[i25] - y[i24], x5);
                                                if (num34 < 0.0)
                                                    num34 += 2.0 * num1;
                                                az[kItem] = num34;
                                            }
                                            i24 = i25 + num23;
                                        }
                                        else
                                            break;
                                    }
                                    while (i24 < ks && i25 < ks);
                                }
                                if (iStyle == 5)
                                {
                                    int i27 = 0;
                                    num29 = 0;
                                    int num35;
                                    do
                                    {
                                        int i28 = i27 + num20;
                                        if (i28 <= ks)
                                        {
                                            int i29 = (i27 + i28) / 2;
                                            xWin1 = Convert.ToInt32(x[i29]);
                                            yWin1 = Convert.ToInt32(y[i29]);
                                            WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            ++kItem;
                                            numSign[kItem] = i2;
                                            numItem[kItem] = num8;
                                            xItem[kItem] = xCur;
                                            yItem[kItem] = yCur;
                                            double x6 = x[i28] - x[i27];
                                            double num36 = Math.Atan2(y[i28] - y[i27], x6);
                                            if (num36 < 0.0)
                                                num36 += 2.0 * num1;
                                            az[kItem] = num36;
                                            int num37 = i28 + num23;
                                            if (num37 < ks)
                                            {
                                                num35 = num37 + num26;
                                                if (num35 <= ks)
                                                    i27 = num35 + num23;
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                        else
                                            break;
                                    }
                                    while (i27 < ks && num35 < ks);
                                }
                                if (iStyle == 6)
                                {
                                    int i30 = 0;
                                    num29 = 0;
                                    int i31;
                                    do
                                    {
                                        i31 = i30 + num20;
                                        if (i31 <= ks)
                                        {
                                            int i32 = (i30 + i31) / 2;
                                            xWin1 = Convert.ToInt32(x[i32]);
                                            yWin1 = Convert.ToInt32(y[i32]);
                                            WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                            ++kItem;
                                            numSign[kItem] = i2;
                                            numItem[kItem] = num8;
                                            xItem[kItem] = xCur;
                                            yItem[kItem] = yCur;
                                            double x7 = x[i31] - x[i30];
                                            double num38 = Math.Atan2(y[i31] - y[i30], x7);
                                            if (num38 < 0.0)
                                                num38 += 2.0 * num1;
                                            az[kItem] = num38;
                                            int num39 = i31 + num23 + num26;
                                            if (num39 < ks)
                                                i30 = num39 + num23;
                                            else
                                                break;
                                        }
                                        else
                                            break;
                                    }
                                    while (i30 < ks && i31 < ks);
                                }
                            }
                        }
                        else
                        {
                            double num40 = 1.0 * (double)iLine;
                            double num41 = 1.0 * (double)iBlank;
                            double num42 = 1.0 * (double)iDop;
                            double num43;
                            double num44 = num43 = 0.0;
                            for (int i33 = 1; i33 <= ks; ++i33)
                            {
                                double x8 = x[i33] - x[i33 - 1];
                                double y1 = y[i33] - y[i33 - 1];
                                double num45 = Math.Sqrt(x8 * x8 + y1 * y1);
                                double num46 = Math.Atan2(y1, x8);
                                if (num46 < 0.0)
                                    num46 += 2.0 * num1;
                                if (num6 > 0)
                                {
                                    if (num45 > num3)
                                    {
                                        xWin1 = Convert.ToInt32(0.5 * (x[i33 - 1] + x[i33]));
                                        yWin1 = Convert.ToInt32(0.5 * (y[i33 - 1] + y[i33]));
                                        WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                        ++kItem;
                                        numSign[kItem] = i2;
                                        numItem[kItem] = num8;
                                        xItem[kItem] = xCur;
                                        yItem[kItem] = yCur;
                                        az[kItem] = num46;
                                    }
                                }
                                else
                                {
                                    if (iStyle == 1 || iStyle == 2 || iStyle == 7)
                                    {
                                        double num47 = x[i33 - 1];
                                        double num48 = y[i33 - 1];
                                        double num49 = 0.0;
                                        do
                                        {
                                            num49 += num40;
                                            if (num49 <= num45)
                                            {
                                                double num50 = num47 + num40 * Math.Cos(num46);
                                                double num51 = num48 + num40 * Math.Sin(num46);
                                                xWin1 = Convert.ToInt32(0.5 * (num47 + num50));
                                                yWin1 = Convert.ToInt32(0.5 * (num48 + num51));
                                                WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                ++kItem;
                                                numSign[kItem] = i2;
                                                numItem[kItem] = num8;
                                                xItem[kItem] = xCur;
                                                yItem[kItem] = yCur;
                                                az[kItem] = num46;
                                                num47 = num50;
                                                num48 = num51;
                                            }
                                            else
                                                break;
                                        }
                                        while (num49 < num45);
                                    }
                                    if (iStyle == 3)
                                    {
                                        double num52 = x[i33 - 1];
                                        double num53 = y[i33 - 1];
                                        double num54 = 0.0;
                                        do
                                        {
                                            double num55 = num54 + num40;
                                            if (num55 <= num45)
                                            {
                                                double num56 = num52 + num40 * Math.Cos(num46);
                                                double num57 = num53 + num40 * Math.Sin(num46);
                                                xWin1 = Convert.ToInt32(0.5 * (num52 + num56));
                                                yWin1 = Convert.ToInt32(0.5 * (num53 + num57));
                                                WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                ++kItem;
                                                numSign[kItem] = i2;
                                                numItem[kItem] = num8;
                                                xItem[kItem] = xCur;
                                                yItem[kItem] = yCur;
                                                az[kItem] = num46;
                                                num54 = num55 + num41;
                                                if (num54 < num45)
                                                {
                                                    num52 = num56 + num41 * Math.Cos(num46);
                                                    num53 = num57 + num41 * Math.Sin(num46);
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                        while (num54 < num45);
                                    }
                                    if (iStyle == 4)
                                    {
                                        double num58 = x[i33 - 1];
                                        double num59 = y[i33 - 1];
                                        double num60 = 0.0;
                                        int num61 = 0;
                                        do
                                        {
                                            double num62 = num60 + num40;
                                            if (num62 <= num45)
                                            {
                                                double num63 = num58 + num40 * Math.Cos(num46);
                                                double num64 = num59 + num40 * Math.Sin(num46);
                                                ++num61;
                                                int num65 = num61 / 2;
                                                if (num61 - 2 * num65 == 0)
                                                {
                                                    xWin1 = Convert.ToInt32(0.5 * (num58 + num63));
                                                    yWin1 = Convert.ToInt32(0.5 * (num59 + num64));
                                                    WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                    ++kItem;
                                                    numSign[kItem] = i2;
                                                    numItem[kItem] = num8;
                                                    xItem[kItem] = xCur;
                                                    yItem[kItem] = yCur;
                                                    az[kItem] = num46;
                                                }
                                                num60 = num62 + num41;
                                                if (num60 < num45)
                                                {
                                                    num58 = num63 + num41 * Math.Cos(num46);
                                                    num59 = num64 + num41 * Math.Sin(num46);
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                        while (num60 < num45);
                                    }
                                    if (iStyle == 5)
                                    {
                                        double num66 = x[i33 - 1];
                                        double num67 = y[i33 - 1];
                                        double num68 = 0.0;
                                        do
                                        {
                                            double num69 = num68 + num40;
                                            if (num69 <= num45)
                                            {
                                                double num70 = num66 + num40 * Math.Cos(num46);
                                                double num71 = num67 + num40 * Math.Sin(num46);
                                                xWin1 = Convert.ToInt32(0.5 * (num66 + num70));
                                                yWin1 = Convert.ToInt32(0.5 * (num67 + num71));
                                                WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                ++kItem;
                                                numSign[kItem] = i2;
                                                numItem[kItem] = num8;
                                                xItem[kItem] = xCur;
                                                yItem[kItem] = yCur;
                                                az[kItem] = num46;
                                                double num72 = num69 + num41;
                                                if (num72 < num45)
                                                {
                                                    double num73 = num70 + num41 * Math.Cos(num46);
                                                    double num74 = num71 + num41 * Math.Sin(num46);
                                                    double num75 = num72 + num42;
                                                    if (num75 < num45)
                                                    {
                                                        double num76 = num73 + num42 * Math.Cos(num46);
                                                        double num77 = num74 + num42 * Math.Sin(num46);
                                                        num68 = num75 + num41;
                                                        if (num68 < num45)
                                                        {
                                                            num66 = num76 + num41 * Math.Cos(num46);
                                                            num67 = num77 + num41 * Math.Sin(num46);
                                                        }
                                                        else
                                                            break;
                                                    }
                                                    else
                                                        break;
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                        while (num68 < num45);
                                    }
                                    if (iStyle == 6)
                                    {
                                        double num78 = x[i33 - 1];
                                        double num79 = y[i33 - 1];
                                        double num80 = 0.0;
                                        do
                                        {
                                            double num81 = num80 + num40;
                                            if (num81 <= num45)
                                            {
                                                double num82 = num78 + num40 * Math.Cos(num46);
                                                double num83 = num79 + num40 * Math.Sin(num46);
                                                xWin1 = Convert.ToInt32(0.5 * (num78 + num82));
                                                yWin1 = Convert.ToInt32(0.5 * (num79 + num83));
                                                WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                                ++kItem;
                                                numSign[kItem] = i2;
                                                numItem[kItem] = num8;
                                                xItem[kItem] = xCur;
                                                yItem[kItem] = yCur;
                                                az[kItem] = num46;
                                                double num84 = num81 + num41;
                                                if (num84 < num45)
                                                {
                                                    double num85 = num82 + num41 * Math.Cos(num46);
                                                    double num86 = num83 + num41 * Math.Sin(num46);
                                                    double num87 = num85;
                                                    double num88 = num86;
                                                    num80 = num84 + num41;
                                                    if (num80 < num45)
                                                    {
                                                        num78 = num87 + num41 * Math.Cos(num46);
                                                        num79 = num88 + num41 * Math.Sin(num46);
                                                    }
                                                    else
                                                        break;
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                        while (num80 < num45);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void Print_SignDraw(
          PrintPageEventArgs e,
          int ixh,
          int iyh,
          int kPixel,
          int[] ixSqu,
          int[] iySqu,
          int[] nColor,
          SolidBrush[] brColor,
          int iPrintCol)
        {
            Graphics graphics = e.Graphics;
            int num1;
            int num2 = num1 = 0;
            if (kPixel == 0)
                return;
            for (int i = 1; i <= kPixel; ++i)
            {
                if (ixSqu[i] > num2)
                    num2 = ixSqu[i];
                if (iySqu[i] > num1)
                    num1 = iySqu[i];
            }
            graphics.FillRectangle((Brush)new SolidBrush(Color.White), ixh - 1, iyh - 1, num2 + 1, num1 + 1);
            if (iPrintCol > 0)
            {
                for (int i1 = 1; i1 <= kPixel; ++i1)
                {
                    int x = ixh + ixSqu[i1];
                    int y = iyh + iySqu[i1];
                    int i2 = nColor[i1];
                    if (i2 > 15)
                        i2 = 1;
                    SolidBrush solidBrush = brColor[i2];
                    graphics.FillRectangle((Brush)solidBrush, x, y, 1, 1);
                }
            }
            if (iPrintCol != 0)
                return;
            for (int i = 1; i <= kPixel; ++i)
            {
                int x = ixh + ixSqu[i];
                int y = iyh + iySqu[i];
                if (nColor[i] > 15)
                    ;
                SolidBrush solidBrush = new SolidBrush(Color.Black);
                graphics.FillRectangle((Brush)solidBrush, x, y, 1, 1);
            }
        }

        public static void Print_Vertical(
          PrintPageEventArgs e,
          string tText,
          int ix,
          int iy,
          int hText,
          SolidBrush dBrush)
        {
            Graphics graphics = e.Graphics;
            Font font = new Font("Жирный", (float)hText);
            graphics.DrawString(tText, font, (Brush)dBrush, (float)ix, (float)iy, new StringFormat()
            {
                FormatFlags = StringFormatFlags.DirectionVertical
            });
            font.Dispose();
        }

        public static void AreaConvert(double aMetre, int iParam, out double aConv)
        {
            aConv = 0.0;
            double num1 = 10000.0;
            double num2 = 4046.85642;
            double num3 = 1000.0;
            if (iParam == 1)
                aConv = aMetre;
            if (iParam == 2)
                aConv = aMetre / num1;
            if (iParam == 3)
                aConv = aMetre / num2;
            if (iParam != 4)
                return;
            aConv = aMetre / num3;
        }

        public static void Precision_Set(int iPrecision, double ar, out string sTmp, out double sar)
        {
            sTmp = "";
            sar = 0.0;
            if (iPrecision == 1)
                sTmp = string.Format("{0:F1}", (object)ar);
            if (iPrecision == 2)
                sTmp = string.Format("{0:F2}", (object)ar);
            if (iPrecision == 3)
                sTmp = string.Format("{0:F3}", (object)ar);
            if (iPrecision == 4)
                sTmp = string.Format("{0:F4}", (object)ar);
            if (iPrecision == 5)
                sTmp = string.Format("{0:F5}", (object)ar);
            sar = Convert.ToDouble(sTmp);
        }

        public static void OrderPnt(int k, ref double[] x, ref double[] y, ref double[] r)
        {
            int num1;
            int num2 = num1 = 0;
            double num3;
            double num4 = num3 = 0.0;
            for (int i1 = 0; i1 < k; ++i1)
            {
                for (int i2 = i1 + 1; i2 <= k; ++i2)
                {
                    if (r[i1] > r[i2])
                    {
                        double num5 = r[i1];
                        double num6 = x[i1];
                        double num7 = y[i1];
                        r[i1] = r[i2];
                        x[i1] = x[i2];
                        y[i1] = y[i2];
                        r[i2] = num5;
                        x[i2] = num6;
                        y[i2] = num7;
                    }
                }
            }
        }

        public static void ClipLine(
          int kp,
          double[] xp,
          double[] yp,
          int k,
          double[] x,
          double[] y,
          double rad,
          double xrd,
          double yrd,
          out int kl,
          int[] k1,
          int[] k2,
          double[] xl,
          double[] yl,
          int[] ind,
          double[] xr,
          double[] yr)
        {
            double[] x1 = new double[200];
            double[] y1 = new double[200];
            double[] r = new double[200];
            double ym;
            double xm = ym = 0.0;
            kl = -1;
            int i1 = -1;
            int kArray1 = 999999;
            doubleArray(x, ref kArray1);
            doubleArray(y, ref kArray1);
            doubleArray(xl, ref kArray1);
            doubleArray(yl, ref kArray1);
            doubleArray(xr, ref kArray1);
            doubleArray(yr, ref kArray1);
            intArray(ind, ref kArray1);
            int num1 = kArray1 - 2;
            if (k > num1)
            {
                int num2 = (int)MessageBox.Show("Индекс массива ClipLine");
                kl = -1;
            }
            else
            {
                int kArray2 = 999999;
                intArray(k1, ref kArray2);
                intArray(k2, ref kArray2);
                int num3 = kArray2 - 2;
                int num4 = -1;
                int i2 = -1;
                if (rad > 0.0)
                {
                    for (int i3 = 0; i3 <= k; ++i3)
                    {
                        int num5 = in_out(kp, ref xp, ref yp, x[i3], y[i3]);
                        if (num5 == 0)
                        {
                            if (num4 > 0)
                            {
                                int num6 = num4 + 1;
                                ++i1;
                                xl[i1] = x[i3];
                                yl[i1] = y[i3];
                                ++i2;
                                if (i2 > num3)
                                {
                                    int num7 = (int)MessageBox.Show("Индекс массива ClipLine");
                                    kl = -1;
                                    return;
                                }
                                if (i2 == 0)
                                {
                                    k1[i2] = 0;
                                    k2[i2] = num6;
                                }
                                if (i2 > 0)
                                {
                                    k1[i2] = k2[i2 - 1] + 1;
                                    k2[i2] = k1[i2] + num6;
                                }
                            }
                            num4 = -1;
                        }
                        if (num5 > 0)
                        {
                            if (num4 < 0 && i3 > 0)
                            {
                                ++num4;
                                ++i1;
                                xl[i1] = x[i3 - 1];
                                yl[i1] = y[i3 - 1];
                            }
                            ++num4;
                            ++i1;
                            xl[i1] = x[i3];
                            yl[i1] = y[i3];
                        }
                    }
                    if (num4 > 0)
                    {
                        ++i2;
                        if (i2 > num3)
                        {
                            int num8 = (int)MessageBox.Show("Индекс массива ClipLine");
                            kl = -1;
                            return;
                        }
                        if (i2 == 0)
                        {
                            k1[i2] = 0;
                            k2[i2] = num4;
                        }
                        if (i2 > 0)
                        {
                            k1[i2] = k2[i2 - 1] + 1;
                            k2[i2] = k1[i2] + num4;
                        }
                    }
                    kl = i2;
                }
                else
                {
                    int i4 = -1;
                    for (int i5 = 1; i5 <= k; ++i5)
                    {
                        double x1_1 = x[i5 - 1];
                        double y1_1 = y[i5 - 1];
                        double x2 = x[i5];
                        double y2 = y[i5];
                        for (int i6 = 1; i6 <= kp; ++i6)
                        {
                            double x3 = xp[i6 - 1];
                            double y3 = yp[i6 - 1];
                            double x4 = xp[i6];
                            double y4 = yp[i6];
                            int ip = 1;
                            TwoLine(x1_1, y1_1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip);
                            if (xm != 0.0 && ym != 0.0)
                            {
                                ++i4;
                                ind[i4] = i5;
                                xr[i4] = xm;
                                yr[i4] = ym;
                            }
                        }
                    }
                    if (i4 < 0)
                    {
                        int num9 = 0;
                        int num10 = 0;
                        for (int i7 = 0; i7 <= k; ++i7)
                        {
                            int num11 = in_out(kp, ref xp, ref yp, x[i7], y[i7]);
                            if (num11 == 0)
                                ++num9;
                            if (num11 > 0)
                                ++num10;
                        }
                        if (num9 > 0 && num10 == 0)
                            return;
                        if (num9 == 0 && num10 > 0)
                        {
                            kl = 0;
                            k1[0] = 0;
                            k2[0] = k;
                            for (int i8 = 0; i8 <= k; ++i8)
                            {
                                xl[i8] = x[i8];
                                yl[i8] = y[i8];
                            }
                            return;
                        }
                    }
                    int num12 = -1;
                    int i9 = -1;
                    for (int i10 = 1; i10 <= k; ++i10)
                    {
                        double xt1 = x[i10 - 1];
                        double yt1 = y[i10 - 1];
                        double xt2 = x[i10];
                        double yt2 = y[i10];
                        int k3 = -1;
                        for (int i11 = 0; i11 <= i4; ++i11)
                        {
                            if (ind[i11] == i10)
                            {
                                ++k3;
                                x1[k3] = xr[i11];
                                y1[k3] = yr[i11];
                                double num13 = xr[i11] - xt1;
                                double num14 = yr[i11] - yt1;
                                r[k3] = Math.Sqrt(num13 * num13 + num14 * num14);
                            }
                        }
                        if (k3 > 0)
                            OrderPnt(k3, ref x1, ref y1, ref r);
                        int num15 = in_out(kp, ref xp, ref yp, xt1, yt1);
                        int num16 = in_out(kp, ref xp, ref yp, xt2, yt2);
                        if (num15 > 0 && num16 > 0)
                        {
                            if (k3 <= 0)
                            {
                                int num17 = num12 + 1;
                                int i12 = i1 + 1;
                                xl[i12] = xt1;
                                yl[i12] = yt1;
                                int num18 = num17 + 1;
                                i1 = i12 + 1;
                                xl[i1] = xt2;
                                yl[i1] = yt2;
                                ++i9;
                                if (i9 > num3)
                                {
                                    int num19 = (int)MessageBox.Show("Индекс массива ClipLine");
                                    kl = -1;
                                    return;
                                }
                                if (i9 == 0)
                                {
                                    k1[i9] = 0;
                                    k2[i9] = num18;
                                }
                                if (i9 > 0)
                                {
                                    k1[i9] = k2[i9 - 1] + 1;
                                    k2[i9] = k1[i9] + num18;
                                }
                                num12 = -1;
                            }
                            if (k3 > 0)
                            {
                                for (int i13 = 0; i13 <= k3; ++i13)
                                {
                                    if (i13 == 0)
                                    {
                                        xm = 0.5 * (xt1 + x1[i13]);
                                        ym = 0.5 * (yt1 + y1[i13]);
                                    }
                                    if (i13 > 0 && i13 < k3)
                                    {
                                        xm = 0.5 * (x1[i13 - 1] + x1[i13]);
                                        ym = 0.5 * (y1[i13 - 1] + y1[i13]);
                                    }
                                    if (i13 == k3)
                                    {
                                        xm = 0.5 * (x1[i13] + xt2);
                                        ym = 0.5 * (y1[i13] + yt2);
                                    }
                                    int num20 = in_out(kp, ref xp, ref yp, xm, ym);
                                    if (num20 > 0)
                                    {
                                        if (i13 == 0)
                                        {
                                            int num21 = num12 + 1;
                                            int i14 = i1 + 1;
                                            xl[i14] = xt1;
                                            yl[i14] = yt1;
                                            num12 = num21 + 1;
                                            i1 = i14 + 1;
                                            xl[i1] = x1[i13];
                                            yl[i1] = y1[i13];
                                        }
                                        if (i13 > 0 && i13 < k3)
                                        {
                                            int num22 = num12 + 1;
                                            int i15 = i1 + 1;
                                            xl[i15] = x1[i13 - 1];
                                            yl[i15] = y1[i13 - 1];
                                            num12 = num22 + 1;
                                            i1 = i15 + 1;
                                            xl[i1] = x1[i13];
                                            yl[i1] = y1[i13];
                                        }
                                        if (i13 == k3)
                                        {
                                            int num23 = num12 + 1;
                                            int i16 = i1 + 1;
                                            xl[i16] = x1[i13];
                                            yl[i16] = y1[i13];
                                            num12 = num23 + 1;
                                            i1 = i16 + 1;
                                            xl[i1] = xt2;
                                            yl[i1] = yt2;
                                        }
                                    }
                                    if (num20 == 0)
                                    {
                                        if (num12 > 0)
                                        {
                                            ++i9;
                                            if (i9 > num3)
                                            {
                                                int num24 = (int)MessageBox.Show("Индекс массива ClipLine");
                                                kl = -1;
                                                return;
                                            }
                                            if (i9 == 0)
                                            {
                                                k1[i9] = 0;
                                                k2[i9] = num12;
                                            }
                                            if (i9 > 0)
                                            {
                                                k1[i9] = k2[i9 - 1] + 1;
                                                k2[i9] = k1[i9] + num12;
                                            }
                                        }
                                        num12 = -1;
                                    }
                                }
                            }
                        }
                        if (num15 > 0 && num16 == 0)
                        {
                            if (k3 < 0)
                            {
                                num12 = -1;
                                continue;
                            }
                            if (k3 == 0)
                            {
                                xm = 0.5 * (xt1 + x1[0]);
                                ym = 0.5 * (yt1 + y1[0]);
                                if (in_out(kp, ref xp, ref yp, xm, ym) > 0)
                                {
                                    int num25 = num12 + 1;
                                    int i17 = i1 + 1;
                                    xl[i17] = xt1;
                                    yl[i17] = yt1;
                                    int num26 = num25 + 1;
                                    i1 = i17 + 1;
                                    xl[i1] = x1[0];
                                    yl[i1] = y1[0];
                                    ++i9;
                                    if (i9 > num3)
                                    {
                                        int num27 = (int)MessageBox.Show("Индекс массива ClipLine");
                                        kl = -1;
                                        return;
                                    }
                                    if (i9 == 0)
                                    {
                                        k1[i9] = 0;
                                        k2[i9] = num26;
                                    }
                                    if (i9 > 0)
                                    {
                                        k1[i9] = k2[i9 - 1] + 1;
                                        k2[i9] = k1[i9] + num26;
                                    }
                                    num12 = -1;
                                }
                            }
                            if (k3 > 0)
                            {
                                for (int i18 = 0; i18 <= k3; ++i18)
                                {
                                    if (i18 == 0)
                                    {
                                        xm = 0.5 * (xt1 + x1[i18]);
                                        ym = 0.5 * (yt1 + y1[i18]);
                                    }
                                    if (i18 > 0 && i18 <= k3)
                                    {
                                        xm = 0.5 * (x1[i18 - 1] + x1[i18]);
                                        ym = 0.5 * (y1[i18 - 1] + y1[i18]);
                                    }
                                    if (in_out(kp, ref xp, ref yp, xm, ym) > 0)
                                    {
                                        if (i18 == 0)
                                        {
                                            int num28 = num12 + 1;
                                            int i19 = i1 + 1;
                                            xl[i19] = xt1;
                                            yl[i19] = yt1;
                                            int num29 = num28 + 1;
                                            i1 = i19 + 1;
                                            xl[i1] = x1[i18];
                                            yl[i1] = y1[i18];
                                            ++i9;
                                            if (i9 == 0)
                                            {
                                                k1[i9] = 0;
                                                k2[i9] = num29;
                                            }
                                            if (i9 > 0)
                                            {
                                                k1[i9] = k2[i9 - 1] + 1;
                                                k2[i9] = k1[i9] + num29;
                                            }
                                            num12 = -1;
                                        }
                                        if (i18 > 0 && i18 <= k3)
                                        {
                                            int num30 = num12 + 1;
                                            int i20 = i1 + 1;
                                            xl[i20] = x1[i18 - 1];
                                            yl[i20] = y1[i18 - 1];
                                            int num31 = num30 + 1;
                                            i1 = i20 + 1;
                                            xl[i1] = x1[i18];
                                            yl[i1] = y1[i18];
                                            ++i9;
                                            if (i9 > num3)
                                            {
                                                int num32 = (int)MessageBox.Show("Индекс массива ClipLine");
                                                kl = -1;
                                                return;
                                            }
                                            if (i9 == 0)
                                            {
                                                k1[i9] = 0;
                                                k2[i9] = num31;
                                            }
                                            if (i9 > 0)
                                            {
                                                k1[i9] = k2[i9 - 1] + 1;
                                                k2[i9] = k1[i9] + num31;
                                            }
                                            num12 = -1;
                                        }
                                    }
                                }
                            }
                        }
                        if (num15 == 0 && num16 > 0)
                        {
                            if (k3 < 0)
                            {
                                num12 = -1;
                                continue;
                            }
                            if (k3 == 0)
                            {
                                xm = 0.5 * (x1[0] + xt2);
                                ym = 0.5 * (y1[0] + yt2);
                                if (in_out(kp, ref xp, ref yp, xm, ym) != 0)
                                {
                                    int num33 = num12 + 1;
                                    int i21 = i1 + 1;
                                    xl[i21] = x1[0];
                                    yl[i21] = y1[0];
                                    int num34 = num33 + 1;
                                    i1 = i21 + 1;
                                    xl[i1] = xt2;
                                    yl[i1] = yt2;
                                    ++i9;
                                    if (i9 > num3)
                                    {
                                        int num35 = (int)MessageBox.Show("Индекс массива ClipLine");
                                        kl = -1;
                                        return;
                                    }
                                    if (i9 == 0)
                                    {
                                        k1[i9] = 0;
                                        k2[i9] = num34;
                                    }
                                    if (i9 > 0)
                                    {
                                        k1[i9] = k2[i9 - 1] + 1;
                                        k2[i9] = k1[i9] + num34;
                                    }
                                    num12 = -1;
                                }
                                else
                                    continue;
                            }
                            if (k3 > 0)
                            {
                                for (int i22 = 1; i22 <= k3; ++i22)
                                {
                                    if (i22 > 0 && i22 < k3)
                                    {
                                        xm = 0.5 * (x1[i22 - 1] + x1[i22]);
                                        ym = 0.5 * (y1[i22 - 1] + y1[i22]);
                                    }
                                    if (i22 == k3)
                                    {
                                        xm = 0.5 * (x1[i22] + xt2);
                                        ym = 0.5 * (y1[i22] + yt2);
                                    }
                                    if (in_out(kp, ref xp, ref yp, xm, ym) > 0)
                                    {
                                        if (i22 > 0 && i22 < k3)
                                        {
                                            int num36 = num12 + 1;
                                            int i23 = i1 + 1;
                                            xl[i23] = x1[i22 - 1];
                                            yl[i23] = y1[i22 - 1];
                                            int num37 = num36 + 1;
                                            i1 = i23 + 1;
                                            xl[i1] = x1[i22];
                                            yl[i1] = y1[i22];
                                            ++i9;
                                            if (i9 > num3)
                                            {
                                                int num38 = (int)MessageBox.Show("Индекс массива ClipLine");
                                                kl = -1;
                                                return;
                                            }
                                            if (i9 == 0)
                                            {
                                                k1[i9] = 0;
                                                k2[i9] = num37;
                                            }
                                            if (i9 > 0)
                                            {
                                                k1[i9] = k2[i9 - 1] + 1;
                                                k2[i9] = k1[i9] + num37;
                                            }
                                            num12 = -1;
                                        }
                                        if (i22 == k3)
                                        {
                                            int num39 = num12 + 1;
                                            int i24 = i1 + 1;
                                            xl[i24] = x1[i22];
                                            yl[i24] = y1[i22];
                                            int num40 = num39 + 1;
                                            i1 = i24 + 1;
                                            xl[i1] = xt2;
                                            yl[i1] = yt2;
                                            ++i9;
                                            if (i9 > num3)
                                            {
                                                int num41 = (int)MessageBox.Show("Индекс массива ClipLine");
                                                kl = -1;
                                                return;
                                            }
                                            if (i9 == 0)
                                            {
                                                k1[i9] = 0;
                                                k2[i9] = num40;
                                            }
                                            if (i9 > 0)
                                            {
                                                k1[i9] = k2[i9 - 1] + 1;
                                                k2[i9] = k1[i9] + num40;
                                            }
                                            num12 = -1;
                                        }
                                    }
                                }
                            }
                        }
                        if (num15 == 0 && num16 == 0 && k3 > 0 && k3 > 0)
                        {
                            for (int i25 = 1; i25 <= k3; ++i25)
                            {
                                xm = 0.5 * (x1[i25 - 1] + x1[i25]);
                                ym = 0.5 * (y1[i25 - 1] + y1[i25]);
                                if (in_out(kp, ref xp, ref yp, xm, ym) > 0)
                                {
                                    int num42 = num12 + 1;
                                    int i26 = i1 + 1;
                                    xl[i26] = x1[i25 - 1];
                                    yl[i26] = y1[i25 - 1];
                                    int num43 = num42 + 1;
                                    i1 = i26 + 1;
                                    xl[i1] = x1[i25];
                                    yl[i1] = y1[i25];
                                    ++i9;
                                    if (i9 > num3)
                                    {
                                        int num44 = (int)MessageBox.Show("Индекс массива ClipLine");
                                        kl = -1;
                                        return;
                                    }
                                    if (i9 == 0)
                                    {
                                        k1[i9] = 0;
                                        k2[i9] = num43;
                                    }
                                    if (i9 > 0)
                                    {
                                        k1[i9] = k2[i9 - 1] + 1;
                                        k2[i9] = k1[i9] + num43;
                                    }
                                    num12 = -1;
                                }
                            }
                        }
                    }
                    if (num12 > 0)
                    {
                        ++i9;
                        if (i9 > num3)
                        {
                            int num45 = (int)MessageBox.Show("Индекс массива ClipLine");
                            kl = -1;
                            return;
                        }
                        if (i9 == 0)
                        {
                            k1[i9] = 0;
                            k2[i9] = num12;
                        }
                        if (i9 > 0)
                        {
                            k1[i9] = k2[i9 - 1] + 1;
                            k2[i9] = k1[i9] + num12;
                        }
                    }
                    kl = i9;
                }
            }
        }

        public static void ContTextPrevPrint(
          PrintPageEventArgs e,
          string tText,
          int x,
          int y,
          int hText,
          int angle,
          SolidBrush iColor,
          int iParam,
          int iFont)
        {
            double num1 = 3.1415926;
            Graphics graphics = e.Graphics;
            graphics.TextRenderingHint = TextRenderingHint.AntiAliasGridFit;
            Font font1 = new Font("Verdana", (float)hText, FontStyle.Bold);
            Font font2 = new Font("Arial", (float)hText, FontStyle.Regular);
            Point point = new Point(x, y);
            double num2 = (double)angle * num1 / 180.0;
            int x1 = x - Convert.ToInt32(0.5 * (double)tText.Length * (double)hText * Math.Cos(num2));
            int y1 = y - Convert.ToInt32(0.5 * (double)tText.Length * (double)hText * Math.Sin(num2));
            int x2 = x + Convert.ToInt32(0.5 * (double)tText.Length * (double)hText * Math.Cos(num2));
            int y2 = y + Convert.ToInt32(0.5 * (double)tText.Length * (double)hText * Math.Sin(num2));
            Point pt1 = new Point(x1, y1);
            Point pt2 = new Point(x2, y2);
            graphics.DrawLine(new Pen(Brushes.White)
            {
                Width = (float)(hText / 2)
            }, pt1, pt2);
            graphics.TranslateTransform((float)point.X, (float)point.Y);
            graphics.RotateTransform((float)angle);
            if (iParam < 2)
            {
                StringFormat format = new StringFormat(StringFormatFlags.NoClip);
                if (iParam == 0)
                    format.Alignment = StringAlignment.Near;
                if (iParam == 1)
                    format.Alignment = StringAlignment.Center;
                format.LineAlignment = StringAlignment.Center;
                if (iFont == 1)
                    graphics.DrawString(tText, font1, (Brush)iColor, 0.0f, 0.0f, format);
                if (iFont == 2)
                    graphics.DrawString(tText, font2, (Brush)iColor, 0.0f, 0.0f, format);
            }
            graphics.RotateTransform((float)-angle);
            graphics.TranslateTransform((float)-point.X, (float)-point.Y);
        }

        public static void LineInOut(
     int kBord,
     double[] xBord,
     double[] yBord,
     int k,
     double[] x,
     double[] y,
     out int kin,
     int[] ki,
     int[] kin1,
     int[] kin2,
     double[] xin,
     double[] yin,
     out int kout,
     int[] ko,
     int[] kout1,
     int[] kout2,
     double[] xout,
     double[] yout,
     int[] nd,
     double[] xd,
     double[] yd,
     double[] xr,
     double[] yr)
        {
            double[] numArray1 = new double[10];
            double[] numArray2 = new double[10];
            double[] numArray3 = new double[10];
            kin = 0;
            kout = 0;
            int i1 = 0;
            double ym;
            for (int i2 = 2; i2 <= k; ++i2)
            {
                double x1 = x[i2 - 1];
                double y1 = y[i2 - 1];
                double x2 = x[i2];
                double y2 = y[i2];
                for (int i3 = 1; i3 <= kBord; ++i3)
                {
                    double x3 = xBord[i3 - 1];
                    double y3 = yBord[i3 - 1];
                    double x4 = xBord[i3];
                    double y4 = yBord[i3];
                    int ip = 1;
                    double xm;
                    DllClass1.TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip);
                    if (xm != 0.0 || ym != 0.0)
                    {
                        ++i1;
                        nd[i1] = i2;
                        xd[i1] = xm;
                        yd[i1] = ym;
                    }
                }
            }
            int i4;
            int i5 = i4 = 0;
            if (i1 == 0)
            {
                double xt = 0.5 * (x[1] + x[2]);
                ym = 0.5 * (y[1] + y[2]);
                int num = DllClass1.in_out(kBord, ref xBord, ref yBord, xt, ym);
                if (num > 0)
                {
                    ++kin;
                    for (int i6 = 1; i6 <= k; ++i6)
                    {
                        ++i5;
                        xin[i5] = x[i6];
                        yin[i5] = y[i6];
                    }
                    ki[kin] = k;
                }
                if (num == 0)
                {
                    ++kout;
                    for (int i7 = 1; i7 <= k; ++i7)
                    {
                        ++i4;
                        xout[i4] = x[i7];
                        yout[i4] = y[i7];
                    }
                    ko[kout] = k;
                }
            }
            if (i1 > 0)
            {
                if (i1 > 1)
                {
                    for (int i8 = 1; i8 < i1; ++i8)
                    {
                        for (int i9 = i8 + 1; i9 <= i1; ++i9)
                        {
                            if (nd[i8] > nd[i9])
                            {
                                int num1 = nd[i8];
                                double num2 = xd[i8];
                                ym = yd[i8];
                                nd[i8] = nd[i9];
                                xd[i8] = xd[i9];
                                yd[i8] = yd[i9];
                                nd[i9] = num1;
                                xd[i9] = num2;
                                yd[i9] = ym;
                            }
                        }
                    }
                }
                int i10 = 1;
                xr[i10] = x[1];
                yr[i10] = y[1];
                for (int i11 = 2; i11 <= k; ++i11)
                {
                    int i12 = 0;
                    for (int i13 = 1; i13 <= i1; ++i13)
                    {
                        if (nd[i13] == i11)
                        {
                            ++i12;
                            numArray1[i12] = xd[i13];
                            numArray2[i12] = yd[i13];
                            double num3 = xd[i13] - x[i11 - 1];
                            double num4 = yd[i13] - y[i11 - 1];
                            numArray3[i12] = Math.Sqrt(num3 * num3 + num4 * num4);
                        }
                    }
                    if (i12 == 0)
                    {
                        ++i10;
                        xr[i10] = x[i11];
                        yr[i10] = y[i11];
                    }
                    else
                    {
                        if (i12 > 1)
                        {
                            for (int i14 = 1; i14 < i12; ++i14)
                            {
                                for (int i15 = i14 + 1; i15 <= i12; ++i15)
                                {
                                    if (numArray3[i14] > numArray3[i15])
                                    {
                                        double num5 = numArray1[i14];
                                        ym = numArray2[i14];
                                        double num6 = numArray3[i14];
                                        numArray1[i14] = numArray1[i15];
                                        numArray2[i14] = numArray2[i15];
                                        numArray3[i14] = numArray3[i15];
                                        numArray1[i15] = num5;
                                        numArray2[i15] = ym;
                                        numArray3[i15] = num6;
                                    }
                                }
                            }
                        }
                        for (int i16 = 1; i16 <= i12; ++i16)
                        {
                            double num7 = numArray1[i16] - xr[i10];
                            double num8 = numArray2[i16] - yr[i10];
                            if (Math.Sqrt(num7 * num7 + num8 * num8) >= 0.005)
                            {
                                double num9 = numArray1[i16] - x[i11];
                                double num10 = numArray2[i16] - y[i11];
                                if (Math.Sqrt(num9 * num9 + num10 * num10) >= 0.005)
                                {
                                    ++i10;
                                    xr[i10] = numArray1[i16];
                                    yr[i10] = numArray2[i16];
                                }
                            }
                        }
                        double num11 = x[i11] - xr[i10];
                        double num12 = y[i11] - yr[i10];
                        if (Math.Sqrt(num11 * num11 + num12 * num12) >= 0.005)
                        {
                            ++i10;
                            xr[i10] = x[i11];
                            yr[i10] = y[i11];
                        }
                    }
                }
                int num13 = 0;
                for (int i17 = 2; i17 <= i10; ++i17)
                {
                    double xt = 0.5 * (xr[i17 - 1] + xr[i17]);
                    ym = 0.5 * (yr[i17 - 1] + yr[i17]);
                    int num14 = DllClass1.in_out(kBord, ref xBord, ref yBord, xt, ym);
                    if (num14 == 0 && num13 > 1)
                    {
                        ++kin;
                        ki[kin] = num13;
                        num13 = 0;
                    }
                    if (num14 > 0)
                    {
                        if (num13 == 0)
                        {
                            int i18 = i5 + 1;
                            int num15 = num13 + 1;
                            xin[i18] = xr[i17 - 1];
                            yin[i18] = yr[i17 - 1];
                            i5 = i18 + 1;
                            num13 = num15 + 1;
                            xin[i5] = xr[i17];
                            yin[i5] = yr[i17];
                        }
                        else if (num13 > 0)
                        {
                            double num16 = xin[i5] - xr[i17 - 1];
                            double num17 = yin[i5] - yr[i17 - 1];
                            if (Math.Sqrt(num16 * num16 + num17 * num17) < 0.003)
                            {
                                ++i5;
                                ++num13;
                                xin[i5] = xr[i17];
                                yin[i5] = yr[i17];
                            }
                        }
                    }
                }
                if (num13 > 1)
                {
                    ++kin;
                    ki[kin] = num13;
                }
                int num18 = 0;
                for (int i19 = 2; i19 <= i10; ++i19)
                {
                    double xt = 0.5 * (xr[i19 - 1] + xr[i19]);
                    ym = 0.5 * (yr[i19 - 1] + yr[i19]);
                    int num19 = DllClass1.in_out(kBord, ref xBord, ref yBord, xt, ym);
                    if (num19 > 0 && num18 > 1)
                    {
                        ++kout;
                        ko[kout] = num18;
                        num18 = 0;
                    }
                    if (num19 == 0)
                    {
                        if (num18 == 0)
                        {
                            int i20 = i4 + 1;
                            int num20 = num18 + 1;
                            xout[i20] = xr[i19 - 1];
                            yout[i20] = yr[i19 - 1];
                            i4 = i20 + 1;
                            num18 = num20 + 1;
                            xout[i4] = xr[i19];
                            yout[i4] = yr[i19];
                        }
                        else if (num18 > 0)
                        {
                            double num21 = xout[i4] - xr[i19 - 1];
                            double num22 = yout[i4] - yr[i19 - 1];
                            if (Math.Sqrt(num21 * num21 + num22 * num22) < 0.003)
                            {
                                ++i4;
                                ++num18;
                                xout[i4] = xr[i19];
                                yout[i4] = yr[i19];
                            }
                        }
                    }
                }
                if (num18 > 1)
                {
                    ++kout;
                    ko[kout] = num18;
                }
            }
            if (kin > 0)
            {
                kin1[1] = 1;
                kin2[1] = ki[1];
                if (kin > 1)
                {
                    for (int i21 = 2; i21 <= kin; ++i21)
                    {
                        kin1[i21] = kin2[i21 - 1] + 1;
                        kin2[i21] = kin2[i21 - 1] + ki[i21];
                    }
                }
            }
            if (kout <= 0)
                return;
            kout1[1] = 1;
            kout2[1] = ko[1];
            if (kout <= 1)
                return;
            for (int i22 = 2; i22 <= kout; ++i22)
            {
                kout1[i22] = kout2[i22 - 1] + 1;
                kout2[i22] = kout2[i22 - 1] + ko[i22];
            }
        }

        public static void RotTextPrevPrint(
          PrintPageEventArgs e,
          string tText,
          int x,
          int y,
          int hText,
          int angle,
          SolidBrush iColor,
          int iParam)
        {
            Graphics graphics = e.Graphics;
            graphics.TextRenderingHint = TextRenderingHint.AntiAliasGridFit;
            Font font = new Font("Verdana", (float)(hText - 1), FontStyle.Regular);
            Point point = new Point(x, y);
            if (angle > 90 && angle < 180)
                angle += 180;
            if (angle >= 180 && angle < 270)
                angle -= 180;
            graphics.TranslateTransform((float)point.X, (float)point.Y);
            graphics.RotateTransform((float)angle);
            if (iParam < 2)
            {
                StringFormat format = new StringFormat(StringFormatFlags.NoClip);
                if (iParam == 0)
                    format.Alignment = StringAlignment.Near;
                if (iParam == 1)
                    format.Alignment = StringAlignment.Center;
                format.LineAlignment = StringAlignment.Center;
                graphics.DrawString(tText, font, (Brush)iColor, 0.0f, 0.0f, format);
            }
            graphics.RotateTransform((float)-angle);
            graphics.TranslateTransform((float)-point.X, (float)-point.Y);
        }

        public static void FullPolySymb(
          int k,
          double[] x,
          double[] y,
          int nDensity,
          int iWid,
          int iHei,
          out int kCent,
          double[] xCent,
          double[] yCent)
        {
            double[] numArray1 = new double[50];
            double[] numArray2 = new double[50];
            kCent = 0;
            double num1 = 0.0;
            int kArray = 999999;
            doubleArray(xCent, ref kArray);
            doubleArray(yCent, ref kArray);
            int num2 = kArray - 2;
            if (nDensity == 0 || nDensity == 1)
                num1 = 2.0;
            if (nDensity == 2)
                num1 = 1.5;
            if (nDensity == 3)
                num1 = 1.0;
            if (nDensity == 4)
                num1 = 0.5;
            if (nDensity == 5)
                num1 = 0.0;
            double num3 = (double)iWid + num1 * (double)iWid;
            double num4 = (double)iHei + num1 * (double)iHei;
            double num5 = 9999999.9;
            double num6 = 9999999.9;
            double num7 = -9999999.9;
            double num8 = -9999999.9;
            for (int i = 0; i <= k; ++i)
            {
                if (x[i] < num5)
                    num5 = x[i];
                if (y[i] < num6)
                    num6 = y[i];
                if (x[i] > num7)
                    num7 = x[i];
                if (y[i] > num8)
                    num8 = y[i];
            }
            double num9 = num6 - num4;
            do
            {
                num9 += num4;
                double y1 = num9 - 0.5 * num4;
                double y2 = y1;
                double x1 = num5 - 0.1;
                double x2 = num7 + 0.1;
                int i1 = 0;
                int ip;
                double xm;
                double ym;
                for (int i2 = 1; i2 <= k; ++i2)
                {
                    double x3 = x[i2 - 1];
                    double y3 = y[i2 - 1];
                    double x4 = x[i2];
                    double y4 = y[i2];
                    ip = 1;
                    TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip);
                    if (xm != 0.0 || ym != 0.0)
                    {
                        ++i1;
                        numArray1[i1] = xm;
                        numArray2[i1] = ym;
                    }
                }
                if (i1 > 0 && num9 >= num8)
                {
                    ip = i1 / 2;
                    if (i1 - 2 * ip > 0)
                        y1 -= 5.0;
                }
                if (i1 == 0 && num9 >= num8)
                    y1 -= 5.0;
                if (i1 >= 1)
                {
                    if (i1 > 1)
                    {
                        for (int i3 = 1; i3 < i1; ++i3)
                        {
                            ip = i3 + 1;
                            for (int i4 = ip; i4 <= i1; ++i4)
                            {
                                if (numArray1[i3] > numArray1[i4])
                                {
                                    xm = numArray1[i3];
                                    ym = numArray2[i3];
                                    numArray1[i3] = numArray1[i4];
                                    numArray2[i3] = numArray2[i4];
                                    numArray1[i4] = xm;
                                    numArray2[i4] = ym;
                                }
                            }
                        }
                    }
                    for (int i5 = 2; i5 <= i1; ++i5)
                    {
                        double yt = y1;
                        double xt1 = 0.5 * (numArray1[i5 - 1] + numArray1[i5]);
                        ip = in_out(k, ref x, ref y, xt1, yt);
                        if (ip != 0)
                        {
                            double num10 = (numArray1[i5] - numArray1[i5 - 1]) / num3;
                            if (num1 == 0.0)
                            {
                                double num11 = num5 - 0.5 * num3;
                                do
                                {
                                    num11 += num3;
                                    double num12 = num11 - 0.5 * num3;
                                    if (kCent > num2)
                                    {
                                        int num13 = (int)MessageBox.Show("Индекс массива FullPolySymb");
                                        return;
                                    }
                                    ++kCent;
                                    xCent[kCent] = num12;
                                    yCent[kCent] = yt;
                                }
                                while (num11 < num7);
                            }
                            else if (num10 <= 1.0)
                            {
                                if (kCent > num2)
                                {
                                    int num14 = (int)MessageBox.Show("Индекс массива FullPolySymb");
                                    return;
                                }
                                ++kCent;
                                xCent[kCent] = xt1;
                                yCent[kCent] = yt;
                            }
                            else if (num10 > 1.0 && num1 > 0.0)
                            {
                                int int32 = Convert.ToInt32(num10);
                                double num15 = 0.5 * (numArray1[i5] - numArray1[i5 - 1] - (double)int32 * num3);
                                double xt2 = numArray1[i5 - 1] + num15;
                                do
                                {
                                    int num16 = in_out(k, ref x, ref y, xt2, yt);
                                    xt2 += num3;
                                    double xt3 = xt2 - 0.5 * num3;
                                    ip = in_out(k, ref x, ref y, xt3, yt);
                                    if (ip != 0 || num16 != 0)
                                    {
                                        if (kCent > num2)
                                        {
                                            int num17 = (int)MessageBox.Show("Индекс массива FullPolySymb");
                                            return;
                                        }
                                        ++kCent;
                                        xCent[kCent] = xt3;
                                        yCent[kCent] = yt;
                                    }
                                }
                                while (xt2 < numArray1[i5]);
                            }
                        }
                    }
                }
            }
            while (num9 < num8);
        }

        public static void PolyIntersect(
          int kExt,
          double[] xExt,
          double[] yExt,
          int k,
          double[] x,
          double[] y,
          out int kd,
          double[] xd,
          double[] yd,
          out int kInt,
          int[] nInt,
          double[] xInt,
          double[] yInt)
        {
            int[] numArray1 = new int[100];
            int[] numArray2 = new int[100];
            double[] numArray3 = new double[100];
            double[] numArray4 = new double[100];
            double[] x1 = new double[50];
            double[] y1 = new double[50];
            double[] r = new double[50];
            kd = 0;
            kInt = -1;
            int kArray = 999999;
            doubleArray(xd, ref kArray);
            doubleArray(yd, ref kArray);
            int num1 = kArray - 3;
            int i1 = 0;
            double xm;
            for (int i2 = 1; i2 <= k; ++i2)
            {
                double x1_1 = x[i2 - 1];
                double y1_1 = y[i2 - 1];
                double x2 = x[i2];
                double y2 = y[i2];
                for (int i3 = 1; i3 <= kExt; ++i3)
                {
                    double x3 = xExt[i3 - 1];
                    double y3 = yExt[i3 - 1];
                    double x4 = xExt[i3];
                    double y4 = yExt[i3];
                    int ip = 1;
                    xm = 0.0;
                    double ym = 0.0;
                    TwoLine(x1_1, y1_1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip);
                    if (xm != 0.0 || ym != 0.0)
                    {
                        ++i1;
                        numArray1[i1] = i2;
                        numArray2[i1] = i3;
                        numArray3[i1] = xm;
                        numArray4[i1] = ym;
                    }
                }
            }
            if (i1 == 0)
            {
                int num2 = -1;
                for (int i4 = 0; i4 <= k; ++i4)
                {
                    if (in_out(kExt, ref xExt, ref yExt, x[i4], y[i4]) > 0)
                        ++num2;
                }
                if (num2 != k)
                    return;
                kInt = k;
                for (int i5 = 0; i5 <= k; ++i5)
                {
                    xInt[i5] = x[i5];
                    yInt[i5] = y[i5];
                }
            }
            else
            {
                kd = 0;
                for (int i6 = 1; i6 <= k; ++i6)
                {
                    int k1 = 0;
                    for (int i7 = 1; i7 <= i1; ++i7)
                    {
                        if (numArray1[i7] == i6)
                        {
                            ++k1;
                            x1[k1] = numArray3[i7];
                            y1[k1] = numArray4[i7];
                            double num3 = numArray3[i7] - x[i6 - 1];
                            double num4 = numArray4[i7] - y[i6 - 1];
                            r[k1] = Math.Sqrt(num3 * num3 + num4 * num4);
                        }
                    }
                    switch (k1)
                    {
                        case 0:
                            xm = 0.5 * (x[i6 - 1] + x[i6]);
                            double yt1 = 0.5 * (y[i6 - 1] + y[i6]);
                            if (in_out(kExt, ref xExt, ref yExt, xm, yt1) > 0)
                            {
                                ++kd;
                                xd[kd] = x[i6 - 1];
                                yd[kd] = y[i6 - 1];
                                ++kd;
                                xd[kd] = x[i6];
                                yd[kd] = y[i6];
                                if (kd > num1)
                                {
                                    int num5 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                    return;
                                }
                                break;
                            }
                            break;
                        case 1:
                            xm = 0.5 * (x[i6 - 1] + x1[1]);
                            double yt2 = 0.5 * (y[i6 - 1] + y1[1]);
                            if (in_out(kExt, ref xExt, ref yExt, xm, yt2) > 0)
                            {
                                ++kd;
                                xd[kd] = x[i6 - 1];
                                yd[kd] = y[i6 - 1];
                                ++kd;
                                xd[kd] = x1[1];
                                yd[kd] = y1[1];
                                if (kd > num1)
                                {
                                    int num6 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                    return;
                                }
                            }
                            xm = 0.5 * (x1[1] + x[i6]);
                            double yt3 = 0.5 * (y1[1] + y[i6]);
                            if (in_out(kExt, ref xExt, ref yExt, xm, yt3) > 0)
                            {
                                ++kd;
                                xd[kd] = x1[1];
                                yd[kd] = y1[1];
                                ++kd;
                                xd[kd] = x[i6];
                                yd[kd] = y[i6];
                                if (kd > num1)
                                {
                                    int num7 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                    return;
                                }
                                break;
                            }
                            break;
                        default:
                            if (k1 > 1)
                            {
                                OrderPnt(k1, ref x1, ref y1, ref r);
                                xm = 0.5 * (x[i6 - 1] + x1[1]);
                                double yt4 = 0.5 * (y[i6 - 1] + y1[1]);
                                if (in_out(kExt, ref xExt, ref yExt, xm, yt4) > 0)
                                {
                                    ++kd;
                                    xd[kd] = x[i6 - 1];
                                    yd[kd] = y[i6 - 1];
                                    ++kd;
                                    xd[kd] = x1[1];
                                    yd[kd] = y1[1];
                                    if (kd > num1)
                                    {
                                        int num8 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                        return;
                                    }
                                }
                                for (int i8 = 2; i8 <= k1; ++i8)
                                {
                                    xm = 0.5 * (x1[i8 - 1] + x1[i8]);
                                    double yt5 = 0.5 * (y1[i8 - 1] + y1[i8]);
                                    if (in_out(kExt, ref xExt, ref yExt, xm, yt5) > 0)
                                    {
                                        ++kd;
                                        xd[kd] = x1[i8 - 1];
                                        yd[kd] = y1[i8 - 1];
                                        ++kd;
                                        xd[kd] = x1[i8];
                                        yd[kd] = y1[i8];
                                        if (kd > num1)
                                        {
                                            int num9 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                            return;
                                        }
                                    }
                                }
                                xm = 0.5 * (x1[k1] + x[i6]);
                                double yt6 = 0.5 * (y1[k1] + y[i6]);
                                if (in_out(kExt, ref xExt, ref yExt, xm, yt6) > 0)
                                {
                                    ++kd;
                                    xd[kd] = x1[k1];
                                    yd[kd] = y1[k1];
                                    ++kd;
                                    xd[kd] = x[i6];
                                    yd[kd] = y[i6];
                                    if (kd > num1)
                                    {
                                        int num10 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                        return;
                                    }
                                    break;
                                }
                                break;
                            }
                            break;
                    }
                }
                for (int i9 = 1; i9 <= kExt; ++i9)
                {
                    int k2 = 0;
                    for (int i10 = 1; i10 <= i1; ++i10)
                    {
                        if (numArray2[i10] == i9)
                        {
                            ++k2;
                            x1[k2] = numArray3[i10];
                            y1[k2] = numArray4[i10];
                            double num11 = numArray3[i10] - xExt[i9 - 1];
                            double num12 = numArray4[i10] - yExt[i9 - 1];
                            r[k2] = Math.Sqrt(num11 * num11 + num12 * num12);
                        }
                    }
                    switch (k2)
                    {
                        case 0:
                            xm = 0.5 * (xExt[i9 - 1] + xExt[i9]);
                            double yt7 = 0.5 * (yExt[i9 - 1] + yExt[i9]);
                            if (in_out(k, ref x, ref y, xm, yt7) > 0)
                            {
                                ++kd;
                                xd[kd] = xExt[i9 - 1];
                                yd[kd] = yExt[i9 - 1];
                                ++kd;
                                xd[kd] = xExt[i9];
                                yd[kd] = yExt[i9];
                                if (kd > num1)
                                {
                                    int num13 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                    return;
                                }
                                break;
                            }
                            break;
                        case 1:
                            xm = 0.5 * (xExt[i9 - 1] + x1[1]);
                            double yt8 = 0.5 * (yExt[i9 - 1] + y1[1]);
                            if (in_out(k, ref x, ref y, xm, yt8) > 0)
                            {
                                ++kd;
                                xd[kd] = xExt[i9 - 1];
                                yd[kd] = yExt[i9 - 1];
                                ++kd;
                                xd[kd] = x1[1];
                                yd[kd] = y1[1];
                                if (kd > num1)
                                {
                                    int num14 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                    return;
                                }
                            }
                            xm = 0.5 * (x1[1] + xExt[i9]);
                            double yt9 = 0.5 * (y1[1] + yExt[i9]);
                            if (in_out(k, ref x, ref y, xm, yt9) > 0)
                            {
                                ++kd;
                                xd[kd] = x1[1];
                                yd[kd] = y1[1];
                                ++kd;
                                xd[kd] = xExt[i9];
                                yd[kd] = yExt[i9];
                                if (kd > num1)
                                {
                                    int num15 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                    return;
                                }
                                break;
                            }
                            break;
                        default:
                            if (k2 > 1)
                            {
                                OrderPnt(k2, ref x1, ref y1, ref r);
                                xm = 0.5 * (xExt[i9 - 1] + x1[1]);
                                double yt10 = 0.5 * (yExt[i9 - 1] + y1[1]);
                                if (in_out(k, ref x, ref y, xm, yt10) > 0)
                                {
                                    ++kd;
                                    xd[kd] = xExt[i9 - 1];
                                    yd[kd] = yExt[i9 - 1];
                                    ++kd;
                                    xd[kd] = x1[1];
                                    yd[kd] = y1[1];
                                    if (kd > num1)
                                    {
                                        int num16 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                        return;
                                    }
                                }
                                for (int i11 = 2; i11 <= k2; ++i11)
                                {
                                    xm = 0.5 * (x1[i11 - 1] + x1[i11]);
                                    double yt11 = 0.5 * (y1[i11 - 1] + y1[i11]);
                                    if (in_out(k, ref x, ref y, xm, yt11) > 0)
                                    {
                                        ++kd;
                                        xd[kd] = x1[i11 - 1];
                                        yd[kd] = y1[i11 - 1];
                                        ++kd;
                                        xd[kd] = x1[i11];
                                        yd[kd] = y1[i11];
                                        if (kd > num1)
                                        {
                                            int num17 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                            return;
                                        }
                                    }
                                }
                                xm = 0.5 * (x1[k2] + xExt[i9]);
                                double yt12 = 0.5 * (y1[k2] + yExt[i9]);
                                if (in_out(k, ref x, ref y, xm, yt12) > 0)
                                {
                                    ++kd;
                                    xd[kd] = x1[k2];
                                    yd[kd] = y1[k2];
                                    ++kd;
                                    xd[kd] = xExt[i9];
                                    yd[kd] = yExt[i9];
                                    if (kd > num1)
                                    {
                                        int num18 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                        return;
                                    }
                                    break;
                                }
                                break;
                            }
                            break;
                    }
                }
                if (kd == 0)
                    return;
                ++kInt;
                xInt[kInt] = xd[1];
                yInt[kInt] = yd[1];
                ++kInt;
                xInt[kInt] = xd[2];
                yInt[kInt] = yd[2];
                int i12 = 1;
                nInt[i12] = 2;
                for (int i13 = 1; i13 <= kd; ++i13)
                {
                    for (int i14 = 4; i14 <= kd; i14 += 2)
                    {
                        int num19 = 0;
                        for (int i15 = 1; i15 <= i12; ++i15)
                        {
                            if (nInt[i15] == i14)
                            {
                                ++num19;
                                break;
                            }
                        }
                        if (num19 <= 0)
                        {
                            double num20 = xInt[kInt] - xd[i14 - 1];
                            double num21 = yInt[kInt] - yd[i14 - 1];
                            if (Math.Sqrt(num20 * num20 + num21 * num21) < 0.003)
                            {
                                if (kInt > num1)
                                {
                                    int num22 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                    return;
                                }
                                ++kInt;
                                xInt[kInt] = xd[i14];
                                yInt[kInt] = yd[i14];
                                ++i12;
                                nInt[i12] = i14;
                            }
                            else
                            {
                                double num23 = xInt[kInt] - xd[i14];
                                double num24 = yInt[kInt] - yd[i14];
                                if (Math.Sqrt(num23 * num23 + num24 * num24) < 0.003)
                                {
                                    if (kInt > num1)
                                    {
                                        int num25 = (int)MessageBox.Show("Индекс массива PolyIntersect");
                                        return;
                                    }
                                    ++kInt;
                                    xInt[kInt] = xd[i14 - 1];
                                    yInt[kInt] = yd[i14 - 1];
                                    ++i12;
                                    nInt[i12] = i14;
                                }
                            }
                        }
                    }
                    double num26 = xInt[kInt] - xInt[0];
                    double num27 = yInt[kInt] - yInt[0];
                    if (Math.Sqrt(num26 * num26 + num27 * num27) < 0.003)
                        break;
                }
            }
        }

        public static void Page_Area(
          double sPixInch,
          int dxSheet,
          int dySheet,
          int hText,
          int k,
          string[] sMess,
          int kPolFin,
          string[] namePol,
          double[] arCalcFin,
          double[] arLegFin,
          out int kNewMess,
          string[] sNewMess,
          int iSquare,
          int iPrecision,
          out int kPage,
          int[] k1,
          int[] k2,
          int[] kp,
          double sArea,
          double arExter,
          double[] aCalc,
          double[] aLeg)
        {
            string sTmp1 = "";
            string sTmp2 = "";
            char[] seps = new char[2] { ' ', ',' };
            int kPart = 50;
            double sar = 0.0;
            double num1 = 0.0;
            double num2 = 0.0;
            kNewMess = 0;
            kPage = 0;
            int num3;
            int num4 = num3 = 0;
            int k3 = num3;
            int num5 = num3;
            int kArray1 = 999999;
            stringArray(namePol, ref kArray1);
            doubleArray(arCalcFin, ref kArray1);
            doubleArray(arLegFin, ref kArray1);
            if (kPolFin > kArray1)
            {
                int num6 = (int)MessageBox.Show("Индекс массива Page_Area");
            }
            else
            {
                int kArray2 = 999999;
                stringArray(sMess, ref kArray2);
                stringArray(sNewMess, ref kArray2);
                intArray(k1, ref kArray2);
                intArray(k2, ref kArray2);
                intArray(kp, ref kArray2);
                doubleArray(aCalc, ref kArray2);
                doubleArray(aLeg, ref kArray2);
                if (k > kArray2)
                {
                    int num7 = (int)MessageBox.Show("Индекс массива Page_Area");
                }
                else
                {
                    int int32 = Convert.ToInt32(0.8 * (double)dxSheet / sPixInch);
                    Convert.ToInt32(0.1 * (double)dxSheet / sPixInch);
                    int num8 = 30;
                    int num9 = num8;
                    int num10 = int32 / 5;
                    int num11 = hText + hText / 2;
                    int num12 = Convert.ToInt32((double)dySheet / sPixInch) - 10 * hText;
                    Equal_Area(iSquare, iPrecision, sArea, arExter, kPolFin, arCalcFin, arLegFin, aCalc, aLeg);
                    string[] sPart;
                    for (int i1 = 1; i1 <= kPolFin; ++i1)
                    {
                        int num13 = 0;
                        double aConv1 = 0.0;
                        double aConv2 = 0.0;
                        for (int i2 = 1; i2 <= k; ++i2)
                        {
                            ShareString(sMess[i2], kPart, seps, out k3, out sPart);
                            switch (k3)
                            {
                                case 0:
                                    return;
                                case 1:
                                case 2:
                                    continue;
                                default:
                                    if (namePol[i1] == sPart[1])
                                    {
                                        ++num13;
                                        aConv1 = Convert.ToDouble(sPart[2]);
                                        aConv2 = Convert.ToDouble(sPart[3]);
                                        goto label_12;
                                    }
                                    else
                                        continue;
                            }
                        }
                    label_12:
                        if (num13 == 0)
                        {
                            AreaConvert(aCalc[i1], iSquare, out aConv1);
                            AreaConvert(aLeg[i1], iSquare, out aConv2);
                        }
                        Precision_Set(iPrecision, aConv1, out sTmp1, out sar);
                        Precision_Set(iPrecision, aConv2, out sTmp2, out sar);
                        ++kNewMess;
                        sNewMess[kNewMess] = namePol[i1] + "  " + sTmp1 + "  " + sTmp2;
                        double num14 = Convert.ToDouble(sTmp1);
                        aConv2 = Convert.ToDouble(sTmp2);
                        num1 += num14;
                        num2 += aConv2;
                    }
                    ++kNewMess;
                    sNewMess[kNewMess] = "0";
                    int num15 = 1;
                    int num16 = 0;
                    for (int i3 = 1; i3 <= kNewMess && num15 < kNewMess; ++i3)
                    {
                        num8 = num8 + 2 * num11 + hText / 2 + num11 + hText / 2 + num11;
                        for (int i4 = num15; i4 <= kNewMess; ++i4)
                        {
                            ShareString(sNewMess[i4], kPart, seps, out k3, out sPart);
                            switch (k3)
                            {
                                case 0:
                                    return;
                                case 1:
                                case 2:
                                    num5 = i4;
                                    break;
                                default:
                                    num8 += num11;
                                    if (i4 == kNewMess)
                                    {
                                        num5 = kNewMess;
                                        goto label_30;
                                    }
                                    else
                                    {
                                        if (num8 < num12)
                                        {
                                            ++num16;
                                            num5 = i4;
                                            break;
                                        }
                                        if (num8 >= num12)
                                        {
                                            num5 = i4;
                                            if (num16 > 0)
                                            {
                                                ++kPage;
                                                kp[kPage] = i4 - num15 + 1;
                                                num8 = num9;
                                                num16 = 0;
                                                goto label_30;
                                            }
                                            else
                                                goto label_30;
                                        }
                                        else
                                            break;
                                    }
                            }
                        }
                    label_30:
                        if (num16 > 0)
                        {
                            ++kPage;
                            kp[kPage] = num5 - num15 + 1;
                            num8 = num9;
                            num16 = 0;
                        }
                        num15 = num5 + 1;
                    }
                    if (kPage <= 0)
                        return;
                    k1[1] = 1;
                    k2[1] = kp[1];
                    if (kPage <= 0)
                        return;
                    for (int i = 2; i <= kPage; ++i)
                    {
                        k1[i] = k2[i - 1] + 1;
                        k2[i] = k2[i - 1] + kp[i];
                    }
                }
            }
        }

        public static void Equal_Area(
          int iSquare,
          int iPrecision,
          double sArea,
          double arExter,
          int kPolFin,
          double[] arCalcFin,
          double[] arLegFin,
          double[] dCalc,
          double[] dLeg)
        {
            string sTmp1 = "";
            string sTmp2 = "";
            int num1 = 0;
            double num2 = 0.0;
            double sar1 = sArea;
            double sar2 = arExter;
            double num3;
            double sar3 = num3 = 0.0;
            double ar1 = num3;
            double ar2 = num3;
            int num4;
            int num5 = num4 = 0;
            int kArray = 999999;
            doubleArray(arCalcFin, ref kArray);
            doubleArray(arLegFin, ref kArray);
            doubleArray(dCalc, ref kArray);
            doubleArray(dLeg, ref kArray);
            if (kPolFin > kArray)
            {
                int num6 = (int)MessageBox.Show("Индекс массива Equal_Area");
            }
            else
            {
                if (iPrecision == 1)
                {
                    num1 = 10;
                    num2 = 0.1;
                }
                if (iPrecision == 2)
                {
                    num1 = 100;
                    num2 = 0.01;
                }
                if (iPrecision == 3)
                {
                    num1 = 1000;
                    num2 = 0.001;
                }
                if (iPrecision == 4)
                {
                    num1 = 10000;
                    num2 = 0.0001;
                }
                double aConv1;
                AreaConvert(sar1, iSquare, out aConv1);
                Precision_Set(iPrecision, aConv1, out sTmp1, out sar1);
                AreaConvert(sar2, iSquare, out aConv1);
                Precision_Set(iPrecision, aConv1, out sTmp2, out sar2);
                for (int i = 1; i <= kPolFin; ++i)
                {
                    sar3 = Math.Abs(arCalcFin[i] - arLegFin[i]);
                    if (sar3 < 0.0005)
                        arLegFin[i] = arCalcFin[i];
                    AreaConvert(arCalcFin[i], iSquare, out aConv1);
                    double aConv2;
                    AreaConvert(arLegFin[i], iSquare, out aConv2);
                    Precision_Set(iPrecision, aConv1, out sTmp1, out sar3);
                    aConv1 = sar3;
                    Precision_Set(iPrecision, aConv2, out sTmp2, out sar3);
                    aConv2 = sar3;
                    dCalc[i] = aConv1;
                    dLeg[i] = aConv2;
                    ar2 += aConv1;
                    ar1 += aConv2;
                }
                Precision_Set(iPrecision, ar2, out sTmp1, out sar3);
                double num7 = sar3;
                Precision_Set(iPrecision, ar1, out sTmp2, out sar3);
                double num8 = sar3;
                if (Math.Abs(num7 - sar1) >= 0.1)
                    return;
                int int32_1 = Convert.ToInt32((double)num1 * sar1);
                int int32_2 = Convert.ToInt32((double)num1 * sar2);
                int int32_3 = Convert.ToInt32((double)num1 * num7);
                int int32_4 = Convert.ToInt32((double)num1 * num8);
                int num9 = int32_3 - int32_1;
                if (num9 > 0)
                {
                    int num10 = 0;
                    for (int i1 = 1; i1 <= num9; ++i1)
                    {
                        for (int i2 = 1; i2 <= kPolFin; ++i2)
                        {
                            ++num10;
                            dCalc[i2] = dCalc[i2] - num2;
                            if (num10 == num9)
                                break;
                        }
                        if (num10 == num9)
                            break;
                    }
                }
                if (num9 < 0)
                {
                    int num11 = int32_1 - int32_3;
                    int num12 = 0;
                    for (int i3 = 1; i3 <= num11; ++i3)
                    {
                        for (int i4 = 1; i4 <= kPolFin; ++i4)
                        {
                            ++num12;
                            dCalc[i4] = dCalc[i4] + num2;
                            if (num12 == num11)
                                break;
                        }
                        if (num12 == num11)
                            break;
                    }
                }
                int num13 = int32_4 - int32_2;
                if (num13 > 0)
                {
                    int num14 = 0;
                    for (int i5 = 1; i5 <= num13; ++i5)
                    {
                        for (int i6 = 1; i6 <= kPolFin; ++i6)
                        {
                            ++num14;
                            dLeg[i6] = dLeg[i6] - num2;
                            if (num14 == num13)
                                break;
                        }
                        if (num14 == num13)
                            break;
                    }
                }
                if (num13 >= 0)
                    return;
                int num15 = int32_2 - int32_4;
                int num16 = 0;
                for (int i7 = 1; i7 <= num15; ++i7)
                {
                    for (int i8 = 1; i8 <= kPolFin; ++i8)
                    {
                        ++num16;
                        dLeg[i8] = dLeg[i8] + num2;
                        if (num16 == num15)
                            break;
                    }
                    if (num16 == num15)
                        break;
                }
            }
        }

        public static void PageCount(
          double sPixInch,
          int dxSheet,
          int dySheet,
          int hText,
          int k,
          string[] sMess,
          out int kPage,
          int[] k1,
          int[] k2,
          int[] kp,
          int[] nTab)
        {
            char[] seps = new char[2] { ' ', ',' };
            int kPart = 50;
            string[] strArray = new string[200];
            int num1 = 0;
            kPage = 0;
            int num2;
            int k3 = num2 = 0;
            Convert.ToInt32(0.25 * (double)dxSheet / sPixInch);
            int num3 = 30;
            int int32_1 = Convert.ToInt32(0.5 * (double)dxSheet / sPixInch);
            int int32_2 = Convert.ToInt32((double)dySheet / sPixInch);
            int num4 = int32_1 / 4;
            int num5 = hText + hText / 2;
            int num6;
            int i1 = num6 = 0;
            int i2 = num6;
            int k4 = num6;
            int k5 = num6;
            int num7 = num6;
            int num8 = num3 + num5;
            int num9 = num8;
            int kArray = 999999;
            stringArray(sMess, ref kArray);
            intArray(k1, ref kArray);
            intArray(k2, ref kArray);
            intArray(kp, ref kArray);
            intArray(nTab, ref kArray);
            if (k > kArray)
            {
                int num10 = (int)MessageBox.Show("Индекс массива PageCount");
            }
            else
            {
                int num11 = 1;
                for (int i3 = 1; i3 <= k && num11 < k; ++i3)
                {
                    for (int i4 = num11; i4 <= k; ++i4)
                    {
                        num2 = i4;
                        string[] sPart;
                        ShareString(sMess[i4], kPart, seps, out k3, out sPart);
                        switch (k3)
                        {
                            case 0:
                                return;
                            case 2:
                                int int32_3 = Convert.ToInt32(sPart[1]);
                                if (int32_3 != 10)
                                {
                                    if (int32_3 == 210 || int32_3 == 220 || int32_3 == 230 || int32_3 == 240 || int32_3 == 250 || int32_3 == 260)
                                    {
                                        int num12 = num8 + num5 + 2 * hText + hText / 2 + hText + hText / 2 + hText / 2 + hText + hText / 2;
                                        int num13 = 999;
                                        int i5 = 0;
                                        i1 = num2;
                                        do
                                        {
                                            ++i1;
                                            string sLine = sMess[i1];
                                            ShareString(sLine, kPart, seps, out k5, out sPart);
                                            switch (k5)
                                            {
                                                case 0:
                                                    return;
                                                case 1:
                                                    num7 = 0;
                                                    goto label_13;
                                                default:
                                                    ++i5;
                                                    strArray[i5] = sLine;
                                                    continue;
                                            }
                                        }
                                        while (num13 != 0);
                                    label_13:
                                        for (int i6 = 2; i6 <= i5; ++i6)
                                        {
                                            ShareString(strArray[i6], kPart, seps, out k5, out sPart);
                                            if (k5 == 0)
                                                return;
                                            num12 = num12 + hText + hText / 2;
                                        }
                                        ShareString(strArray[1], kPart, seps, out k5, out sPart);
                                        if (k5 == 0)
                                            return;
                                        num8 = num12 + hText + hText / 2;
                                        if (num8 < int32_2)
                                        {
                                            num2 = i1;
                                            ++num1;
                                        }
                                        if (num8 >= int32_2)
                                        {
                                            ++i2;
                                            kp[i2] = num2;
                                            num8 = num9;
                                            nTab[i2] = num1;
                                            num1 = 0;
                                            goto label_88;
                                        }
                                        else
                                            goto label_88;
                                    }
                                    else
                                    {
                                        if (int32_3 == 270 || int32_3 == 280)
                                        {
                                            do
                                            {
                                                ShareString(sMess[num2 + 1], kPart, seps, out k4, out sPart);
                                                if (k4 == 0)
                                                    return;
                                                int num14 = num8 + num5 + 2 * hText + hText / 2 + hText + hText / 2 + hText / 2 + hText + hText / 2;
                                                int num15 = 999;
                                                int i7 = 0;
                                                i1 = num2;
                                                do
                                                {
                                                    ++i1;
                                                    string sLine = sMess[i1];
                                                    ShareString(sLine, kPart, seps, out k5, out sPart);
                                                    switch (k5)
                                                    {
                                                        case 0:
                                                            return;
                                                        case 1:
                                                            num7 = 0;
                                                            goto label_32;
                                                        default:
                                                            ++i7;
                                                            strArray[i7] = sLine;
                                                            continue;
                                                    }
                                                }
                                                while (num15 != 0);
                                            label_32:
                                                for (int i8 = 2; i8 <= i7; ++i8)
                                                {
                                                    ShareString(strArray[i8], kPart, seps, out k5, out sPart);
                                                    if (k5 == 0)
                                                        return;
                                                    num14 = num14 + hText + hText / 2;
                                                }
                                                ShareString(strArray[1], kPart, seps, out k5, out sPart);
                                                if (k5 == 0)
                                                    return;
                                                num8 = num14 + hText + hText / 2;
                                                if (num8 < int32_2)
                                                {
                                                    num2 = i1;
                                                    ++num1;
                                                }
                                                if (num8 >= int32_2)
                                                {
                                                    ++i2;
                                                    kp[i2] = num2;
                                                    num8 = num9;
                                                    nTab[i2] = num1;
                                                    num1 = 0;
                                                }
                                            }
                                            while (i1 < k && k4 != 2);
                                        }
                                        if (int32_3 == 290)
                                        {
                                            while (i1 != k)
                                            {
                                                i1 = num2;
                                                ShareString(sMess[num2 + 1], kPart, seps, out k4, out sPart);
                                                if (k4 == 0)
                                                    return;
                                                int num16 = num8 + num5;
                                                if (k4 == 2)
                                                    ++i1;
                                                num8 = num16 + 2 * hText + hText / 2 + hText + hText / 2 + hText / 2 + hText + hText / 2;
                                                int num17 = 999;
                                                int i9 = 0;
                                                while (i1 != k)
                                                {
                                                    ++i1;
                                                    string sLine = sMess[i1];
                                                    ShareString(sLine, kPart, seps, out k5, out sPart);
                                                    switch (k5)
                                                    {
                                                        case 0:
                                                            return;
                                                        case 1:
                                                            num7 = 0;
                                                            goto label_56;
                                                        default:
                                                            ++i9;
                                                            strArray[i9] = sLine;
                                                            if (num17 != 0)
                                                                continue;
                                                            goto label_56;
                                                    }
                                                }
                                            label_56:
                                                if (i9 >= 2)
                                                {
                                                    for (int i10 = 2; i10 <= i9; ++i10)
                                                    {
                                                        ShareString(strArray[i10], kPart, seps, out k5, out sPart);
                                                        if (k5 == 0)
                                                            return;
                                                        num8 = num8 + hText + hText / 2;
                                                    }
                                                    ShareString(strArray[1], kPart, seps, out k5, out sPart);
                                                    if (k5 == 0)
                                                        return;
                                                    num8 = num8 + hText + hText / 2;
                                                    if (num8 < int32_2)
                                                    {
                                                        num2 = i1;
                                                        ++num1;
                                                    }
                                                    if (num8 >= int32_2)
                                                    {
                                                        ++i2;
                                                        kp[i2] = num2;
                                                        num8 = num9;
                                                        nTab[i2] = num1;
                                                        num1 = 0;
                                                    }
                                                }
                                                if (k4 == 2)
                                                    break;
                                            }
                                        }
                                        if (int32_3 == 310 || int32_3 == 320 || int32_3 == 410)
                                        {
                                            int num18 = num8 + num5 + 2 * hText + hText / 2 + hText + hText / 2 + hText / 2 + hText + hText / 2;
                                            int num19 = 999;
                                            int i11 = 0;
                                            i1 = num2;
                                            do
                                            {
                                                ++i1;
                                                string sLine = sMess[i1];
                                                ShareString(sLine, kPart, seps, out k5, out sPart);
                                                switch (k5)
                                                {
                                                    case 0:
                                                        return;
                                                    case 1:
                                                        num7 = 0;
                                                        goto label_75;
                                                    default:
                                                        ++i11;
                                                        strArray[i11] = sLine;
                                                        continue;
                                                }
                                            }
                                            while (num19 != 0);
                                        label_75:
                                            for (int i12 = 2; i12 <= i11; ++i12)
                                            {
                                                ShareString(strArray[i12], kPart, seps, out k5, out sPart);
                                                if (k5 == 0)
                                                    return;
                                                num18 = num18 + hText + hText / 2;
                                            }
                                            ShareString(strArray[1], kPart, seps, out k5, out sPart);
                                            if (k5 == 0)
                                                return;
                                            num8 = num18 + hText + hText / 2;
                                            if (num8 < int32_2)
                                            {
                                                num2 = i1;
                                                ++num1;
                                            }
                                            if (num8 >= int32_2)
                                            {
                                                ++i2;
                                                kp[i2] = num2;
                                                num8 = num9;
                                                nTab[i2] = num1;
                                                num1 = 0;
                                                goto label_88;
                                            }
                                            else
                                                goto label_88;
                                        }
                                        else
                                            break;
                                    }
                                }
                                else
                                    goto label_88;
                        }
                    }
                label_88:
                    num11 = num2 + 1;
                }
                if (i2 == 0)
                {
                    kPage = 1;
                    k1[1] = 1;
                    k2[1] = k;
                    nTab[1] = num1;
                }
                if (i2 <= 0)
                    return;
                kPage = 1;
                k1[1] = 1;
                k2[1] = kp[1];
                if (i2 > 1)
                {
                    for (int i13 = 2; i13 <= i2; ++i13)
                    {
                        ++kPage;
                        k1[kPage] = k2[i13 - 1] + 1;
                        k2[kPage] = kp[i13];
                    }
                }
                if (k <= k2[kPage])
                    return;
                ++kPage;
                k1[kPage] = k2[kPage - 1] + 1;
                k2[kPage] = k;
                nTab[kPage] = num1;
            }
        }

        public static void TablePrepare(
          int k,
          string[] sMess,
          int iSquare,
          int iPrecision,
          out int kMess,
          string[] sMessNew,
          string[] sNew,
          double[] dopCalc,
          double[] dopLeg,
          double sArea,
          double arExter,
          int kPolFin,
          string[] namePol,
          double[] arCalcFin,
          double[] arLegFin,
          double[] dCalc,
          double[] dLeg)
        {
            string sTmp1 = "";
            string sTmp2 = "";
            string sTmp3 = "";
            string sTmp4 = "";
            char[] seps = new char[2] { ' ', ',' };
            int kPart = 50;
            int num1 = 0;
            int num2 = 0;
            double num3 = 0.0;
            double sArea1 = sArea;
            double arExter1 = arExter;
            double ar1;
            double ar2 = ar1 = 0.0;
            int num4;
            int i1 = num4 = 0;
            int num5 = num4;
            int k1 = num4;
            int num6;
            int num7 = num6 = 0;
            kMess = k;
            int kArray1 = 999999;
            doubleArray(arCalcFin, ref kArray1);
            doubleArray(arLegFin, ref kArray1);
            doubleArray(dCalc, ref kArray1);
            doubleArray(dLeg, ref kArray1);
            if (kPolFin > kArray1)
            {
                int num8 = (int)MessageBox.Show("Индекс массива TablePrepare");
            }
            else
            {
                int kArray2 = 999999;
                stringArray(sMess, ref kArray2);
                stringArray(sMessNew, ref kArray2);
                stringArray(sNew, ref kArray2);
                doubleArray(dopCalc, ref kArray2);
                doubleArray(dopLeg, ref kArray2);
                if (k > kArray2)
                {
                    int num9 = (int)MessageBox.Show("Индекс массива TablePrepare");
                }
                else
                {
                    Equal_Area(iSquare, iPrecision, sArea1, arExter1, kPolFin, arCalcFin, arLegFin, dCalc, dLeg);
                    double num10 = 0.0;
                    double num11 = 0.0;
                    for (int i2 = 1; i2 <= kPolFin; ++i2)
                    {
                        num10 += dCalc[i2];
                        num11 += dLeg[i2];
                    }
                    int num12 = 1;
                    for (int i3 = 1; i3 <= k && num12 < k; ++i3)
                    {
                        for (int i4 = num12; i4 <= k; ++i4)
                        {
                            num5 = i4;
                            string sLine1 = sMess[i4];
                            string[] sPart;
                            ShareString(sLine1, kPart, seps, out k1, out sPart);
                            if (k1 == 0)
                                return;
                            if (k1 == 1)
                            {
                                sMessNew[i4] = sLine1;
                            }
                            else
                            {
                                if (k1 == 2)
                                {
                                    int int32 = Convert.ToInt32(sPart[1]);
                                    if (int32 == 210 || int32 == 220 || int32 == 230 || int32 == 240 || int32 == 250 || int32 == 260 || int32 == 270 || int32 == 280 || int32 == 290)
                                        num1 = 1;
                                    if (int32 == 10 || int32 == 310 || int32 == 320 || int32 == 410)
                                        num1 = 2;
                                    sMessNew[i4] = sLine1;
                                    i1 = num5;
                                }
                                int k2;
                                if (k1 == 3)
                                {
                                    int i5 = num5;
                                    for (int i6 = 1; i6 < num5; ++i6)
                                    {
                                        --i5;
                                        ShareString(sMess[i5], kPart, seps, out k2, out sPart);
                                        switch (k2)
                                        {
                                            case 0:
                                                return;
                                            case 2:
                                                int int32 = Convert.ToInt32(sPart[1]);
                                                if (int32 == 210 || int32 == 220 || int32 == 230 || int32 == 240 || int32 == 250 || int32 == 260 || int32 == 270 || int32 == 280 || int32 == 290)
                                                    num1 = 1;
                                                if (int32 == 10 || int32 == 310 || int32 == 320 || int32 == 410)
                                                    num1 = 2;
                                                i1 = num5 - 1;
                                                goto label_31;
                                            default:
                                                continue;
                                        }
                                    }
                                }
                            label_31:
                                int num13 = i1;
                                int num14 = 999;
                                int i7 = 0;
                                do
                                {
                                    ++i1;
                                    string sLine2 = sMess[i1];
                                    ShareString(sLine2, kPart, seps, out k2, out sPart);
                                    switch (k2)
                                    {
                                        case 0:
                                            return;
                                        case 1:
                                            sMessNew[i1] = sLine2;
                                            goto label_36;
                                        default:
                                            ++i7;
                                            sNew[i7] = sLine2;
                                            continue;
                                    }
                                }
                                while (num14 != 0);
                            label_36:
                                num5 = i1;
                                double num15 = 0.0;
                                double num16 = 0.0;
                                double sar1;
                                double sar2;
                                for (int i8 = 1; i8 <= i7; ++i8)
                                {
                                    ShareString(sNew[i8], kPart, seps, out k2, out sPart);
                                    if (k2 == 0)
                                        return;
                                    sar1 = Convert.ToDouble(sPart[2]);
                                    double aConv1;
                                    AreaConvert(sar1, iSquare, out aConv1);
                                    Precision_Set(iPrecision, aConv1, out sTmp3, out sar1);
                                    aConv1 = sar1;
                                    sar2 = Convert.ToDouble(sPart[3]);
                                    double aConv2;
                                    AreaConvert(sar2, iSquare, out aConv2);
                                    Precision_Set(iPrecision, aConv2, out sTmp4, out sar2);
                                    aConv2 = sar2;
                                    for (int i9 = 1; i9 <= kPolFin; ++i9)
                                    {
                                        if (namePol[i9] == sPart[1])
                                        {
                                            aConv1 = dCalc[i9];
                                            aConv2 = dLeg[i9];
                                            break;
                                        }
                                    }
                                    dopCalc[i8] = aConv1;
                                    dopLeg[i8] = aConv2;
                                    if (i8 > 1)
                                    {
                                        num15 += aConv1;
                                        num16 += aConv2;
                                    }
                                    if (i8 == 1)
                                    {
                                        ar2 = aConv1;
                                        ar1 = aConv2;
                                    }
                                }
                                int int32_1 = Convert.ToInt32((double)num2 * ar2);
                                int int32_2 = Convert.ToInt32((double)num2 * ar1);
                                int int32_3 = Convert.ToInt32((double)num2 * num15);
                                int int32_4 = Convert.ToInt32((double)num2 * num16);
                                if (num1 == 1)
                                {
                                    ar2 = num15;
                                    ar1 = num16;
                                    dopCalc[1] = num15;
                                    dopLeg[1] = num16;
                                }
                                if (num1 == 2)
                                {
                                    int num17 = int32_3 - int32_1;
                                    if (num17 > 0)
                                    {
                                        int num18 = 0;
                                        for (int i10 = 1; i10 <= num17; ++i10)
                                        {
                                            for (int i11 = 2; i11 <= i7; ++i11)
                                            {
                                                ++num18;
                                                dopCalc[i11] = dopCalc[i11] - num3;
                                                if (num18 == num17)
                                                    break;
                                            }
                                            if (num18 == num17)
                                                break;
                                        }
                                    }
                                    if (num17 < 0)
                                    {
                                        int num19 = int32_1 - int32_3;
                                        int num20 = 0;
                                        for (int i12 = 1; i12 <= num19; ++i12)
                                        {
                                            for (int i13 = 2; i13 <= i7; ++i13)
                                            {
                                                ++num20;
                                                dopCalc[i13] = dopCalc[i13] + num3;
                                                if (num20 == num19)
                                                    break;
                                            }
                                            if (num20 == num19)
                                                break;
                                        }
                                    }
                                    int num21 = int32_4 - int32_2;
                                    if (num21 > 0)
                                    {
                                        int num22 = 0;
                                        for (int i14 = 1; i14 <= num21; ++i14)
                                        {
                                            for (int i15 = 2; i15 <= i7; ++i15)
                                            {
                                                ++num22;
                                                dopLeg[i15] = dopLeg[i15] - num3;
                                                if (num22 == num21)
                                                    break;
                                            }
                                            if (num22 == num21)
                                                break;
                                        }
                                    }
                                    if (num21 < 0)
                                    {
                                        int num23 = int32_2 - int32_4;
                                        int num24 = 0;
                                        for (int i16 = 1; i16 <= num23; ++i16)
                                        {
                                            for (int i17 = 2; i17 <= i7; ++i17)
                                            {
                                                ++num24;
                                                dopLeg[i17] = dopLeg[i17] + num3;
                                                if (num24 == num23)
                                                    break;
                                            }
                                            if (num24 == num23)
                                                break;
                                        }
                                    }
                                }
                                double num25 = 0.0;
                                double num26 = 0.0;
                                for (int i18 = 2; i18 <= i7; ++i18)
                                {
                                    num25 += dopCalc[i18];
                                    num26 += dopLeg[i18];
                                }
                                ShareString(sNew[1], kPart, seps, out k2, out sPart);
                                if (k2 == 0)
                                    return;
                                string str1 = sPart[1];
                                Precision_Set(iPrecision, ar2, out sTmp3, out sar1);
                                Precision_Set(iPrecision, ar1, out sTmp4, out sar2);
                                int i19 = num13 + 1;
                                for (int i20 = 2; i20 <= i7; ++i20)
                                {
                                    ShareString(sNew[i20], kPart, seps, out k2, out sPart);
                                    if (k2 == 0)
                                        return;
                                    Precision_Set(iPrecision, dopCalc[i20], out sTmp1, out sar1);
                                    Precision_Set(iPrecision, dopLeg[i20], out sTmp2, out sar2);
                                    string str2 = sPart[1] + "  " + sTmp1 + "  " + sTmp2;
                                    ++i19;
                                    sMessNew[i19] = str2;
                                }
                                string str3 = str1 + "  " + sTmp3 + "  " + sTmp4;
                                sMessNew[num13 + 1] = str3;
                                break;
                            }
                        }
                        num12 = num5 + 1;
                    }
                }
            }
        }

        public static void Print_Report(
          PrintPageEventArgs e,
          double sPixInch,
          int dxSheet,
          int dySheet,
          int hText,
          int k,
          string[] sMess,
          int kPage,
          int[] k1,
          int[] k2,
          int ni,
          int newTable,
          out int nTable,
          int iSquare,
          int iPrecision,
          string[] sNew)
        {
            string s1 = "";
            char[] seps = new char[2] { ' ', ',' };
            int kPart = 50;
            int num1;
            int k3 = num1 = 0;
            nTable = 0;
            int kArray1 = 999999;
            stringArray(sMess, ref kArray1);
            stringArray(sNew, ref kArray1);
            if (k > kArray1)
            {
                int num2 = (int)MessageBox.Show("Индекс массива Print_Report");
            }
            else
            {
                int kArray2 = 999999;
                intArray(k1, ref kArray2);
                intArray(k2, ref kArray2);
                if (kPage > kArray2)
                {
                    int num3 = (int)MessageBox.Show("Индекс массива Print_Report");
                }
                else
                {
                    int int32_1 = Convert.ToInt32(0.25 * (double)dxSheet / sPixInch);
                    int y1 = 30;
                    int int32_2 = Convert.ToInt32(0.5 * (double)dxSheet / sPixInch);
                    Convert.ToInt32((double)dySheet / sPixInch);
                    int num4 = int32_2 / 4;
                    int num5 = hText + hText / 2;
                    int num6;
                    int i1 = num6 = 0;
                    int k4 = num6;
                    int num7 = num6;
                    int num8;
                    int num9 = num8 = 0;
                    nTable = newTable;
                    SolidBrush solidBrush = new SolidBrush(Color.Black);
                    Pen pen = new Pen(Color.Black);
                    pen.Width = 1f;
                    int num10 = k1[ni];
                    int num11 = k2[ni];
                    e.Graphics.DrawString("Таблица действий", new Font("Bold", (float)(hText + hText / 2)), (Brush)solidBrush, (float)(int32_1 + int32_2 / 3 - 10), (float)y1);
                    int num12 = y1 + num5;
                    int num13 = num10;
                    for (int i2 = 1; i2 <= k && num13 != num11; ++i2)
                    {
                        string s2 = "";
                        for (int i3 = num13; i3 <= num11; ++i3)
                        {
                            num1 = i3;
                            string[] sPart;
                            ShareString(sMess[i3], kPart, seps, out k3, out sPart);
                            if (k3 == 0)
                                return;
                            if (k3 != 1)
                            {
                                if (k3 == 2)
                                {
                                    int int32_3 = Convert.ToInt32(sPart[1]);
                                    if (int32_3 == 210 || int32_3 == 220 || int32_3 == 230 || int32_3 == 240 || int32_3 == 250 || int32_3 == 260 || int32_3 == 270 || int32_3 == 280 || int32_3 == 290)
                                    {
                                        ++nTable;
                                        s2 = string.Format("{0}", (object)nTable) + ". Разделение";
                                    }
                                    if (int32_3 == 10 || int32_3 == 310 || int32_3 == 320 || int32_3 == 410)
                                    {
                                        ++nTable;
                                        s2 = string.Format("{0}", (object)nTable) + ". Слияние";
                                    }
                                    i1 = num1;
                                }
                                if (k3 == 3)
                                {
                                    int i4 = num1;
                                    for (int i5 = 1; i5 < num1; ++i5)
                                    {
                                        --i4;
                                        ShareString(sMess[i4], kPart, seps, out k4, out sPart);
                                        switch (k4)
                                        {
                                            case 0:
                                                return;
                                            case 2:
                                                int int32_4 = Convert.ToInt32(sPart[1]);
                                                if (int32_4 == 210 || int32_4 == 220 || int32_4 == 230 || int32_4 == 240 || int32_4 == 250 || int32_4 == 260 || int32_4 == 270 || int32_4 == 280 || int32_4 == 290)
                                                {
                                                    ++nTable;
                                                    s2 = string.Format("{0}", (object)nTable) + ". Разделение";
                                                }
                                                if (int32_4 == 10 || int32_4 == 310 || int32_4 == 320 || int32_4 == 410)
                                                {
                                                    ++nTable;
                                                    s2 = string.Format("{0}", (object)nTable) + ". Слияние";
                                                }
                                                i1 = num1 - 1;
                                                goto label_27;
                                            default:
                                                continue;
                                        }
                                    }
                                }
                            label_27:
                                int y2 = num12 + num5;
                                e.Graphics.DrawString(s2, new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_1 + int32_2 / 2 - 40), (float)y2);
                                int num14 = y2 + 2 * hText;
                                e.Graphics.DrawLine(pen, int32_1, num14, int32_1 + int32_2, num14);
                                int num15 = int32_1;
                                int y1_1 = num14;
                                int y3 = num14 + hText / 2;
                                e.Graphics.DrawString("Area,", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_1 + 30), (float)y3);
                                e.Graphics.DrawString("Название участка", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_1 + 2 * num4), (float)y3);
                                int num16 = y3 + hText + hText / 2;
                                e.Graphics.DrawLine(pen, int32_1 + num4, num16, int32_1 + int32_2, num16);
                                int num17 = int32_1 + 2 * num4;
                                int y1_2 = num16;
                                int y4 = num16 + hText / 2;
                                if (iSquare == 1)
                                    s1 = "м.кв";
                                if (iSquare == 2)
                                    s1 = "hectare";
                                if (iSquare == 3)
                                    s1 = "acre";
                                if (iSquare == 4)
                                    s1 = "dunam";
                                e.Graphics.DrawString(s1, new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_1 + 30), (float)y4);
                                e.Graphics.DrawString("Конечный", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_1 + num4 + 20), (float)y4);
                                e.Graphics.DrawString("Временный", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_1 + 2 * num4 + 10), (float)y4);
                                int num18 = y4 + hText + hText / 2;
                                e.Graphics.DrawLine(pen, int32_1, num18, int32_1 + int32_2, num18);
                                int num19 = 999;
                                int i6 = 0;
                                do
                                {
                                    ++i1;
                                    string sLine = sMess[i1];
                                    ShareString(sLine, kPart, seps, out k4, out sPart);
                                    switch (k4)
                                    {
                                        case 0:
                                            return;
                                        case 1:
                                            num7 = 0;
                                            goto label_40;
                                        default:
                                            ++i6;
                                            sNew[i6] = sLine;
                                            continue;
                                    }
                                }
                                while (num19 != 0);
                            label_40:
                                num1 = i1;
                                ShareString(sNew[1], kPart, seps, out k4, out sPart);
                                if (k4 == 0)
                                    return;
                                string s3 = sPart[1];
                                string s4 = sPart[3];
                                for (int i7 = 2; i7 <= i6; ++i7)
                                {
                                    ShareString(sNew[i7], kPart, seps, out k4, out sPart);
                                    if (k4 == 0)
                                        return;
                                    e.Graphics.DrawString(sPart[3], new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_1 + 10), (float)num18);
                                    string s5 = sPart[1];
                                    if (s5[0] == 'F')
                                        e.Graphics.DrawString(s5, new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_1 + num4 + 10), (float)num18);
                                    if (s5[0] == 'T' || char.IsDigit(s5[0]))
                                        e.Graphics.DrawString(s5, new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_1 + 2 * num4 + 10), (float)num18);
                                    num18 = num18 + hText + hText / 2;
                                }
                                e.Graphics.DrawLine(pen, int32_1, num18, int32_1 + int32_2, num18);
                                e.Graphics.DrawString(s4, new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_1 + 10), (float)num18);
                                if (s3[0] == 'F')
                                    e.Graphics.DrawString(s3, new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_1 + num4 + 20), (float)num18);
                                if (s3[0] == 'T' || char.IsDigit(s3[0]))
                                    e.Graphics.DrawString(s3, new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_1 + 2 * num4 + 20), (float)num18);
                                num12 = num18 + hText + hText / 2;
                                e.Graphics.DrawLine(pen, int32_1, num12, int32_1 + int32_2, num12);
                                e.Graphics.DrawLine(pen, num15, y1_1, num15, num12);
                                e.Graphics.DrawLine(pen, num15 + num4, y1_1, num15 + num4, num12);
                                e.Graphics.DrawLine(pen, num15 + int32_2, y1_1, num15 + int32_2, num12);
                                e.Graphics.DrawLine(pen, num17, y1_2, num17, num12);
                                e.Graphics.DrawLine(pen, num17 + num4, y1_2, num17 + num4, num12);
                                break;
                            }
                        }
                        num13 = num1 + 1;
                    }
                }
            }
        }

        public static void Print_Area(
          PrintPageEventArgs e,
          double sPixInch,
          int dxSheet,
          int dySheet,
          int hText,
          int k,
          string[] sMess,
          int kPage,
          int[] k1,
          int[] k2,
          int ni,
          int iSquare,
          int iPrecision,
          int iToler,
          char[] sFormula)
        {
            string sTmp = "";
            char[] seps = new char[2] { ' ', ',' };
            int kPart = 50;
            double ar1 = 0.0;
            double ar2 = 0.0;
            double sar = 0.0;
            double toler = 0.0;
            int k3 = 0;
            int kArray1 = 999999;
            stringArray(sMess, ref kArray1);
            if (k > kArray1)
            {
                int num1 = (int)MessageBox.Show("Индекс массива Print_Report");
            }
            else
            {
                int kArray2 = 999999;
                intArray(k1, ref kArray2);
                intArray(k2, ref kArray2);
                if (kPage > kArray2)
                {
                    int num2 = (int)MessageBox.Show("Индекс массива Print_Report");
                }
                else
                {
                    int int32_1 = Convert.ToInt32(0.8 * (double)dxSheet / sPixInch);
                    int int32_2 = Convert.ToInt32(0.1 * (double)dxSheet / sPixInch);
                    int y1 = 30;
                    Convert.ToInt32((double)dySheet / sPixInch);
                    int num3 = int32_1 / 5;
                    int num4 = hText + hText / 2;
                    int num5;
                    int num6 = num5 = 0;
                    int num7 = 1;
                    int num8 = k2[kPage];
                    string[] sPart;
                    for (int i = num7; i <= num8; ++i)
                    {
                        ShareString(sMess[i], kPart, seps, out k3, out sPart);
                        switch (k3)
                        {
                            case 0:
                                return;
                            case 1:
                            case 2:
                                continue;
                            default:
                                double num9 = Convert.ToDouble(sPart[2]);
                                double num10 = Convert.ToDouble(sPart[3]);
                                ar1 += num9;
                                ar2 += num10;
                                continue;
                        }
                    }
                    SolidBrush solidBrush = new SolidBrush(Color.Black);
                    Pen pen = new Pen(Color.Black);
                    pen.Width = 1f;
                    int num11 = k1[ni];
                    int num12 = k2[ni];
                    if (ni == 1)
                        e.Graphics.DrawString("Таблица площадей", new Font("Bold", (float)(hText + hText / 2)), (Brush)solidBrush, (float)(int32_2 + int32_1 / 3), (float)y1);
                    if (ni > 1)
                        e.Graphics.DrawString("Таблица Площадей (продолжение)", new Font("Bold", (float)(hText + hText / 2)), (Brush)solidBrush, (float)(int32_2 + int32_1 / 3), (float)y1);
                    int num13 = y1 + 2 * num4;
                    int y1_1 = num13;
                    e.Graphics.DrawLine(pen, int32_2, num13, int32_2 + int32_1, num13);
                    int y2 = num13 + hText / 2;
                    e.Graphics.DrawString("Name of", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + num3 / 4), (float)y2);
                    if (iSquare == 1)
                        e.Graphics.DrawString("Площадь, м.кв", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + 2 * num3 + num3 / 4), (float)y2);
                    if (iSquare == 2)
                        e.Graphics.DrawString("Площадь, гектары", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + 2 * num3 + num3 / 4), (float)y2);
                    if (iSquare == 3)
                        e.Graphics.DrawString("Площадь, acre", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + 2 * num3 + num3 / 4), (float)y2);
                    if (iSquare == 4)
                        e.Graphics.DrawString("Area, дунам(донум)", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + 2 * num3 + num3 / 4), (float)y2);
                    int num14 = y2 + num4;
                    int num15 = num14;
                    e.Graphics.DrawLine(pen, int32_2 + num3, num14, int32_2 + int32_1, num14);
                    int y3 = num14 + hText / 2;
                    e.Graphics.DrawString("Участок земли", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + num3 / 4), (float)y3);
                    e.Graphics.DrawString("Вычислено", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + num3 + num3 / 4), (float)y3);
                    e.Graphics.DrawString("Законный", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + 2 * num3 + num3 / 4), (float)y3);
                    e.Graphics.DrawString("Разница", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + 3 * num3 + num3 / 4), (float)y3);
                    e.Graphics.DrawString("Допустимое отклонение", new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + 4 * num3 + num3 / 4), (float)y3);
                    int num16 = y3 + num4;
                    e.Graphics.DrawLine(pen, int32_2, num16, int32_2 + int32_1, num16);
                    int num17 = num16 + hText / 2;
                    for (int i = num11; i <= num12; ++i)
                    {
                        ShareString(sMess[i], kPart, seps, out k3, out sPart);
                        switch (k3)
                        {
                            case 0:
                                return;
                            case 1:
                            case 2:
                                continue;
                            default:
                                e.Graphics.DrawString(sPart[1], new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + num3 / 4), (float)num17);
                                e.Graphics.DrawString(sPart[2], new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + num3 + num3 / 4), (float)num17);
                                e.Graphics.DrawString(sPart[3], new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + 2 * num3 + num3 / 4), (float)num17);
                                double A = Convert.ToDouble(sPart[2]);
                                double ar3 = Convert.ToDouble(sPart[3]) - A;
                                Precision_Set(iPrecision, ar3, out sTmp, out sar);
                                e.Graphics.DrawString(sTmp, new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + 3 * num3 + num3 / 4), (float)num17);
                                if (iToler > 0)
                                {
                                    TolerFormula(ref sFormula, A, out toler);
                                    Precision_Set(iPrecision, toler, out sTmp, out sar);
                                    e.Graphics.DrawString(sTmp, new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + 4 * num3 + num3 / 4), (float)num17);
                                }
                                num17 += num4;
                                continue;
                        }
                    }
                    e.Graphics.DrawLine(pen, int32_2, num17, int32_2 + int32_1, num17);
                    int y2_1 = num17;
                    int x1 = int32_2;
                    int x2 = int32_2;
                    e.Graphics.DrawLine(pen, x1, y1_1, x2, y2_1);
                    e.Graphics.DrawLine(pen, x1 + num3, y1_1, x2 + num3, y2_1);
                    e.Graphics.DrawLine(pen, x1 + int32_1, y1_1, x2 + int32_1, y2_1);
                    int y1_2 = num15;
                    e.Graphics.DrawLine(pen, x1 + num3, y1_2, x2 + num3, y2_1);
                    e.Graphics.DrawLine(pen, x1 + 2 * num3, y1_2, x2 + 2 * num3, y2_1);
                    e.Graphics.DrawLine(pen, x1 + 3 * num3, y1_2, x2 + 3 * num3, y2_1);
                    e.Graphics.DrawLine(pen, x1 + 4 * num3, y1_2, x2 + 4 * num3, y2_1);
                    if (ni != kPage)
                        return;
                    Precision_Set(iPrecision, ar1, out sTmp, out sar);
                    int y4 = num17 + num4;
                    e.Graphics.DrawString(sTmp, new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + num3 + num3 / 4), (float)y4);
                    Precision_Set(iPrecision, ar2, out sTmp, out sar);
                    e.Graphics.DrawString(sTmp, new Font("Bold", (float)hText), (Brush)solidBrush, (float)(int32_2 + 2 * num3 + num3 / 4), (float)y4);
                }
            }
        }

        public static void Page_PrevPrint(
          PrintPageEventArgs e,
          double sPixInch,
          int iScaleMap,
          double[] xCorner,
          double[] yCorner,
          int ix,
          int iy,
          int ixPixel,
          int iyPixel,
          int nPage)
        {
            Graphics graphics = e.Graphics;
            double num1 = 0.0;
            double num2 = 0.01 * (double)iScaleMap;
            int kArray = 999999;
            doubleArray(xCorner, ref kArray);
            doubleArray(yCorner, ref kArray);
            if (kArray < 5)
            {
                int num3 = (int)MessageBox.Show("Индекс массива Page_PrevPrint");
            }
            else
            {
                if (iScaleMap == 100 || iScaleMap == 200 || iScaleMap == 500 || iScaleMap == 1000 || iScaleMap == 2000 || iScaleMap == 5000 || iScaleMap == 10000 || iScaleMap == 20000)
                    num1 = 10.0;
                if (iScaleMap == 125 || iScaleMap == 250 || iScaleMap == 625 || iScaleMap == 1250 || iScaleMap == 2500 || iScaleMap == 6250 || iScaleMap == 12500)
                    num1 = 8.0;
                string s1 = "Page  " + string.Format("{0}", (object)nPage);
                Font font1 = new Font("Arial", 12f, FontStyle.Regular);
                graphics.DrawString(s1, font1, Brushes.Black, 370f, 10f);
                graphics.DrawRectangle(new Pen(Color.Black, 2f), ix, iy, ixPixel, iyPixel);
                int num4 = 10;
                Font font2 = new Font("Arial", (float)num4, FontStyle.Regular);
                string s2 = string.Format("{0}", (object)yCorner[1]);
                int x1 = ix - 5 * num4 - num4 / 2;
                int y1 = iy + iyPixel - num4;
                graphics.DrawString(s2, font2, Brushes.Black, (float)x1, (float)y1);
                string s3 = string.Format("{0}", (object)yCorner[2]);
                int x2 = ix - 5 * num4 - num4 / 2;
                int y2 = iy - num4;
                graphics.DrawString(s3, font2, Brushes.Black, (float)x2, (float)y2);
                string s4 = string.Format("{0}", (object)yCorner[3]);
                int x3 = ix + ixPixel + num4 / 2;
                int y3 = iy - num4;
                graphics.DrawString(s4, font2, Brushes.Black, (float)x3, (float)y3);
                string s5 = string.Format("{0}", (object)yCorner[4]);
                int x4 = ix + ixPixel + num4 / 2;
                int y4 = iy + iyPixel - num4;
                graphics.DrawString(s5, font2, Brushes.Black, (float)x4, (float)y4);
                SolidBrush iColor = new SolidBrush(Color.Black);
                string tText1 = string.Format("{0}", (object)xCorner[1]);
                int x5 = ix + num4 / 4;
                int y5 = iy + iyPixel + 6 * num4;
                RotTextPrevPrint(e, tText1, x5, y5, num4, 270, iColor, 0);
                string tText2 = string.Format("{0}", (object)xCorner[2]);
                int x6 = ix + num4 / 4;
                int y6 = iy;
                RotTextPrevPrint(e, tText2, x6, y6, num4, 270, iColor, 0);
                string tText3 = string.Format("{0}", (object)xCorner[3]);
                int x7 = ix + ixPixel + num4 / 4;
                int y7 = iy;
                RotTextPrevPrint(e, tText3, x7, y7, num4, 270, iColor, 0);
                string tText4 = string.Format("{0}", (object)xCorner[4]);
                int x8 = ix + ixPixel + num4 / 4;
                int y8 = iy + iyPixel + 6 * num4;
                RotTextPrevPrint(e, tText4, x8, y8, num4, 270, iColor, 0);
                double num5 = num1 * num2;
                double num6 = -10000000.0;
                do
                {
                    num6 += num5;
                    if (num6 < yCorner[2])
                    {
                        if (num6 > yCorner[1])
                        {
                            string s6 = string.Format("{0}", (object)num6);
                            int int32 = Convert.ToInt32(10.0 * (num6 - yCorner[1]) / num2 / sPixInch);
                            int x9 = ix - 5 * num4 - num4 / 2;
                            int y9 = iy + iyPixel - int32 - num4;
                            graphics.DrawString(s6, font2, Brushes.Black, (float)x9, (float)y9);
                            int y1_1 = iy + iyPixel - int32;
                            int x2_1 = ix + 10;
                            int y2_1 = y1_1;
                            graphics.DrawLine(new Pen(Color.Black, 3f), ix, y1_1, x2_1, y2_1);
                            int x10 = ix + ixPixel + num4 / 2;
                            int y10 = iy + iyPixel - int32 - num4;
                            graphics.DrawString(s6, font2, Brushes.Black, (float)x10, (float)y10);
                            int x1_1 = ix + ixPixel;
                            int y1_2 = iy + iyPixel - int32;
                            int x2_2 = ix + ixPixel - 10;
                            int y2_2 = y1_2;
                            graphics.DrawLine(new Pen(Color.Black, 3f), x1_1, y1_2, x2_2, y2_2);
                        }
                    }
                    else
                        break;
                }
                while (num6 < yCorner[2]);
                double num7 = num1 * num2;
                double num8 = -10000000.0;
                do
                {
                    num8 += num7;
                    if (num8 < xCorner[4])
                    {
                        if (num8 > xCorner[1])
                        {
                            string tText5 = string.Format("{0}", (object)num8);
                            int int32 = Convert.ToInt32(10.0 * (num8 - xCorner[1]) / num2 / sPixInch);
                            int x11 = ix + int32 + num4 / 4;
                            int y11 = iy + iyPixel + 6 * num4;
                            RotTextPrevPrint(e, tText5, x11, y11, num4, 270, iColor, 0);
                            int x1_2 = ix + int32;
                            int y1_3 = iy + iyPixel;
                            int x2_3 = ix + int32;
                            int y2_3 = iy + iyPixel - 10;
                            graphics.DrawLine(new Pen(Color.Black, 3f), x1_2, y1_3, x2_3, y2_3);
                            int x12 = ix + int32 + num4 / 4;
                            int y12 = iy;
                            RotTextPrevPrint(e, tText5, x12, y12, num4, 270, iColor, 0);
                            int x1_3 = ix + int32;
                            int y1_4 = iy;
                            int x2_4 = ix + int32;
                            int y2_4 = iy + 10;
                            graphics.DrawLine(new Pen(Color.Black, 3f), x1_3, y1_4, x2_4, y2_4);
                        }
                    }
                    else
                        break;
                }
                while (num8 < xCorner[4]);
                string s7 = "Масштаб 1 : " + string.Format("{0}", (object)iScaleMap);
                Font font3 = new Font("Arial", 12f, FontStyle.Regular);
                graphics.DrawString(s7, font3, Brushes.Black, 350f, (float)(iy + iyPixel + 6 * num4));
            }
        }

        public static void Labels_PrevPrint(
          PrintPageEventArgs e,
          double sPixInch,
          int iScaleMap,
          double[] xCorner,
          double[] yCorner,
          int kPol,
          string[] namePol,
          double[] xLab,
          double[] yLab,
          int[] iHorVer,
          int iParam,
          int iColorPrint,
          int ix,
          int iy)
        {
            int k = -1;
            double[] x1 = new double[10];
            double[] y = new double[10];
            int num1 = 12;
            int kArray = 999999;
            stringArray(namePol, ref kArray);
            intArray(iHorVer, ref kArray);
            doubleArray(xLab, ref kArray);
            doubleArray(yLab, ref kArray);
            int num2 = kArray - 2;
            if (kPol > num2)
            {
                int num3 = (int)MessageBox.Show("Индекс массива Labels_PrevPrint");
            }
            else
            {
                SolidBrush iColor1 = new SolidBrush(Color.Black);
                SolidBrush iColor2 = new SolidBrush(Color.Blue);
                double num4 = 0.01 * (double)iScaleMap;
                for (int i = 1; i <= 5; ++i)
                {
                    ++k;
                    x1[k] = xCorner[i];
                    y[k] = yCorner[i];
                }
                for (int i = 1; i <= kPol; ++i)
                {
                    if (in_out(k, ref x1, ref y, xLab[i], yLab[i]) > 0)
                    {
                        double num5 = xLab[i] - xCorner[2];
                        double num6 = yLab[i] - yCorner[2];
                        int int32_1 = Convert.ToInt32(10.0 * num5 / num4 / sPixInch);
                        int int32_2 = Convert.ToInt32(10.0 * num6 / num4 / sPixInch);
                        int x2 = ix + int32_1;
                        int num7 = iy - int32_2;
                        if (iHorVer[i] == 0)
                        {
                            if (iColorPrint == 0)
                                e.Graphics.DrawString(namePol[i], new Font("Bold", (float)num1), (Brush)iColor1, (float)(x2 + num1 / 2), (float)(num7 - num1));
                            if (iColorPrint > 0)
                                e.Graphics.DrawString(namePol[i], new Font("Bold", (float)num1), (Brush)iColor2, (float)(x2 + num1 / 2), (float)(num7 - num1));
                        }
                        if (iHorVer[i] > 0)
                        {
                            if (iColorPrint == 0)
                                RotTextPrevPrint(e, namePol[i], x2, num7 - num1 / 2, num1, 270, iColor1, 0);
                            if (iColorPrint > 0)
                                RotTextPrevPrint(e, namePol[i], x2, num7 - num1 / 2, num1, 270, iColor2, 0);
                        }
                        if (iParam != 3)
                        {
                            if (iColorPrint == 0)
                                e.Graphics.FillRectangle((Brush)iColor1, x2 - num1 / 4, num7 - num1 / 4, num1 / 2, num1 / 2);
                            if (iColorPrint > 0)
                                e.Graphics.FillRectangle((Brush)iColor2, x2 - num1 / 4, num7 - num1 / 4, num1 / 2, num1 / 2);
                        }
                        if (iParam == 3)
                        {
                            Point[] points1 = new Point[2];
                            points1[0].X = x2 - 4;
                            points1[0].Y = num7 - 4;
                            points1[1].X = x2 + 4;
                            points1[1].Y = num7 + 4;
                            if (iColorPrint == 0)
                                e.Graphics.DrawLines(new Pen(Color.Black, 2f), points1);
                            if (iColorPrint > 0)
                                e.Graphics.DrawLines(new Pen(Color.DarkGreen, 2f), points1);
                            Point[] points2 = new Point[2];
                            points2[0].X = x2 + 4;
                            points2[0].Y = num7 - 4;
                            points2[1].X = x2 - 4;
                            points2[1].Y = num7 + 4;
                            if (iColorPrint == 0)
                                e.Graphics.DrawLines(new Pen(Color.Black, 2f), points2);
                            if (iColorPrint > 0)
                                e.Graphics.DrawLines(new Pen(Color.DarkGreen, 2f), points2);
                        }
                    }
                }
            }
        }

        public static void Nodes_PrevPrint(
          PrintPageEventArgs e,
          double sPixInch,
          int iScaleMap,
          double[] xCorner,
          double[] yCorner,
          int kPol,
          string[] namePol,
          double[] xLab,
          double[] yLab,
          int[] iHorVer,
          int iParam,
          int iColorPrint,
          int ix,
          int iy)
        {
            int k = -1;
            double[] x = new double[10];
            double[] y = new double[10];
            int emSize = 10;
            int kArray1 = 999999;
            stringArray(namePol, ref kArray1);
            doubleArray(xLab, ref kArray1);
            doubleArray(yLab, ref kArray1);
            intArray(iHorVer, ref kArray1);
            int num1 = kArray1 - 2;
            if (kPol > num1)
            {
                int num2 = (int)MessageBox.Show("Индекс массива Nodes_PrevPrint");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(xCorner, ref kArray2);
                doubleArray(yCorner, ref kArray2);
                if (kArray2 - 2 < 5)
                {
                    int num3 = (int)MessageBox.Show("Индекс массива Nodes_PrevPrint");
                }
                else
                {
                    SolidBrush solidBrush1 = new SolidBrush(Color.Black);
                    SolidBrush solidBrush2 = new SolidBrush(Color.Blue);
                    double num4 = 0.01 * (double)iScaleMap;
                    for (int i = 1; i <= 5; ++i)
                    {
                        ++k;
                        x[k] = xCorner[i];
                        y[k] = yCorner[i];
                    }
                    for (int i = 1; i <= kPol; ++i)
                    {
                        if (in_out(k, ref x, ref y, xLab[i], yLab[i]) > 0)
                        {
                            double num5 = xLab[i] - xCorner[2];
                            double num6 = yLab[i] - yCorner[2];
                            int int32_1 = Convert.ToInt32(10.0 * num5 / num4 / sPixInch);
                            int int32_2 = Convert.ToInt32(10.0 * num6 / num4 / sPixInch);
                            int num7 = ix + int32_1;
                            int num8 = iy - int32_2;
                            if (iColorPrint == 0)
                                e.Graphics.DrawString(namePol[i], new Font("Bold", (float)emSize), (Brush)solidBrush1, (float)(num7 + emSize / 2), (float)(num8 - emSize));
                            if (iColorPrint > 0)
                                e.Graphics.DrawString(namePol[i], new Font("Bold", (float)emSize), (Brush)solidBrush2, (float)(num7 + emSize / 2), (float)(num8 - emSize));
                            if (iParam != 3)
                            {
                                if (iColorPrint == 0)
                                    e.Graphics.FillRectangle((Brush)solidBrush1, num7 - emSize / 4, num8 - emSize / 4, emSize / 2, emSize / 2);
                                if (iColorPrint > 0)
                                    e.Graphics.FillRectangle((Brush)solidBrush2, num7 - emSize / 4, num8 - emSize / 4, emSize / 2, emSize / 2);
                            }
                            if (iParam == 3)
                            {
                                Point[] points1 = new Point[2];
                                points1[0].X = num7 - 4;
                                points1[0].Y = num8 - 4;
                                points1[1].X = num7 + 4;
                                points1[1].Y = num8 + 4;
                                if (iColorPrint == 0)
                                    e.Graphics.DrawLines(new Pen(Color.Black, 2f), points1);
                                if (iColorPrint > 0)
                                    e.Graphics.DrawLines(new Pen(Color.DarkGreen, 2f), points1);
                                Point[] points2 = new Point[2];
                                points2[0].X = num7 + 4;
                                points2[0].Y = num8 - 4;
                                points2[1].X = num7 - 4;
                                points2[1].Y = num8 + 4;
                                if (iColorPrint == 0)
                                    e.Graphics.DrawLines(new Pen(Color.Black, 2f), points2);
                                if (iColorPrint > 0)
                                    e.Graphics.DrawLines(new Pen(Color.DarkGreen, 2f), points2);
                            }
                        }
                    }
                }
            }
        }

        public static void Print_AddInscr(
          PrintPageEventArgs e,
          int kAddInscr,
          string[] txtInscr,
          double[] xInscr,
          double[] yInscr,
          int[] nHorVer,
          int[] nInsCol,
          SolidBrush[] brBrush,
          double sPixInch,
          int iScaleMap,
          double[] xCorner,
          double[] yCorner,
          int xPrintBeg,
          int yPrintBeg)
        {
            Graphics graphics = e.Graphics;
            double num1 = 0.01 * (double)iScaleMap;
            int k = -1;
            double[] x = new double[10];
            double[] y = new double[10];
            int kArray1 = 999999;
            stringArray(txtInscr, ref kArray1);
            doubleArray(xInscr, ref kArray1);
            doubleArray(yInscr, ref kArray1);
            intArray(nHorVer, ref kArray1);
            intArray(nInsCol, ref kArray1);
            int num2 = kArray1 - 2;
            if (kAddInscr > num2)
            {
                int num3 = (int)MessageBox.Show("Индекс массива Print_AddInscr");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(xCorner, ref kArray2);
                doubleArray(yCorner, ref kArray2);
                if (kArray2 < 5)
                {
                    int num4 = (int)MessageBox.Show("Индекс массива Print_AddInscr");
                }
                else
                {
                    for (int i = 1; i <= 5; ++i)
                    {
                        ++k;
                        x[k] = xCorner[i];
                        y[k] = yCorner[i];
                    }
                    int num5 = 10;
                    for (int i1 = 1; i1 <= kAddInscr; ++i1)
                    {
                        if (in_out(k, ref x, ref y, xInscr[i1], yInscr[i1]) != 0)
                        {
                            int i2 = nInsCol[i1];
                            SolidBrush dBrush = brBrush[i2];
                            string str = txtInscr[i1];
                            int num6 = 6 * str.Length / 2;
                            int num7 = nHorVer[i1];
                            double num8 = xInscr[i1] - xCorner[2];
                            double num9 = yInscr[i1] - yCorner[2];
                            int int32_1 = Convert.ToInt32(10.0 * num8 / num1 / sPixInch);
                            int int32_2 = Convert.ToInt32(10.0 * num9 / num1 / sPixInch);
                            int num10 = xPrintBeg + int32_1;
                            int num11 = yPrintBeg - int32_2;
                            if (num7 == 0)
                                graphics.DrawString(str, new Font("Bold", (float)num5), (Brush)dBrush, (float)(num10 - num6), (float)(num11 - num5));
                            if (num7 > 0)
                                Print_Vertical(e, str, num10 - num5 / 2, num11 - num6, num5, dBrush);
                        }
                    }
                }
            }
        }

        public static void Print_PartLines(
          PrintPageEventArgs e,
          double sPixInch,
          int iScaleMap,
          double[] xCorner,
          double[] yCorner,
          int kp,
          double[] xp,
          double[] yp,
          int[] np,
          int kl,
          double[] xa,
          double[] ya,
          double[] xb,
          double[] yb,
          int[] nw,
          int[] nc,
          double[] xc,
          double[] yc,
          double[] xd,
          double[] yd,
          double[] xt,
          double[] yt,
          int[] nDop,
          int[] nDop1,
          int[] nDop2,
          SolidBrush[] brColor,
          Pen[] pnColor,
          int ix,
          int iy,
          int iColorPrint)
        {
            double[] x1 = new double[10];
            double[] y1 = new double[10];
            int num1;
            int num2 = num1 = 0;
            if (kp == 0 && kl == 0)
                return;
            double num3 = 0.01 * (double)iScaleMap;
            int i1 = -1;
            for (int i2 = 1; i2 <= 5; ++i2)
            {
                ++i1;
                x1[i1] = xCorner[i2];
                y1[i1] = yCorner[i2];
            }
            if (kp > 0)
            {
                for (int i3 = 1; i3 <= kp; ++i3)
                {
                    if (in_out(i1, ref x1, ref y1, xp[i3], yp[i3]) != 0)
                    {
                        double num4 = xp[i3] - xCorner[2];
                        double num5 = yp[i3] - yCorner[2];
                        int int32_1 = Convert.ToInt32(10.0 * num4 / num3 / sPixInch);
                        int int32_2 = Convert.ToInt32(10.0 * num5 / num3 / sPixInch);
                        int num6 = ix + int32_1;
                        int num7 = iy - int32_2;
                        int i4 = np[i3];
                        if (iColorPrint == 0)
                            i4 = 1;
                        SolidBrush solidBrush = brColor[i4];
                        e.Graphics.FillRectangle((Brush)solidBrush, num6 - 1, num7 - 1, 2, 2);
                    }
                }
            }
            if (kl == 0)
                return;
            for (int i5 = 1; i5 <= kl; ++i5)
            {
                int num8 = in_out(i1, ref x1, ref y1, xa[i5], ya[i5]);
                int num9 = in_out(i1, ref x1, ref y1, xb[i5], yb[i5]);
                if (num8 != 0 || num9 != 0)
                {
                    int i6 = 0;
                    xt[i6] = xa[i5];
                    yt[i6] = ya[i5];
                    int k = i6 + 1;
                    xt[k] = xb[i5];
                    yt[k] = yb[i5];
                    double rad = 0.0;
                    double xrd = 0.0;
                    double yrd = 0.0;
                    int kl1 = 0;
                    ClipLine(i1, x1, y1, k, xt, yt, rad, xrd, yrd, out kl1, nDop1, nDop2, xc, yc, nDop, xd, yd);
                    if (kl1 >= 0)
                    {
                        for (int i7 = 0; i7 <= kl1; ++i7)
                        {
                            int num10 = nDop1[i7];
                            int num11 = nDop2[i7];
                            for (int i8 = num10 + 1; i8 <= num11; ++i8)
                            {
                                double num12 = xc[i8 - 1] - xCorner[2];
                                double num13 = yc[i8 - 1] - yCorner[2];
                                int int32_3 = Convert.ToInt32(10.0 * num12 / num3 / sPixInch);
                                int int32_4 = Convert.ToInt32(10.0 * num13 / num3 / sPixInch);
                                int x2 = ix + int32_3;
                                int y2 = iy - int32_4;
                                double num14 = xc[i8] - xCorner[2];
                                double num15 = yc[i8] - yCorner[2];
                                int int32_5 = Convert.ToInt32(10.0 * num14 / num3 / sPixInch);
                                int int32_6 = Convert.ToInt32(10.0 * num15 / num3 / sPixInch);
                                int x3 = ix + int32_5;
                                int y3 = iy - int32_6;
                                Point pt1 = new Point(x2, y2);
                                Point pt2 = new Point(x3, y3);
                                int num16 = nw[i5];
                                int i9 = nc[i5];
                                if (iColorPrint == 0)
                                    i9 = 1;
                                Pen pen = pnColor[i9];
                                pen.Width = (float)num16;
                                e.Graphics.DrawLine(pen, pt1, pt2);
                            }
                        }
                    }
                }
            }
        }

        public static void Print_ItemLine(
          PrintPageEventArgs e,
          string fitemLine,
          double sPixInch,
          int iScaleMap,
          double[] xCorner,
          double[] yCorner,
          int kItem,
          int[] numSign,
          int[] numItem,
          double[] xItem,
          double[] yItem,
          double[] azim,
          int[] itemLoc,
          int[] nBaseSymb,
          string[] sInscr,
          double[] hInscr,
          int[] iColInscr,
          int[] ixSqu,
          int[] iySqu,
          int[] nColorItm,
          int[] nDop1,
          int[] nDop2,
          SolidBrush[] brColor,
          Pen[] pnColor,
          int iColorPrint,
          int xPageBeg,
          int yPageBeg)
        {
            double num1 = 3.1415926;
            string sTxt = "";
            int iLong = 0;
            double[] x1 = new double[10];
            double[] y1 = new double[10];
            int num2;
            int mClr = num2 = 0;
            int iHei = num2;
            int iWid = num2;
            int kPix = num2;
            int kArray = 999999;
            doubleArray(xItem, ref kArray);
            doubleArray(yItem, ref kArray);
            doubleArray(azim, ref kArray);
            if (kItem > kArray)
            {
                int num3 = (int)MessageBox.Show("Индекс массива Print_ItemLine");
            }
            else
            {
                SolidBrush iColor1 = new SolidBrush(Color.Black);
                double num4 = 0.01 * (double)iScaleMap;
                int k = -1;
                for (int i = 1; i <= 5; ++i)
                {
                    ++k;
                    x1[k] = xCorner[i];
                    y1[k] = yCorner[i];
                }
                for (int i1 = 1; i1 <= kItem; ++i1)
                {
                    if (numItem[i1] != 0)
                    {
                        double num5 = azim[i1];
                        double num6 = num5 + 0.5 * num1;
                        if (num6 > 2.0 * num1)
                            num6 -= 2.0 * num1;
                        int i2 = numSign[i1];
                        int nSelect = numItem[i1];
                        int num7 = itemLoc[i2];
                        int num8 = nBaseSymb[i2];
                        if (in_out(k, ref x1, ref y1, xItem[i1], yItem[i1]) != 0)
                        {
                            double num9 = xItem[i1] - xCorner[2];
                            double num10 = yItem[i1] - yCorner[2];
                            int int32_1 = Convert.ToInt32(10.0 * num9 / num4 / sPixInch);
                            int int32_2 = Convert.ToInt32(10.0 * num10 / num4 / sPixInch);
                            int x2 = xPageBeg + int32_1;
                            int y2 = yPageBeg - int32_2;
                            if (nSelect > 0)
                                SelItemLine(fitemLine, nSelect, out iLong, out iWid, out iHei, out kPix, ixSqu, iySqu, nColorItm, out sTxt, out mClr);
                            if (iLong > 0)
                            {
                                int length = sTxt.Length;
                                sTxt = sInscr[i2];
                                double num11 = hInscr[i2];
                                mClr = iColInscr[i2];
                                SolidBrush iColor2 = brColor[mClr];
                                int int32_3 = Convert.ToInt32(num11 / sPixInch);
                                int int32_4 = Convert.ToInt32(0.8 * (double)int32_3);
                                int angle = RadGrad(azim[i1]);
                                if (num7 == 2)
                                {
                                    int int32_5 = Convert.ToInt32((double)x2 - (double)(length * int32_4) * Math.Cos(num5));
                                    int int32_6 = Convert.ToInt32((double)y2 - (double)(length * int32_4) * Math.Sin(num5));
                                    int int32_7 = Convert.ToInt32((double)x2 + (double)(length * int32_4) * Math.Cos(num5));
                                    int int32_8 = Convert.ToInt32((double)y2 + (double)(length * int32_4) * Math.Sin(num5));
                                    e.Graphics.DrawLine(new Pen(Color.White)
                                    {
                                        Width = 5f
                                    }, int32_5, int32_6, int32_7, int32_8);
                                    if (iColorPrint == 0)
                                        RotTextPrevPrint(e, sTxt, x2, y2, int32_3, angle, iColor1, 1);
                                    if (iColorPrint > 0)
                                        RotTextPrevPrint(e, sTxt, x2, y2, int32_3, angle, iColor2, 1);
                                }
                                if (num7 == 1)
                                {
                                    int y3;
                                    int x3 = y3 = 0;
                                    if (num8 < 8)
                                    {
                                        x3 = x2 - Convert.ToInt32((double)int32_4 * Math.Cos(num6));
                                        y3 = y2 - Convert.ToInt32((double)int32_4 * Math.Sin(num6));
                                    }
                                    if (num8 == 8)
                                    {
                                        x3 = x2 - Convert.ToInt32((double)int32_3 * Math.Cos(num6));
                                        y3 = y2 - Convert.ToInt32((double)int32_3 * Math.Sin(num6));
                                    }
                                    if (iColorPrint == 0)
                                        RotTextPrevPrint(e, sTxt, x3, y3, int32_3, angle, iColor1, 1);
                                    if (iColorPrint > 0)
                                        RotTextPrevPrint(e, sTxt, x3, y3, int32_3, angle, iColor2, 1);
                                }
                                if (num7 == 3)
                                {
                                    int y4;
                                    int x4 = y4 = 0;
                                    if (num8 < 8)
                                    {
                                        x4 = x2 + Convert.ToInt32((double)int32_4 * Math.Cos(num6));
                                        y4 = y2 + Convert.ToInt32((double)int32_4 * Math.Sin(num6));
                                    }
                                    if (num8 == 8)
                                    {
                                        x4 = x2 + Convert.ToInt32((double)int32_3 * Math.Cos(num6));
                                        y4 = y2 + Convert.ToInt32((double)int32_3 * Math.Sin(num6));
                                    }
                                    if (iColorPrint == 0)
                                        RotTextPrevPrint(e, sTxt, x4, y4, int32_3, angle, iColor1, 1);
                                    if (iColorPrint > 0)
                                        RotTextPrevPrint(e, sTxt, x4, y4, int32_3, angle, iColor2, 1);
                                }
                            }
                            if (iLong == 0)
                            {
                                int num12 = iWid / 2;
                                int num13 = iHei / 2;
                                int num14 = x2 - Convert.ToInt32((double)num13 * Math.Cos(num6));
                                int num15 = y2 - Convert.ToInt32((double)num13 * Math.Sin(num6));
                                int ixh = num14 - Convert.ToInt32((double)num12 * Math.Cos(num5));
                                int iyh = num15 - Convert.ToInt32((double)num12 * Math.Sin(num5));
                                for (int i3 = 1; i3 <= kPix; ++i3)
                                {
                                    nDop1[i3] = Convert.ToInt32((double)ixSqu[i3] * Math.Cos(num5)) - Convert.ToInt32((double)iySqu[i3] * Math.Sin(num5));
                                    nDop2[i3] = Convert.ToInt32((double)ixSqu[i3] * Math.Sin(num5)) + Convert.ToInt32((double)iySqu[i3] * Math.Cos(num5));
                                }
                                Print_SignDraw(e, ixh, iyh, kPix, nDop1, nDop2, nColorItm, brColor, iColorPrint);
                            }
                        }
                    }
                }
            }
        }

        public static void BoundPage(
          int mapScale,
          int kPnt,
          double[] xPnt,
          double[] yPnt,
          int xPage,
          int yPage,
          out int kPage,
          double[] x1,
          double[] y1,
          double[] x2,
          double[] y2,
          double[] x3,
          double[] y3,
          double[] x4,
          double[] y4)
        {
            kPage = 0;
            int num1 = xPage;
            int num2 = yPage;
            int kArray1 = 999999;
            doubleArray(xPnt, ref kArray1);
            doubleArray(yPnt, ref kArray1);
            if (kPnt > kArray1)
            {
                int num3 = (int)MessageBox.Show("Индекс массива BoundPage");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(x1, ref kArray2);
                doubleArray(y1, ref kArray2);
                doubleArray(x2, ref kArray2);
                doubleArray(y2, ref kArray2);
                doubleArray(x3, ref kArray2);
                doubleArray(y3, ref kArray2);
                doubleArray(x4, ref kArray2);
                doubleArray(y4, ref kArray2);
                double num4 = 0.01 * (double)mapScale;
                double num5 = 9999999.9;
                double num6 = 9999999.9;
                double num7 = -9999999.9;
                double num8 = -9999999.9;
                for (int i = 0; i <= kPnt; ++i)
                {
                    if (xPnt[i] < num5)
                        num5 = xPnt[i];
                    if (xPnt[i] > num7)
                        num7 = xPnt[i];
                    if (yPnt[i] < num6)
                        num6 = yPnt[i];
                    if (yPnt[i] > num8)
                        num8 = yPnt[i];
                }
                double num9 = num4 * (double)num1;
                double num10 = 10.0 * (double)Convert.ToInt32(0.1 * num5 + 1E-06) - 10.0;
                int num11 = 0;
                double num12 = num10;
                do
                {
                    num12 += num9;
                    ++num11;
                }
                while (num12 < num7);
                do
                {
                    num12 -= 10.0;
                }
                while (num12 > num7);
                double num13 = num12 + 20.0;
                double num14 = num4 * (double)num2;
                double num15 = 10.0 * (double)Convert.ToInt32(0.1 * num6 + 1E-06) - 10.0;
                int num16 = 0;
                double num17 = num15;
                do
                {
                    num17 += num14;
                    ++num16;
                }
                while (num17 < num8);
                do
                {
                    num17 -= 10.0;
                }
                while (num17 > num8);
                double num18 = num17 + 20.0;
                int i1 = 0;
                double num19 = num15 - num14;
                for (int i2 = 1; i2 <= num16; ++i2)
                {
                    num19 += num14;
                    double num20 = num10 - num9;
                    for (int i3 = 1; i3 <= num11; ++i3)
                    {
                        num20 += num9;
                        ++i1;
                        if (i1 > kArray2)
                        {
                            int num21 = (int)MessageBox.Show("Индекс массива BoundPage");
                            return;
                        }
                        x1[i1] = num20;
                        y1[i1] = num19;
                        x2[i1] = num20;
                        y2[i1] = num19 + num14;
                        x3[i1] = num20 + num9;
                        y3[i1] = num19 + num14;
                        x4[i1] = num20 + num9;
                        y4[i1] = num19;
                    }
                }
                int i4 = 0;
                for (int i5 = 1; i5 <= i1; ++i5)
                {
                    int num22 = 0;
                    for (int i6 = 0; i6 <= kPnt; ++i6)
                    {
                        if (xPnt[i6] >= x1[i5] && xPnt[i6] <= x4[i5] && yPnt[i6] >= y1[i5] && yPnt[i6] <= y2[i5])
                        {
                            ++num22;
                            break;
                        }
                    }
                    if (num22 > 0)
                    {
                        ++i4;
                        x1[i4] = x1[i5];
                        y1[i4] = y1[i5];
                        x2[i4] = x2[i5];
                        y2[i4] = y2[i5];
                        x3[i4] = x3[i5];
                        y3[i4] = y3[i5];
                        x4[i4] = x4[i5];
                        y4[i4] = y4[i5];
                    }
                }
                int num23 = i4;
                kPage = num23;
            }
        }

        public static void NewLine(
          ref int k,
          double[] x,
          double[] y,
          int[] nd,
          double[] xd,
          double[] yd,
          double[] xp,
          double[] yp,
          out int kt,
          double[] xt,
          double[] yt)
        {
            int i1 = 0;
            double num1;
            double num2 = num1 = 0.0;
            double num3 = num1;
            double num4 = num1;
            kt = 0;
            int kArray1 = 999999;
            doubleArray(x, ref kArray1);
            doubleArray(y, ref kArray1);
            intArray(nd, ref kArray1);
            doubleArray(xd, ref kArray1);
            doubleArray(yd, ref kArray1);
            doubleArray(xp, ref kArray1);
            doubleArray(yp, ref kArray1);
            int num5 = kArray1 - 2;
            if (k > num5)
            {
                int num6 = (int)MessageBox.Show("Индекс массива NewLine");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(xt, ref kArray2);
                doubleArray(yt, ref kArray2);
                int num7 = kArray2 - 3;
                int num8 = 0;
                double num9 = x[k] - x[0];
                double num10 = y[k] - y[0];
                if (Math.Sqrt(num9 * num9 + num10 * num10) < 0.1)
                    num8 = 1;
                for (int i2 = 1; i2 <= 100; ++i2)
                {
                    int i3 = 0;
                    i1 = -1;
                    for (int i4 = 1; i4 <= k; ++i4)
                    {
                        if (num8 == 1)
                        {
                            if (i4 < k)
                            {
                                double num11 = x[i4 + 1] - x[i4 - 1];
                                double num12 = y[i4 + 1] - y[i4 - 1];
                                num4 = Math.Sqrt(num11 * num11 + num12 * num12);
                                double num13 = x[i4] - x[i4 - 1];
                                double num14 = y[i4] - y[i4 - 1];
                                num3 = Math.Sqrt(num13 * num13 + num14 * num14);
                                double num15 = x[i4 + 1] - x[i4];
                                double num16 = y[i4 + 1] - y[i4];
                                num2 = Math.Sqrt(num15 * num15 + num16 * num16);
                            }
                            if (i4 == k)
                            {
                                double num17 = x[i4 - 1] - x[1];
                                double num18 = y[i4 - 1] - y[1];
                                num4 = Math.Sqrt(num17 * num17 + num18 * num18);
                                double num19 = x[i4] - x[i4 - 1];
                                double num20 = y[i4] - y[i4 - 1];
                                num3 = Math.Sqrt(num19 * num19 + num20 * num20);
                                double num21 = x[1] - x[i4];
                                double num22 = y[1] - y[i4];
                                num2 = Math.Sqrt(num21 * num21 + num22 * num22);
                            }
                        }
                        if (num8 == 0 && i4 < k)
                        {
                            double num23 = x[i4 + 1] - x[i4 - 1];
                            double num24 = y[i4 + 1] - y[i4 - 1];
                            num4 = Math.Sqrt(num23 * num23 + num24 * num24);
                            double num25 = x[i4] - x[i4 - 1];
                            double num26 = y[i4] - y[i4 - 1];
                            num3 = Math.Sqrt(num25 * num25 + num26 * num26);
                            double num27 = x[i4 + 1] - x[i4];
                            double num28 = y[i4 + 1] - y[i4];
                            num2 = Math.Sqrt(num27 * num27 + num28 * num28);
                        }
                        double num29 = (num4 * num4 + num3 * num3 - num2 * num2) / (2.0 * num4);
                        double num30 = Math.Sqrt(num3 * num3 - num29 * num29);
                        if (num4 < 0.5 * num30)
                        {
                            ++i3;
                            nd[i3] = i4;
                            xd[i3] = 0.5 * (x[i4 - 1] + x[i4 + 1]);
                            yd[i3] = 0.5 * (y[i4 - 1] + y[i4 + 1]);
                            xp[i3] = x[i4];
                            yp[i3] = y[i4];
                        }
                    }
                    if (i3 == 0)
                    {
                        kt = k;
                        for (int i5 = 0; i5 <= k; ++i5)
                        {
                            xt[i5] = x[i5];
                            yt[i5] = y[i5];
                        }
                        return;
                    }
                    for (int i6 = 0; i6 <= k; ++i6)
                    {
                        int i7 = 0;
                        for (int i8 = 1; i8 <= i3; ++i8)
                        {
                            if (nd[i8] == i6)
                            {
                                i7 = i8;
                                break;
                            }
                        }
                        if (i7 == 0)
                        {
                            ++i1;
                            if (i1 > num7)
                            {
                                int num31 = (int)MessageBox.Show("Индекс массива NewLine");
                                kt = 0;
                                return;
                            }
                            xt[i1] = x[i6];
                            yt[i1] = y[i6];
                        }
                        if (i7 > 0)
                        {
                            ++i1;
                            if (i1 > num7)
                            {
                                int num32 = (int)MessageBox.Show("Индекс массива NewLine");
                                kt = 0;
                                return;
                            }
                            xt[i1] = 0.5 * (xd[i7] + xp[i7]);
                            yt[i1] = 0.5 * (yd[i7] + yp[i7]);
                        }
                    }
                    if (num8 > 0)
                    {
                        double num33 = xt[i1] - xt[0];
                        double num34 = yt[i1] - yt[0];
                        if (Math.Sqrt(num33 * num33 + num34 * num34) < 0.003)
                        {
                            ++i1;
                            if (i1 > num7)
                            {
                                int num35 = (int)MessageBox.Show("Индекс массива NewLine");
                                kt = 0;
                                return;
                            }
                            xt[i1] = x[0];
                            yt[i1] = y[0];
                        }
                    }
                    k = i1;
                    for (int i9 = 0; i9 <= i1; ++i9)
                    {
                        x[i9] = xt[i9];
                        y[i9] = yt[i9];
                    }
                }
                kt = i1;
            }
        }

        public static void Smooth1(
          double hSect,
          int k,
          double[] x,
          double[] y,
          int ks,
          double[] xs,
          double[] ys)
        {
            double num1 = 3.1415926;
            int num2;
            int num3 = num2 = 0;
            int num4 = num2;
            int num5 = num2;
            int kArray1 = 999999;
            doubleArray(x, ref kArray1);
            doubleArray(y, ref kArray1);
            if (k > kArray1)
            {
                int num6 = (int)MessageBox.Show("Индекс массива Smooth1");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(xs, ref kArray2);
                doubleArray(ys, ref kArray2);
                if (ks > kArray2)
                {
                    int num7 = (int)MessageBox.Show("Индекс массива Smooth1");
                }
                else
                {
                    if (hSect > 0.5)
                        return;
                    if (hSect == 0.5)
                        num3 = 2;
                    if (hSect == 0.2)
                        num3 = 5;
                    if (hSect == 0.1)
                        num3 = 8;
                    for (int i1 = 1; i1 <= k; ++i1)
                    {
                        double num8 = 9999999.9;
                        for (int i2 = 0; i2 <= ks; ++i2)
                        {
                            double num9 = xs[i2] - x[i1 - 1];
                            double num10 = ys[i2] - y[i1 - 1];
                            double num11 = Math.Sqrt(num9 * num9 + num10 * num10);
                            if (num11 < num8)
                            {
                                num8 = num11;
                                num5 = i2;
                            }
                        }
                        if (i1 == 1)
                            num5 = 0;
                        double num12 = 9999999.9;
                        for (int i3 = 0; i3 <= ks; ++i3)
                        {
                            double num13 = xs[i3] - x[i1];
                            double num14 = ys[i3] - y[i1];
                            double num15 = Math.Sqrt(num13 * num13 + num14 * num14);
                            if (num15 < num12)
                            {
                                num12 = num15;
                                num4 = i3;
                            }
                        }
                        if (i1 == k)
                            num4 = ks;
                        if (num4 - num5 >= 4)
                        {
                            for (int i4 = num5 + 1; i4 < num4; ++i4)
                            {
                                double xp = 0.0;
                                double yp = 0.0;
                                int ip;
                                DistPnt(xs[i4], ys[i4], x[i1 - 1], y[i1 - 1], x[i1], y[i1], out double _, out ip, out xp, out yp);
                                if (ip != 0)
                                {
                                    if (num3 == 2)
                                    {
                                        double num16 = 0.5 * (xs[i4] + xp);
                                        double num17 = 0.5 * (ys[i4] + yp);
                                        xs[i4] = num16;
                                        ys[i4] = num17;
                                    }
                                    else
                                    {
                                        double x1 = xs[i4] - xp;
                                        double y1 = ys[i4] - yp;
                                        double num18 = Math.Sqrt(x1 * x1 + y1 * y1);
                                        if (num18 >= 0.05)
                                        {
                                            double num19 = Math.Atan2(y1, x1);
                                            if (num19 < 0.0)
                                                num19 += 2.0 * num1;
                                            double num20 = num18 / (double)num3;
                                            xs[i4] = xp + num20 * Math.Cos(num19);
                                            ys[i4] = yp + num20 * Math.Sin(num19);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void CheckTriang(
          double xa,
          double ya,
          double xb,
          double yb,
          double xc,
          double yc,
          out int iCond,
          out double h)
        {
            double[] numArray1 = new double[5];
            double[] numArray2 = new double[5];
            iCond = 0;
            h = 0.0;
            int num1 = 0;
            double num2;
            double y2 = num2 = 0.0;
            double x2 = num2;
            double yy = num2;
            double xx = num2;
            double y1 = num2;
            double x1 = num2;
            numArray1[1] = xa;
            numArray2[1] = ya;
            numArray1[2] = xb;
            numArray2[2] = yb;
            numArray1[3] = xc;
            numArray2[3] = yc;
            numArray1[4] = xa;
            numArray2[4] = ya;
            double num3 = 0.0;
            double xp;
            double yp;
            for (int i = 2; i <= 4; ++i)
            {
                xp = numArray1[i] - numArray1[i - 1];
                yp = numArray2[i] - numArray2[i - 1];
                double num4 = Math.Sqrt(xp * xp + yp * yp);
                if (num4 > num3)
                {
                    num3 = num4;
                    num1 = i;
                    x1 = numArray1[i - 1];
                    y1 = numArray2[i - 1];
                    x2 = numArray1[i];
                    y2 = numArray2[i];
                }
            }
            int ip;
            if (num1 == 2)
            {
                ip = 3;
                xx = numArray1[ip];
                yy = numArray2[ip];
            }
            if (num1 == 3)
            {
                ip = 1;
                xx = numArray1[ip];
                yy = numArray2[ip];
            }
            if (num1 == 4)
            {
                ip = 2;
                xx = numArray1[ip];
                yy = numArray2[ip];
            }
            DistPnt(xx, yy, x1, y1, x2, y2, out h, out ip, out xp, out yp);
            if (h >= 0.004)
                return;
            iCond = 1;
        }

        public static void SelIntersect(
          double xh,
          double yh,
          double xk,
          double yk,
          double xv,
          double yv,
          int kSel,
          double[] xs1,
          double[] ys1,
          double[] xs2,
          double[] ys2,
          out int ip,
          out double xp,
          out double yp)
        {
            ip = 0;
            xp = yp = 0.0;
            double ym;
            for (int i = 1; i <= kSel; ++i)
            {
                double x1 = xs1[i];
                double y1 = ys1[i];
                double x2 = xs2[i];
                double y2 = ys2[i];
                double x3 = xh;
                double y3 = yh;
                double x4 = xv;
                double y4 = yv;
                int ip1 = 1;
                double xm = 0.0;
                ym = 0.0;
                TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip1);
                if (xm != 0.0 && ym != 0.0)
                {
                    double num1 = x1 - xm;
                    double num2 = y1 - ym;
                    if (Math.Sqrt(num1 * num1 + num2 * num2) >= 0.003)
                    {
                        double num3 = x2 - xm;
                        double num4 = y2 - ym;
                        if (Math.Sqrt(num3 * num3 + num4 * num4) >= 0.003)
                        {
                            double num5 = x3 - xm;
                            double num6 = y3 - ym;
                            if (Math.Sqrt(num5 * num5 + num6 * num6) >= 0.003)
                            {
                                double num7 = x4 - xm;
                                double num8 = y4 - ym;
                                if (Math.Sqrt(num7 * num7 + num8 * num8) >= 0.003)
                                {
                                    ip = 1;
                                    xp = xm;
                                    yp = ym;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            if (ip > 0)
                return;
            for (int i = 1; i <= kSel; ++i)
            {
                double x1 = xs1[i];
                double y1 = ys1[i];
                double x2 = xs2[i];
                double y2 = ys2[i];
                double x3 = xk;
                double y3 = yk;
                double x4 = xv;
                double y4 = yv;
                int ip2 = 1;
                double xm = 0.0;
                ym = 0.0;
                TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip2);
                if (xm != 0.0 && ym != 0.0)
                {
                    double num9 = x1 - xm;
                    double num10 = y1 - ym;
                    if (Math.Sqrt(num9 * num9 + num10 * num10) >= 0.003)
                    {
                        double num11 = x2 - xm;
                        double num12 = y2 - ym;
                        if (Math.Sqrt(num11 * num11 + num12 * num12) >= 0.003)
                        {
                            double num13 = x3 - xm;
                            double num14 = y3 - ym;
                            if (Math.Sqrt(num13 * num13 + num14 * num14) >= 0.003)
                            {
                                double num15 = x4 - xm;
                                double num16 = y4 - ym;
                                if (Math.Sqrt(num15 * num15 + num16 * num16) >= 0.003)
                                {
                                    ip = 1;
                                    xp = xm;
                                    yp = ym;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void TinInTin(
          double x1,
          double y1,
          double x2,
          double y2,
          double x3,
          double y3,
          int kTin,
          double[] xTin,
          double[] yTin,
          out int iCond)
        {
            double[] x4 = new double[5];
            double[] y4 = new double[5];
            double[] x5 = new double[5];
            double[] y5 = new double[5];
            iCond = 0;
            if (kTin < 4)
                return;
            x5[0] = x1;
            y5[0] = y1;
            x5[1] = x2;
            y5[1] = y2;
            x5[2] = x3;
            y5[2] = y3;
            x5[3] = x1;
            y5[3] = y1;
            double xt1 = (x1 + x2 + x3) / 3.0;
            double yt1 = (y1 + y2 + y3) / 3.0;
            int num = kTin / 4;
            int i1 = -3;
            for (int i2 = 1; i2 <= num; ++i2)
            {
                i1 += 4;
                x4[0] = xTin[i1];
                y4[0] = yTin[i1];
                x4[1] = xTin[i1 + 1];
                y4[1] = yTin[i1 + 1];
                x4[2] = xTin[i1 + 2];
                y4[2] = yTin[i1 + 2];
                x4[3] = xTin[i1];
                y4[3] = yTin[i1];
                if (in_out(3, ref x4, ref y4, xt1, yt1) > 0)
                {
                    iCond = 1;
                    break;
                }
                double xt2 = (x4[0] + x4[1] + x4[2]) / 3.0;
                double yt2 = (y4[0] + y4[1] + y4[2]) / 3.0;
                if (in_out(3, ref x5, ref y5, xt2, yt2) > 0)
                {
                    iCond = 1;
                    break;
                }
            }
        }

        public static void SecondTre(
          int kg,
          double[] xg,
          double[] yg,
          int kt,
          int[] nt,
          double[] xt,
          double[] yt,
          double[] zt,
          int ktin,
          int[] ntin,
          double[] xtin,
          double[] ytin,
          double[] ztin,
          out int kti,
          double[] tPntxc,
          double[] tPntyc,
          int[] nth,
          double[] xth,
          double[] yth,
          double[] zth,
          int[] ntk,
          double[] xtk,
          double[] ytk,
          double[] ztk,
          int[] ind,
          double[] xnd,
          double[] ynd,
          double[] znd,
          double[] xcs,
          double[] ycs,
          int[] ntd,
          double[] xtd,
          double[] ytd,
          double[] ztd,
          double[] xn1,
          double[] yn1,
          double[] xn2,
          double[] yn2,
          StatusBarPanel panel)
        {
            int[] numArray1 = new int[5];
            double[] numArray2 = new double[5];
            double[] numArray3 = new double[5];
            double[] numArray4 = new double[5];
            double num1;
            double num2 = num1 = 0.0;
            double yp;
            double xp = yp = 0.0;
            kti = 0;
            Cursor.Current = Cursors.WaitCursor;
            int kArray1 = 999999;
            doubleArray(xg, ref kArray1);
            doubleArray(yg, ref kArray1);
            if (kg > kArray1)
            {
                int num3 = (int)MessageBox.Show("Индекс массива SecondTre");
            }
            else
            {
                int kArray2 = 999999;
                intArray(nt, ref kArray2);
                doubleArray(xt, ref kArray2);
                doubleArray(yt, ref kArray2);
                doubleArray(zt, ref kArray2);
                if (kt > kArray2)
                {
                    int num4 = (int)MessageBox.Show("Индекс массива SecondTre");
                }
                else
                {
                    kArray2 = 999999;
                    intArray(ntin, ref kArray2);
                    doubleArray(xtin, ref kArray2);
                    doubleArray(ytin, ref kArray2);
                    doubleArray(ztin, ref kArray2);
                    kArray2 -= 3;
                    if (ktin > kArray2)
                    {
                        int num5 = (int)MessageBox.Show("Индекс массива SecondTre");
                    }
                    else
                    {
                        int num6 = 0;
                        int i1 = 0;
                        int i2 = 0;
                        int i3 = 0;
                        int num7 = ktin / 4;
                        int i4 = -3;
                        for (int i5 = 1; i5 <= num7; ++i5)
                        {
                            ++num6;
                            i4 += 4;
                            numArray1[1] = ntin[i4];
                            numArray2[1] = xtin[i4];
                            numArray3[1] = ytin[i4];
                            numArray4[1] = ztin[i4];
                            numArray1[2] = ntin[i4 + 1];
                            numArray2[2] = xtin[i4 + 1];
                            numArray3[2] = ytin[i4 + 1];
                            numArray4[2] = ztin[i4 + 1];
                            numArray1[3] = ntin[i4 + 2];
                            numArray2[3] = xtin[i4 + 2];
                            numArray3[3] = ytin[i4 + 2];
                            numArray4[3] = ztin[i4 + 2];
                            numArray1[4] = ntin[i4 + 3];
                            numArray2[4] = xtin[i4 + 3];
                            numArray3[4] = ytin[i4 + 3];
                            numArray4[4] = ztin[i4 + 3];
                            int num8 = 4;
                            int num9 = 0;
                            if (i1 > 0)
                            {
                                xp = (xtin[i4] + xtin[i4 + 1] + xtin[i4 + 2]) / 3.0;
                                yp = (ytin[i4] + ytin[i4 + 1] + ytin[i4 + 2]) / 3.0;
                                for (int i6 = 1; i6 <= i1; ++i6)
                                {
                                    double num10 = tPntxc[i6] - xp;
                                    double num11 = tPntyc[i6] - yp;
                                    if (Math.Sqrt(num10 * num10 + num11 * num11) < 0.003)
                                    {
                                        ++num9;
                                        break;
                                    }
                                }
                            }
                            if (num9 <= 0)
                            {
                                for (int i7 = 1; i7 <= num8; ++i7)
                                {
                                    ++i2;
                                    if (i2 > kArray2)
                                    {
                                        int num12 = (int)MessageBox.Show("Индекс массива SecondTre");
                                        return;
                                    }
                                    ntin[i2] = numArray1[i7];
                                    xtin[i2] = numArray2[i7];
                                    ytin[i2] = numArray3[i7];
                                    ztin[i2] = numArray4[i7];
                                }
                                ++i1;
                                tPntxc[i1] = (xtin[i4] + xtin[i4 + 1] + xtin[i4 + 2]) / 3.0;
                                tPntyc[i1] = (ytin[i4] + ytin[i4 + 1] + ytin[i4 + 2]) / 3.0;
                                int num13 = in_out(kg, ref xg, ref yg, xtin[i4], ytin[i4]);
                                int num14 = in_out(kg, ref xg, ref yg, xtin[i4 + 1], ytin[i4 + 1]);
                                if (num13 > 0 && num14 > 0)
                                {
                                    ++i3;
                                    nth[i3] = ntin[i4];
                                    xth[i3] = xtin[i4];
                                    yth[i3] = ytin[i4];
                                    zth[i3] = ztin[i4];
                                    ntk[i3] = ntin[i4 + 1];
                                    xtk[i3] = xtin[i4 + 1];
                                    ytk[i3] = ytin[i4 + 1];
                                    ztk[i3] = ztin[i4 + 1];
                                    ind[i3] = ntin[i4 + 2];
                                    xnd[i3] = xtin[i4 + 2];
                                    ynd[i3] = ytin[i4 + 2];
                                    xcs[i3] = 0.5 * (xtin[i4] + xtin[i4 + 1]);
                                    ycs[i3] = 0.5 * (ytin[i4] + ytin[i4 + 1]);
                                }
                                else
                                {
                                    int num15 = in_out(kg, ref xg, ref yg, xtin[i4 + 1], ytin[i4 + 1]);
                                    int num16 = in_out(kg, ref xg, ref yg, xtin[i4 + 2], ytin[i4 + 2]);
                                    if (num15 > 0 && num16 > 0)
                                    {
                                        ++i3;
                                        nth[i3] = ntin[i4 + 1];
                                        xth[i3] = xtin[i4 + 1];
                                        yth[i3] = ytin[i4 + 1];
                                        zth[i3] = ztin[i4 + 1];
                                        ntk[i3] = ntin[i4 + 2];
                                        xtk[i3] = xtin[i4 + 2];
                                        ytk[i3] = ytin[i4 + 2];
                                        ztk[i3] = ztin[i4 + 2];
                                        ind[i3] = ntin[i4 + 3];
                                        xnd[i3] = xtin[i4 + 3];
                                        ynd[i3] = ytin[i4 + 3];
                                        xcs[i3] = 0.5 * (xtin[i4 + 1] + xtin[i4 + 2]);
                                        ycs[i3] = 0.5 * (ytin[i4 + 1] + ytin[i4 + 2]);
                                    }
                                    else
                                    {
                                        int num17 = in_out(kg, ref xg, ref yg, xtin[i4 + 2], ytin[i4 + 2]);
                                        int num18 = in_out(kg, ref xg, ref yg, xtin[i4 + 3], ytin[i4 + 3]);
                                        if (num17 > 0 && num18 > 0)
                                        {
                                            ++i3;
                                            nth[i3] = ntin[i4 + 2];
                                            xth[i3] = xtin[i4 + 2];
                                            yth[i3] = ytin[i4 + 2];
                                            zth[i3] = ztin[i4 + 2];
                                            ntk[i3] = ntin[i4 + 3];
                                            xtk[i3] = xtin[i4 + 3];
                                            ytk[i3] = ytin[i4 + 3];
                                            ztk[i3] = ztin[i4 + 3];
                                            ind[i3] = ntin[i4 + 1];
                                            xnd[i3] = xtin[i4 + 1];
                                            ynd[i3] = ytin[i4 + 1];
                                            xcs[i3] = 0.5 * (xtin[i4 + 2] + xtin[i4 + 3]);
                                            ycs[i3] = 0.5 * (ytin[i4 + 2] + ytin[i4 + 3]);
                                        }
                                    }
                                }
                            }
                        }
                        ktin = i2;
                        kti = ktin;
                        int kSel = 0;
                        for (int i8 = 1; i8 <= kt; ++i8)
                        {
                            for (int i9 = 1; i9 <= i3; ++i9)
                            {
                                ++kSel;
                                ind[kSel] = kSel;
                                xnd[kSel] = xth[i9];
                                ynd[kSel] = yth[i9];
                                xtd[kSel] = xtk[i9];
                                ytd[kSel] = ytk[i9];
                                xcs[kSel] = 0.5 * (xth[i9] + xtk[i9]);
                                ycs[kSel] = 0.5 * (yth[i9] + ytk[i9]);
                            }
                            int num19 = 0;
                            int i10 = 0;
                            int num20;
                            for (int i11 = 1; i11 <= i3; ++i11)
                            {
                                if (nth[i11] != 0 || ntk[i11] != 0)
                                {
                                    int i12 = 2;
                                    numArray1[1] = nth[i11];
                                    numArray2[1] = xth[i11];
                                    numArray3[1] = yth[i11];
                                    numArray4[1] = zth[i11];
                                    numArray1[2] = ntk[i11];
                                    numArray2[2] = xtk[i11];
                                    numArray3[2] = ytk[i11];
                                    numArray4[2] = ztk[i11];
                                    nth[i11] = 0;
                                    ntk[i11] = 0;
                                    double num21 = numArray2[2] - numArray2[1];
                                    double num22 = numArray3[2] - numArray3[1];
                                    double num23 = num21 * num21 + num22 * num22;
                                    double num24 = 9999999.9;
                                    for (int i13 = 1; i13 <= kt; ++i13)
                                    {
                                        CheckTriang(numArray2[1], numArray3[1], numArray2[2], numArray3[2], xt[i13], yt[i13], out num20, out double _);
                                        if (num20 <= 0)
                                        {
                                            SelIntersect(numArray2[1], numArray3[1], numArray2[2], numArray3[2], xt[i13], yt[i13], kSel, xnd, ynd, xtd, ytd, out num20, out xp, out yp);
                                            if (num20 <= 0)
                                            {
                                                TinInTin(numArray2[1], numArray3[1], numArray2[2], numArray3[2], xt[i13], yt[i13], ktin, xtin, ytin, out num20);
                                                if (num20 <= 0)
                                                {
                                                    double num25 = xt[i13] - numArray2[1];
                                                    double num26 = yt[i13] - numArray3[1];
                                                    double d1 = num25 * num25 + num26 * num26;
                                                    double num27 = Math.Sqrt(d1);
                                                    if (num27 >= 0.003)
                                                    {
                                                        double num28 = xt[i13] - numArray2[2];
                                                        double num29 = yt[i13] - numArray3[2];
                                                        double d2 = num28 * num28 + num29 * num29;
                                                        double num30 = Math.Sqrt(d2);
                                                        if (num30 >= 0.003)
                                                        {
                                                            double num31 = (d1 + d2 - num23) / (2.0 * num27 * num30);
                                                            if (num31 < num24)
                                                            {
                                                                num24 = num31;
                                                                i12 = 3;
                                                                numArray2[i12] = xt[i13];
                                                                numArray3[i12] = yt[i13];
                                                                numArray4[i12] = zt[i13];
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (i12 >= 3)
                                    {
                                        ++num19;
                                        int i14 = 4;
                                        numArray2[i14] = numArray2[1];
                                        numArray3[i14] = numArray3[1];
                                        numArray4[i14] = numArray4[1];
                                        int i15 = kSel + 1;
                                        ind[i15] = i15;
                                        xnd[i15] = numArray2[1];
                                        ynd[i15] = numArray3[1];
                                        znd[i15] = numArray4[1];
                                        xtd[i15] = numArray2[3];
                                        ytd[i15] = numArray3[3];
                                        ztd[i15] = numArray4[3];
                                        xcs[i15] = 0.5 * (numArray2[1] + numArray2[3]);
                                        ycs[i15] = 0.5 * (numArray3[1] + numArray3[3]);
                                        num20 = 0;
                                        for (int i16 = 1; i16 <= i3; ++i16)
                                        {
                                            xp = 0.5 * (xth[i16] + xtk[i16]);
                                            yp = 0.5 * (yth[i16] + ytk[i16]);
                                            double num32 = xcs[i15] - xp;
                                            double num33 = ycs[i15] - yp;
                                            if (Math.Sqrt(num32 * num32 + num33 * num33) < 0.003)
                                            {
                                                ++num20;
                                                nth[i16] = 0;
                                                ntk[i16] = 0;
                                                break;
                                            }
                                        }
                                        if (num20 == 0)
                                        {
                                            ++i10;
                                            xn1[i10] = xnd[i15];
                                            yn1[i10] = ynd[i15];
                                            xn2[i10] = xtd[i15];
                                            yn2[i10] = ytd[i15];
                                        }
                                        kSel = i15 + 1;
                                        ind[kSel] = kSel;
                                        xnd[kSel] = numArray2[2];
                                        ynd[kSel] = numArray3[2];
                                        znd[kSel] = numArray4[2];
                                        xtd[kSel] = numArray2[3];
                                        ytd[kSel] = numArray3[3];
                                        ztd[kSel] = numArray4[3];
                                        xcs[kSel] = 0.5 * (numArray2[2] + numArray2[3]);
                                        ycs[kSel] = 0.5 * (numArray3[2] + numArray3[3]);
                                        num20 = 0;
                                        for (int i17 = 1; i17 <= i3; ++i17)
                                        {
                                            xp = 0.5 * (xth[i17] + xtk[i17]);
                                            yp = 0.5 * (yth[i17] + ytk[i17]);
                                            double num34 = xcs[kSel] - xp;
                                            double num35 = ycs[kSel] - yp;
                                            if (Math.Sqrt(num34 * num34 + num35 * num35) < 0.003)
                                            {
                                                ++num20;
                                                nth[i17] = 0;
                                                ntk[i17] = 0;
                                                break;
                                            }
                                        }
                                        if (num20 == 0)
                                        {
                                            ++i10;
                                            xn1[i10] = xnd[kSel];
                                            yn1[i10] = ynd[kSel];
                                            xn2[i10] = xtd[kSel];
                                            yn2[i10] = ytd[kSel];
                                        }
                                        for (int i18 = 1; i18 <= i14; ++i18)
                                        {
                                            ++ktin;
                                            xtin[ktin] = numArray2[i18];
                                            ytin[ktin] = numArray3[i18];
                                            ztin[ktin] = numArray4[i18];
                                        }
                                        ++num6;
                                        panel.Text = "Подождите..Модель рельефа " + string.Format("{0}", (object)num6);
                                    }
                                }
                            }
                            if (num19 != 0 && i10 != 0)
                            {
                                if (i10 > 1)
                                {
                                    for (int i19 = 1; i19 < i10; ++i19)
                                        ind[i19] = i19;
                                    for (int i20 = 1; i20 < i10; ++i20)
                                    {
                                        if (ind[i20] != 0)
                                        {
                                            double num36 = 0.5 * (xn1[i20] + xn2[i20]);
                                            double num37 = 0.5 * (yn1[i20] + yn2[i20]);
                                            int num38 = i20 + 1;
                                            num20 = 0;
                                            for (int i21 = num38; i21 <= i10; ++i21)
                                            {
                                                if (ind[i21] != 0)
                                                {
                                                    double num39 = 0.5 * (xn1[i21] + xn2[i21]);
                                                    double num40 = 0.5 * (yn1[i21] + yn2[i21]);
                                                    double num41 = num36 - num39;
                                                    double num42 = num37 - num40;
                                                    if (Math.Sqrt(num41 * num41 + num42 * num42) < 0.003)
                                                    {
                                                        ++num20;
                                                        ind[i21] = 0;
                                                    }
                                                }
                                            }
                                            if (num20 != 0)
                                                ind[i20] = 0;
                                        }
                                    }
                                    int i22 = 0;
                                    for (int i23 = 1; i23 <= i10; ++i23)
                                    {
                                        if (ind[i23] != 0)
                                        {
                                            ++i22;
                                            xn1[i22] = xn1[i23];
                                            yn1[i22] = yn1[i23];
                                            xn2[i22] = xn2[i23];
                                            yn2[i22] = yn2[i23];
                                        }
                                    }
                                    i10 = i22;
                                }
                                if (i10 != 0)
                                {
                                    i3 = i10;
                                    for (int i24 = 1; i24 <= i10; ++i24)
                                    {
                                        ind[i24] = i24;
                                        xth[i24] = xn1[i24];
                                        yth[i24] = yn1[i24];
                                        xtk[i24] = xn2[i24];
                                        ytk[i24] = yn2[i24];
                                        xcs[i24] = 0.5 * (xth[i24] + xtk[i24]);
                                        ycs[i24] = 0.5 * (yth[i24] + ytk[i24]);
                                    }
                                    for (int i25 = 1; i25 <= i3; ++i25)
                                    {
                                        for (int i26 = 1; i26 <= kt; ++i26)
                                        {
                                            double num43 = xth[i25] - xt[i26];
                                            double num44 = yth[i25] - yt[i26];
                                            if (Math.Sqrt(num43 * num43 + num44 * num44) < 0.003)
                                            {
                                                nth[i25] = nt[i26];
                                                zth[i25] = zt[i26];
                                            }
                                            double num45 = xtk[i25] - xt[i26];
                                            double num46 = ytk[i25] - yt[i26];
                                            if (Math.Sqrt(num45 * num45 + num46 * num46) < 0.003)
                                            {
                                                ntk[i25] = nt[i26];
                                                ztk[i25] = zt[i26];
                                            }
                                        }
                                    }
                                }
                                else
                                    break;
                            }
                            else
                                break;
                        }
                        kti = ktin;
                    }
                }
            }
        }

        public static void FindSection(
          double x1,
          double y1,
          double x2,
          double y2,
          int kTin,
          double[] xTin,
          double[] yTin,
          out int kSect,
          double[] xs,
          double[] ys,
          double[] xs1,
          double[] ys1,
          double[] xs2,
          double[] ys2)
        {
            double[] numArray1 = new double[5];
            double[] numArray2 = new double[5];
            kSect = 0;
            int kArray = 999999;
            doubleArray(xs, ref kArray);
            doubleArray(ys, ref kArray);
            doubleArray(xs1, ref kArray);
            doubleArray(ys1, ref kArray);
            doubleArray(xs2, ref kArray);
            doubleArray(ys2, ref kArray);
            int num1 = kArray - 4;
            int num2 = kTin / 4;
            int i1 = -3;
            int i2 = 0;
            for (int i3 = 1; i3 <= num2; ++i3)
            {
                i1 += 4;
                numArray1[1] = xTin[i1];
                numArray2[1] = yTin[i1];
                numArray1[2] = xTin[i1 + 1];
                numArray2[2] = yTin[i1 + 1];
                numArray1[3] = xTin[i1 + 2];
                numArray2[3] = yTin[i1 + 2];
                numArray1[4] = xTin[i1 + 3];
                numArray2[4] = yTin[i1 + 3];
                for (int i4 = 2; i4 <= 4; ++i4)
                {
                    double x3 = numArray1[i4 - 1];
                    double y3 = numArray2[i4 - 1];
                    double x4 = numArray1[i4];
                    double y4 = numArray2[i4];
                    int ip = 1;
                    double xm;
                    double ym;
                    TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip);
                    if (xm != 0.0 || ym != 0.0)
                    {
                        ip = 0;
                        if (i2 > 0)
                        {
                            for (int i5 = 1; i5 <= i2; ++i5)
                            {
                                double num3 = xs[i5] - xm;
                                double num4 = ys[i5] - ym;
                                if (Math.Sqrt(num3 * num3 + num4 * num4) < 0.003)
                                {
                                    ++ip;
                                    break;
                                }
                            }
                        }
                        if (ip <= 0)
                        {
                            ++i2;
                            xs[i2] = xm;
                            ys[i2] = ym;
                            xs1[i2] = x3;
                            ys1[i2] = y3;
                            xs2[i2] = x4;
                            ys2[i2] = y4;
                            if (i2 > num1)
                            {
                                int num5 = (int)MessageBox.Show("Индекс массива FindSection");
                                return;
                            }
                        }
                    }
                }
            }
            kSect = i2;
        }

        public static void BorderY(
          double xh,
          double yh,
          double xk,
          double yk,
          int kPnt,
          int[] nPnt,
          double[] xPnt,
          double[] yPnt,
          double[] zPnt,
          out int kTin,
          int[] nTin,
          double[] xTin,
          double[] yTin,
          double[] zTin,
          int[] nDop,
          int kp,
          double[] xp,
          double[] yp,
          int[] np1,
          double[] xp1,
          double[] yp1,
          double[] zp1,
          int[] np2,
          double[] xp2,
          double[] yp2,
          double[] zp2)
        {
            int[] numArray1 = new int[10];
            double[] numArray2 = new double[10];
            double[] numArray3 = new double[10];
            double[] numArray4 = new double[10];
            int num1 = 30;
            kTin = 0;
            int kArray = 999999;
            intArray(nTin, ref kArray);
            doubleArray(xTin, ref kArray);
            doubleArray(yTin, ref kArray);
            doubleArray(zTin, ref kArray);
            int num2 = kArray - 5;
            double num3 = 9999999.9;
            double num4 = 9999999.9;
            double num5 = -9999999.9;
            double num6 = -9999999.9;
            for (int i = 0; i <= kPnt; ++i)
            {
                if (xPnt[i] < num3)
                    num3 = xPnt[i];
                if (yPnt[i] < num4)
                    num4 = yPnt[i];
                if (xPnt[i] > num5)
                    num5 = xPnt[i];
                if (yPnt[i] > num6)
                    num6 = yPnt[i];
            }
            double num7 = (num5 - num3) * (num6 - num4);
            double num8 = Math.Sqrt(Convert.ToDouble((double)num1 * num7 / (double)kPnt));
            double num9 = yp[kp] - yp[1];
            if (num9 > num8)
                num8 = num9 - 1.0;
            int i1 = 0;
            int i2 = 0;
            for (int i3 = 2; i3 <= kp; i3 += 2)
            {
                int num10 = np1[i3];
                int num11 = np2[i3];
                double num12 = xp[i3 - 1];
                double num13 = yp[i3 - 1];
                double x3 = xp[i3 - 1];
                double y3 = yp[i3 - 1];
                double x4 = xp[i3];
                double y4 = yp[i3];
                numArray1[1] = np1[i3 - 1];
                numArray2[1] = xp1[i3 - 1];
                numArray3[1] = yp1[i3 - 1];
                numArray4[1] = zp1[i3 - 1];
                numArray1[2] = np2[i3 - 1];
                numArray2[2] = xp2[i3 - 1];
                numArray3[2] = yp2[i3 - 1];
                numArray4[2] = zp2[i3 - 1];
                int num14 = 0;
                int num15 = 0;
                for (int i4 = 0; i4 <= kPnt; ++i4)
                {
                    double num16 = numArray2[2] - numArray2[1];
                    double num17 = numArray3[2] - numArray3[1];
                    double num18 = num16 * num16 + num17 * num17;
                    double num19 = 9999999.9;
                    int i5 = 2;
                    int ip;
                    double xm;
                    double ym;
                    for (int i6 = 0; i6 <= kPnt; ++i6)
                    {
                        if (Math.Abs(xPnt[i6] - num12) <= num8)
                        {
                            ip = 0;
                            if (i2 > 0)
                            {
                                for (int i7 = 1; i7 <= i2; ++i7)
                                {
                                    if (nDop[i7] == nPnt[i6])
                                    {
                                        ++ip;
                                        break;
                                    }
                                }
                            }
                            if (ip <= 0)
                            {
                                double num20 = xPnt[i6] - numArray2[1];
                                double num21 = yPnt[i6] - numArray3[1];
                                double d1 = num20 * num20 + num21 * num21;
                                double num22 = Math.Sqrt(d1);
                                double num23 = xPnt[i6] - numArray2[2];
                                double num24 = yPnt[i6] - numArray3[2];
                                double d2 = num23 * num23 + num24 * num24;
                                double num25 = Math.Sqrt(d2);
                                if (num22 <= num8 && num25 <= num8)
                                {
                                    ip = 1;
                                    xm = 0.0;
                                    ym = 0.0;
                                    TwoLine(numArray2[1], numArray3[1], x3, yh, xPnt[i6], yPnt[i6], x4, yk, out xm, out ym, ref ip);
                                    if (ym == 0.0 || ym > num13)
                                    {
                                        ip = 1;
                                        xm = 0.0;
                                        ym = 0.0;
                                        TwoLine(numArray2[2], numArray3[2], x3, yh, xPnt[i6], yPnt[i6], x4, yk, out xm, out ym, ref ip);
                                        if (ym == 0.0 || ym > num13)
                                        {
                                            double num26 = (d1 + d2 - num18) / (2.0 * num22 * num25);
                                            if (num26 < num19)
                                            {
                                                num19 = num26;
                                                i5 = 3;
                                                numArray1[i5] = nPnt[i6];
                                                numArray2[i5] = xPnt[i6];
                                                numArray3[i5] = yPnt[i6];
                                                numArray4[i5] = zPnt[i6];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (i5 >= 3)
                    {
                        int i8 = i2 + 1;
                        nDop[i8] = numArray1[1];
                        i2 = i8 + 1;
                        nDop[i2] = numArray1[2];
                        int i9 = 4;
                        numArray1[i9] = numArray1[1];
                        numArray2[i9] = numArray2[1];
                        numArray3[i9] = numArray3[1];
                        numArray4[i9] = numArray4[1];
                        for (int i10 = 1; i10 <= i9; ++i10)
                        {
                            if (i1 > num2)
                            {
                                int num27 = (int)MessageBox.Show("Индекс массива BorderY");
                                return;
                            }
                            ++i1;
                            nTin[i1] = numArray1[i10];
                            xTin[i1] = numArray2[i10];
                            yTin[i1] = numArray3[i10];
                            zTin[i1] = numArray4[i10];
                        }
                        if (num14 > 0)
                        {
                            if (numArray1[3] == num14)
                            {
                                xm = 0.5 * (xp1[i3] + xp2[i3]);
                                ym = 0.5 * (yp1[i3] + yp2[i3]);
                                double num28 = 0.5 * (numArray2[1] + numArray2[3]);
                                double num29 = 0.5 * (numArray3[1] + numArray3[3]);
                                double num30 = num28 - xm;
                                double num31 = num29 - ym;
                                double num32 = Math.Sqrt(num30 * num30 + num31 * num31);
                                if (num32 >= 0.003)
                                {
                                    double num33 = 0.5 * (numArray2[2] + numArray2[3]);
                                    double num34 = 0.5 * (numArray3[2] + numArray3[3]);
                                    double num35 = num33 - xm;
                                    double num36 = num34 - ym;
                                    double num37 = Math.Sqrt(num35 * num35 + num36 * num36);
                                    if (num37 >= 0.003)
                                    {
                                        if (num32 < num37)
                                        {
                                            int num38 = numArray1[1];
                                            double num39 = numArray2[1];
                                            double num40 = numArray3[1];
                                            double num41 = numArray4[1];
                                            numArray1[1] = np1[i3];
                                            numArray2[1] = xp1[i3];
                                            numArray3[1] = yp1[i3];
                                            numArray4[1] = zp1[i3];
                                            numArray1[2] = np2[i3];
                                            numArray2[2] = xp2[i3];
                                            numArray3[2] = yp2[i3];
                                            numArray4[2] = zp2[i3];
                                            numArray1[3] = num38;
                                            numArray2[3] = num39;
                                            numArray3[3] = num40;
                                            numArray4[3] = num41;
                                        }
                                        if (num37 < num32)
                                        {
                                            int num42 = numArray1[2];
                                            double num43 = numArray2[2];
                                            double num44 = numArray3[2];
                                            double num45 = numArray4[2];
                                            numArray1[1] = np1[i3];
                                            numArray2[1] = xp1[i3];
                                            numArray3[1] = yp1[i3];
                                            numArray4[1] = zp1[i3];
                                            numArray1[2] = np2[i3];
                                            numArray2[2] = xp2[i3];
                                            numArray3[2] = yp2[i3];
                                            numArray4[2] = zp2[i3];
                                            numArray1[3] = num42;
                                            numArray2[3] = num43;
                                            numArray3[3] = num44;
                                            numArray4[3] = num45;
                                        }
                                        numArray1[4] = numArray1[1];
                                        numArray2[4] = numArray2[1];
                                        numArray3[4] = numArray3[1];
                                        numArray4[4] = numArray4[1];
                                        int num46 = 4;
                                        for (int i11 = 1; i11 <= num46; ++i11)
                                        {
                                            if (i1 > num2)
                                            {
                                                int num47 = (int)MessageBox.Show("Индекс массива BorderY");
                                                return;
                                            }
                                            ++i1;
                                            nTin[i1] = numArray1[i11];
                                            xTin[i1] = numArray2[i11];
                                            yTin[i1] = numArray3[i11];
                                            zTin[i1] = numArray4[i11];
                                        }
                                        break;
                                    }
                                    break;
                                }
                                break;
                            }
                            int num48 = 0;
                            double x1 = xp1[i3];
                            double y1 = yp1[i3];
                            double x2 = xp2[i3];
                            double y2 = yp2[i3];
                            if (numArray1[1] == num15)
                            {
                                ip = 1;
                                xm = 0.0;
                                ym = 0.0;
                                TwoLine(x1, y1, numArray2[2], numArray3[2], x2, y2, numArray2[3], numArray3[3], out xm, out ym, ref ip);
                                if (xm != 0.0 && ym != 0.0)
                                {
                                    ++num48;
                                    numArray1[1] = np1[i3];
                                    numArray2[1] = xp1[i3];
                                    numArray3[1] = yp1[i3];
                                    numArray4[1] = zp1[i3];
                                    numArray1[3] = np2[i3];
                                    numArray2[3] = xp2[i3];
                                    numArray3[3] = yp2[i3];
                                    numArray4[3] = zp2[i3];
                                }
                            }
                            if (numArray1[2] == num15)
                            {
                                ip = 1;
                                xm = 0.0;
                                ym = 0.0;
                                TwoLine(x1, y1, numArray2[1], numArray3[1], x2, y2, numArray2[3], numArray3[3], out xm, out ym, ref ip);
                                if (xm != 0.0 && ym != 0.0)
                                {
                                    ++num48;
                                    numArray1[2] = np1[i3];
                                    numArray2[2] = xp1[i3];
                                    numArray3[2] = yp1[i3];
                                    numArray4[2] = zp1[i3];
                                    numArray1[3] = np2[i3];
                                    numArray2[3] = xp2[i3];
                                    numArray3[3] = yp2[i3];
                                    numArray4[3] = zp2[i3];
                                }
                            }
                            if (num48 > 0)
                            {
                                numArray1[4] = numArray1[1];
                                numArray2[4] = numArray2[1];
                                numArray3[4] = numArray3[1];
                                numArray4[4] = numArray4[1];
                                int num49 = 4;
                                for (int i12 = 1; i12 <= num49; ++i12)
                                {
                                    if (i1 > num2)
                                    {
                                        int num50 = (int)MessageBox.Show("Индекс массива BorderY");
                                        return;
                                    }
                                    ++i1;
                                    nTin[i1] = numArray1[i12];
                                    xTin[i1] = numArray2[i12];
                                    yTin[i1] = numArray3[i12];
                                    zTin[i1] = numArray4[i12];
                                }
                                break;
                            }
                        }
                        if (num14 == 0)
                        {
                            if (numArray1[3] == num10)
                            {
                                num14 = num11;
                                num15 = num10;
                            }
                            if (numArray1[3] == num11)
                            {
                                num14 = num10;
                                num15 = num11;
                            }
                        }
                        int num51 = numArray1[1];
                        double x1_1 = numArray2[1];
                        double y1_1 = numArray3[1];
                        double num52 = numArray4[1];
                        int num53 = numArray1[2];
                        double x1_2 = numArray2[2];
                        double y1_2 = numArray3[2];
                        double num54 = numArray4[2];
                        ip = 1;
                        xm = 0.0;
                        ym = 0.0;
                        TwoLine(x1_1, y1_1, x3, y3, numArray2[3], numArray3[3], x4, y4, out xm, out ym, ref ip);
                        if (ym < y4)
                        {
                            if (xm != 0.0 && ym != 0.0)
                            {
                                if (ym > num13)
                                {
                                    num12 = xm;
                                    num13 = ym;
                                    numArray1[1] = num51;
                                    numArray2[1] = x1_1;
                                    numArray3[1] = y1_1;
                                    numArray4[1] = num52;
                                    numArray1[2] = numArray1[3];
                                    numArray2[2] = numArray2[3];
                                    numArray3[2] = numArray3[3];
                                }
                            }
                            else
                            {
                                ip = 1;
                                xm = 0.0;
                                ym = 0.0;
                                TwoLine(x1_2, y1_2, x3, y3, numArray2[3], numArray3[3], x4, y4, out xm, out ym, ref ip);
                                if (ym < y4)
                                {
                                    if (xm != 0.0 && ym != 0.0 && ym > num13)
                                    {
                                        num12 = xm;
                                        num13 = ym;
                                        numArray1[1] = num53;
                                        numArray2[1] = x1_2;
                                        numArray3[1] = y1_2;
                                        numArray4[1] = num54;
                                        numArray1[2] = numArray1[3];
                                        numArray2[2] = numArray2[3];
                                        numArray3[2] = numArray3[3];
                                        numArray4[2] = numArray4[3];
                                    }
                                }
                                else
                                    break;
                            }
                        }
                        else
                            break;
                    }
                }
            }
            kTin = i1;
        }

        public static void PolyArea(int k, double[] x, double[] y, out double sArea)
        {
            int num1;
            int i1 = num1 = 0;
            double num2;
            double num3 = num2 = 0.0;
            double num4 = num2;
            double num5 = num2;
            double num6 = x[k] - x[0];
            double num7 = y[k] - y[0];
            double num8 = Math.Sqrt(num6 * num6 + num7 * num7);
            if (num8 < 0.1)
                i1 = k - 1;
            if (num8 >= 0.1)
                i1 = k;
            double num9 = 0.0;
            double num10 = 0.0;
            for (int i2 = 0; i2 <= i1; ++i2)
            {
                num9 += x[i2];
                num10 += y[i2];
            }
            double num11 = num9 / (double)i1;
            double num12 = num10 / (double)i1;
            double num13 = 0.0;
            for (int i3 = 0; i3 <= i1; ++i3)
            {
                double num14 = x[i3] - num11;
                if (i3 == 0)
                {
                    num4 = y[i3 + 1] - num12;
                    num5 = y[i1] - num12;
                }
                if (i3 > 0 && i3 < i1)
                {
                    num4 = y[i3 + 1] - num12;
                    num5 = y[i3 - 1] - num12;
                }
                if (i3 == i1)
                {
                    num4 = y[0] - num12;
                    num5 = y[i1 - 1] - num12;
                }
                num13 += num14 * (num4 - num5);
            }
            sArea = 0.5 * Math.Abs(num13);
        }

        public static void BorderX(
          double xh,
          double yh,
          double xk,
          double yk,
          int kBord,
          double[] xBord,
          double[] yBord,
          int kPnt,
          int[] nPnt,
          double[] xPnt,
          double[] yPnt,
          double[] zPnt,
          out int kTin,
          int[] nTin,
          double[] xTin,
          double[] yTin,
          double[] zTin,
          int[] nDop,
          int[] nWork,
          double[] zWork)
        {
            int[] numArray1 = new int[10];
            double[] numArray2 = new double[10];
            double[] numArray3 = new double[10];
            double[] numArray4 = new double[10];
            int[] numArray5 = new int[20];
            double[] numArray6 = new double[20];
            double[] numArray7 = new double[20];
            double[] numArray8 = new double[20];
            int[] numArray9 = new int[20];
            double[] numArray10 = new double[20];
            double[] numArray11 = new double[20];
            double[] numArray12 = new double[20];
            double[] numArray13 = new double[20];
            double[] numArray14 = new double[20];
            int num1 = 30;
            kTin = 0;
            int kArray = 999999;
            intArray(nTin, ref kArray);
            doubleArray(xTin, ref kArray);
            doubleArray(yTin, ref kArray);
            doubleArray(zTin, ref kArray);
            int num2 = kArray - 5;
            double num3 = 9999999.9;
            double num4 = 9999999.9;
            double num5 = -9999999.9;
            double num6 = -9999999.9;
            for (int i = 0; i <= kPnt; ++i)
            {
                if (xPnt[i] < num3)
                    num3 = xPnt[i];
                if (yPnt[i] < num4)
                    num4 = yPnt[i];
                if (xPnt[i] > num5)
                    num5 = xPnt[i];
                if (yPnt[i] > num6)
                    num6 = yPnt[i];
            }
            double num7 = (num5 - num3) * (num6 - num4);
            double num8 = Math.Sqrt(Convert.ToDouble((double)num1 * num7 / (double)kPnt));
            for (int i1 = 0; i1 <= kBord; ++i1)
            {
                for (int i2 = 0; i2 <= kPnt; ++i2)
                {
                    double num9 = xBord[i1] - xPnt[i2];
                    double num10 = yBord[i1] - yPnt[i2];
                    if (Math.Sqrt(num9 * num9 + num10 * num10) < 0.003)
                    {
                        nWork[i1] = nPnt[i2];
                        zWork[i1] = zPnt[i2];
                        break;
                    }
                }
            }
            int i3 = 0;
            double ym;
            for (int i4 = 1; i4 <= kBord; ++i4)
            {
                double x1 = xBord[i4 - 1];
                double y1 = yBord[i4 - 1];
                double x2 = xBord[i4];
                double y2 = yBord[i4];
                int ip = 1;
                double xm = 0.0;
                ym = 0.0;
                TwoLine(x1, y1, xh, yh, x2, y2, xk, yk, out xm, out ym, ref ip);
                if (xm != 0.0 || ym != 0.0)
                {
                    ++i3;
                    numArray13[i3] = xm;
                    numArray14[i3] = ym;
                    numArray5[i3] = nWork[i4 - 1];
                    numArray6[i3] = xBord[i4 - 1];
                    numArray7[i3] = yBord[i4 - 1];
                    numArray8[i3] = zWork[i4 - 1];
                    numArray9[i3] = nWork[i4];
                    numArray10[i3] = xBord[i4];
                    numArray11[i3] = yBord[i4];
                    numArray12[i3] = zWork[i4];
                }
            }
            if (i3 == 0)
                return;
            for (int i5 = 1; i5 < i3; ++i5)
            {
                for (int i6 = i5 + 1; i6 <= i3; ++i6)
                {
                    if (numArray13[i5] > numArray13[i6])
                    {
                        double num11 = numArray13[i5];
                        ym = numArray14[i5];
                        int num12 = numArray5[i5];
                        double num13 = numArray6[i5];
                        double num14 = numArray7[i5];
                        double num15 = numArray8[i5];
                        int num16 = numArray9[i5];
                        double num17 = numArray10[i5];
                        double num18 = numArray11[i5];
                        double num19 = numArray12[i5];
                        numArray13[i5] = numArray13[i6];
                        numArray14[i5] = numArray14[i6];
                        numArray5[i5] = numArray5[i6];
                        numArray6[i5] = numArray6[i6];
                        numArray7[i5] = numArray7[i6];
                        numArray8[i5] = numArray8[i6];
                        numArray9[i5] = numArray9[i6];
                        numArray10[i5] = numArray10[i6];
                        numArray11[i5] = numArray11[i6];
                        numArray12[i5] = numArray12[i6];
                        numArray13[i6] = num11;
                        numArray14[i6] = ym;
                        numArray5[i6] = num12;
                        numArray6[i6] = num13;
                        numArray7[i6] = num14;
                        numArray8[i6] = num15;
                        numArray9[i6] = num16;
                        numArray10[i6] = num17;
                        numArray11[i6] = num18;
                        numArray12[i6] = num19;
                    }
                }
            }
            double num20 = numArray13[i3] - numArray13[1];
            if (num20 > num8)
                num8 = num20 - 1.0;
            int i7 = 0;
            int i8 = 0;
            for (int i9 = 2; i9 <= i3; i9 += 2)
            {
                int num21 = numArray5[i9];
                int num22 = numArray9[i9];
                double num23 = numArray13[i9 - 1];
                double num24 = numArray14[i9 - 1];
                double x3 = numArray13[i9 - 1];
                double y3 = numArray14[i9 - 1];
                double x4 = numArray13[i9];
                double y4 = numArray14[i9];
                numArray1[1] = numArray5[i9 - 1];
                numArray2[1] = numArray6[i9 - 1];
                numArray3[1] = numArray7[i9 - 1];
                numArray4[1] = numArray8[i9 - 1];
                numArray1[2] = numArray9[i9 - 1];
                numArray2[2] = numArray10[i9 - 1];
                numArray3[2] = numArray11[i9 - 1];
                numArray4[2] = numArray12[i9 - 1];
                for (int i10 = 0; i10 <= kPnt; ++i10)
                {
                    double num25 = numArray2[2] - numArray2[1];
                    double num26 = numArray3[2] - numArray3[1];
                    double num27 = num25 * num25 + num26 * num26;
                    double num28 = 9999999.9;
                    int i11 = 2;
                    int ip;
                    double xm;
                    for (int i12 = 0; i12 <= kPnt; ++i12)
                    {
                        ip = 0;
                        if (i8 > 0)
                        {
                            for (int i13 = 1; i13 <= i8; ++i13)
                            {
                                if (nDop[i13] == nPnt[i12])
                                {
                                    ++ip;
                                    break;
                                }
                            }
                        }
                        if (ip <= 0)
                        {
                            double num29 = xPnt[i12] - numArray2[1];
                            double num30 = yPnt[i12] - numArray3[1];
                            double d1 = num29 * num29 + num30 * num30;
                            double num31 = Math.Sqrt(d1);
                            if (num31 >= 0.003)
                            {
                                double num32 = xPnt[i12] - numArray2[2];
                                double num33 = yPnt[i12] - numArray3[2];
                                double d2 = num32 * num32 + num33 * num33;
                                double num34 = Math.Sqrt(d2);
                                if (num34 >= 0.003 && num31 <= num8 && num34 <= num8)
                                {
                                    ip = 1;
                                    xm = 0.0;
                                    ym = 0.0;
                                    TwoLine(numArray2[1], numArray3[1], xh, y3, xPnt[i12], yPnt[i12], xk, y4, out xm, out ym, ref ip);
                                    if (xm == 0.0 || xm > num23)
                                    {
                                        ip = 1;
                                        xm = 0.0;
                                        ym = 0.0;
                                        TwoLine(numArray2[2], numArray3[2], xh, y3, xPnt[i12], yPnt[i12], xk, y4, out xm, out ym, ref ip);
                                        if (xm == 0.0 || xm > num23)
                                        {
                                            double num35 = (d1 + d2 - num27) / (2.0 * num31 * num34);
                                            if (num35 < num28)
                                            {
                                                num28 = num35;
                                                i11 = 3;
                                                numArray1[i11] = nPnt[i12];
                                                numArray2[i11] = xPnt[i12];
                                                numArray3[i11] = yPnt[i12];
                                                numArray4[i11] = zPnt[i12];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (i11 >= 3)
                    {
                        int i14 = i8 + 1;
                        nDop[i14] = numArray1[1];
                        i8 = i14 + 1;
                        nDop[i8] = numArray1[2];
                        int i15 = 4;
                        numArray1[i15] = numArray1[1];
                        numArray2[i15] = numArray2[1];
                        numArray3[i15] = numArray3[1];
                        numArray4[i15] = numArray4[1];
                        for (int i16 = 1; i16 <= i15; ++i16)
                        {
                            if (i7 > num2)
                            {
                                int num36 = (int)MessageBox.Show("Индекс массива BorderX");
                                return;
                            }
                            ++i7;
                            nTin[i7] = numArray1[i16];
                            xTin[i7] = numArray2[i16];
                            yTin[i7] = numArray3[i16];
                            zTin[i7] = numArray4[i16];
                        }
                        int num37 = numArray1[1];
                        double x1_1 = numArray2[1];
                        double y1_1 = numArray3[1];
                        double num38 = numArray4[1];
                        int num39 = numArray1[2];
                        double x1_2 = numArray2[2];
                        double y1_2 = numArray3[2];
                        double num40 = numArray4[2];
                        ip = 1;
                        xm = 0.0;
                        ym = 0.0;
                        TwoLine(x1_1, y1_1, x3, y3, numArray2[3], numArray3[3], x4, y4, out xm, out ym, ref ip);
                        if (xm < x4)
                        {
                            if (xm != 0.0 && ym != 0.0)
                            {
                                if (xm > num23)
                                {
                                    num23 = xm;
                                    numArray1[1] = num37;
                                    numArray2[1] = x1_1;
                                    numArray3[1] = y1_1;
                                    numArray4[1] = num38;
                                    numArray1[2] = numArray1[3];
                                    numArray2[2] = numArray2[3];
                                    numArray3[2] = numArray3[3];
                                }
                            }
                            else
                            {
                                ip = 1;
                                xm = 0.0;
                                ym = 0.0;
                                TwoLine(x1_2, y1_2, x3, y3, numArray2[3], numArray3[3], x4, y4, out xm, out ym, ref ip);
                                if (xm < x4)
                                {
                                    if (xm != 0.0 && ym != 0.0 && xm > num23)
                                    {
                                        num23 = xm;
                                        numArray1[1] = num39;
                                        numArray2[1] = x1_2;
                                        numArray3[1] = y1_2;
                                        numArray4[1] = num40;
                                        numArray1[2] = numArray1[3];
                                        numArray2[2] = numArray2[3];
                                        numArray3[2] = numArray3[3];
                                        numArray4[2] = numArray4[3];
                                    }
                                }
                                else
                                    break;
                            }
                        }
                        else
                            break;
                    }
                    else
                        break;
                }
            }
            kTin = i7;
        }

        public static void TriangRemove(
          int kBord,
          double[] xBord,
          double[] yBord,
          ref int kTre,
          ref int[] nTre,
          ref double[] xTre,
          ref double[] yTre,
          ref double[] zTre,
          int[] nDop1,
          int[] nDop2,
          double[] xDop,
          double[] yDop)
        {
            int num1 = kTre / 4;
            int i1 = -3;
            int num2 = 0;
            int i2 = 0;
            for (int i3 = 1; i3 <= num1; ++i3)
            {
                i1 += 4;
                double xt = (xTre[i1] + xTre[i1 + 1] + xTre[i1 + 2]) / 3.0;
                double yt = (yTre[i1] + yTre[i1 + 1] + yTre[i1 + 2]) / 3.0;
                ++i2;
                nDop1[i2] = i1;
                xDop[i2] = xt;
                yDop[i2] = yt;
                if (in_out(kBord, ref xBord, ref yBord, xt, yt) == 0)
                {
                    ++num2;
                    nTre[i1] = 0;
                    nTre[i1 + 1] = 0;
                    nTre[i1 + 2] = 0;
                    nTre[i1 + 3] = 0;
                }
            }
            int i4 = 0;
            for (int i5 = 1; i5 < i2; ++i5)
            {
                if (xDop[i5] != 0.0 || yDop[i5] != 0.0)
                {
                    for (int i6 = i5 + 1; i6 <= i2; ++i6)
                    {
                        if (xDop[i6] != 0.0 || yDop[i6] != 0.0)
                        {
                            double num3 = xDop[i5] - xDop[i6];
                            double num4 = yDop[i5] - yDop[i6];
                            if (Math.Sqrt(num3 * num3 + num4 * num4) < 0.003)
                            {
                                ++i4;
                                nDop2[i4] = nDop1[i6];
                                xDop[i6] = 0.0;
                                yDop[i6] = 0.0;
                            }
                        }
                    }
                }
            }
            if (num2 == 0 && i4 == 0)
                return;
            if (i4 > 0)
            {
                int i7 = -3;
                for (int i8 = 1; i8 <= num1; ++i8)
                {
                    i7 += 4;
                    int num5 = 0;
                    for (int i9 = 1; i9 <= i4; ++i9)
                    {
                        if (nDop2[i9] == i7)
                        {
                            ++num5;
                            break;
                        }
                    }
                    if (num5 > 0)
                    {
                        ++num2;
                        nTre[i7] = 0;
                        nTre[i7 + 1] = 0;
                        nTre[i7 + 2] = 0;
                        nTre[i7 + 3] = 0;
                    }
                }
            }
            int i10 = 0;
            int i11 = -3;
            for (int i12 = 1; i12 <= num1; ++i12)
            {
                i11 += 4;
                if (nTre[i11] != 0 || nTre[i11 + 1] != 0 || nTre[i11 + 2] != 0 || nTre[i11 + 3] != 0)
                {
                    int i13 = i10 + 1;
                    nTre[i13] = nTre[i11];
                    xTre[i13] = xTre[i11];
                    yTre[i13] = yTre[i11];
                    zTre[i13] = zTre[i11];
                    int i14 = i13 + 1;
                    nTre[i14] = nTre[i11 + 1];
                    xTre[i14] = xTre[i11 + 1];
                    yTre[i14] = yTre[i11 + 1];
                    zTre[i14] = zTre[i11 + 1];
                    int i15 = i14 + 1;
                    nTre[i15] = nTre[i11 + 2];
                    xTre[i15] = xTre[i11 + 2];
                    yTre[i15] = yTre[i11 + 2];
                    zTre[i15] = zTre[i11 + 2];
                    i10 = i15 + 1;
                    nTre[i10] = nTre[i11 + 3];
                    xTre[i10] = xTre[i11 + 3];
                    yTre[i10] = yTre[i11 + 3];
                    zTre[i10] = zTre[i11 + 3];
                }
            }
            kTre = i10;
        }

        public static void DivideArea(
          int kBord,
          double[] xBord,
          double[] yBord,
          int kPnt,
          int[] nPnt,
          double[] xPnt,
          double[] yPnt,
          double[] zPnt,
          out int kPart,
          double[] xPart1,
          double[] yPart1,
          double[] xPart2,
          double[] yPart2,
          int[] kPart1,
          int[] kPart2,
          int[] nPart,
          int[] nTch,
          double[] xTch,
          double[] yTch,
          double[] zTch,
          out int kTin,
          int[] nTin,
          double[] xTin,
          double[] yTin,
          double[] zTin,
          int[] nTre,
          double[] xTre,
          double[] yTre,
          double[] zTre,
          int[] nt1,
          int[] nt2,
          int[] nt,
          double[] xt,
          double[] yt,
          double[] zt,
          double[] xAxis,
          double[] yAxis,
          int[] ktt,
          int[] kt1,
          int[] kt2,
          double[] xDop,
          double[] yDop,
          StatusBarPanel panel)
        {
            int[] np1 = new int[200];
            double[] numArray1 = new double[200];
            double[] numArray2 = new double[200];
            double[] zp1 = new double[200];
            int[] np2 = new int[200];
            double[] numArray3 = new double[200];
            double[] numArray4 = new double[200];
            double[] zp2 = new double[200];
            double[] numArray5 = new double[200];
            double[] numArray6 = new double[200];
            double[] x = new double[5];
            double[] y = new double[5];
            double[] xs1 = new double[200];
            double[] ys1 = new double[200];
            double[] xs2 = new double[200];
            double[] ys2 = new double[200];
            double[] xs = new double[200];
            double[] ys = new double[200];
            int num1 = 60;
            kPart = 0;
            kTin = 0;
            if (kPnt < 5)
                return;
            int kArray = 999999;
            intArray(nTin, ref kArray);
            doubleArray(xTin, ref kArray);
            doubleArray(yTin, ref kArray);
            doubleArray(zTin, ref kArray);
            intArray(nTre, ref kArray);
            doubleArray(xTre, ref kArray);
            doubleArray(yTre, ref kArray);
            doubleArray(zTre, ref kArray);
            int num2 = kArray - 4;
            panel.Text = "Wait.....First Sorting ";
            double sArea;
            PolyArea(kBord, xBord, yBord, out sArea);
            double num3 = Math.Sqrt((double)num1 * sArea / (double)kPnt);
            for (int i1 = 0; i1 < kPnt; ++i1)
            {
                for (int i2 = i1 + 1; i2 <= kPnt; ++i2)
                {
                    if (yPnt[i1] > yPnt[i2])
                    {
                        int num4 = nPnt[i1];
                        double num5 = xPnt[i1];
                        double num6 = yPnt[i1];
                        double num7 = zPnt[i1];
                        nPnt[i1] = nPnt[i2];
                        xPnt[i1] = xPnt[i2];
                        yPnt[i1] = yPnt[i2];
                        zPnt[i1] = zPnt[i2];
                        nPnt[i2] = num4;
                        xPnt[i2] = num5;
                        yPnt[i2] = num6;
                        zPnt[i2] = num7;
                    }
                }
            }
            double num8 = yPnt[0] + num3;
            for (int i = 0; i < kPnt; ++i)
            {
                int num9 = i + 1;
                nPnt[i] = num9;
            }
            double num10 = yPnt[0] - 1.0;
            double num11 = yPnt[kPnt] + 1.0;
            double num12 = 9999999.9;
            double num13 = -9999999.9;
            for (int i = 0; i <= kPnt; ++i)
            {
                if (num12 > xPnt[i])
                    num12 = xPnt[i];
                if (num13 < xPnt[i])
                    num13 = xPnt[i];
            }
            double num14 = num12 - 1.0;
            double num15 = num13 + 1.0;
            panel.Text = "Подождите.....Вторая сортировка ";
            int i3 = 0;
            int i4 = 0;
            int i5 = 1;
            yAxis[i5] = num10;
            if (kPnt <= 200)
            {
                int i6 = kPnt / 2 - 1;
                double num16 = 0.5 * (yPnt[i6] + yPnt[i6 + 1]);
                for (int i7 = 1; i7 < kPnt; ++i7)
                {
                    int num17 = 0;
                    for (int i8 = i6; i8 < kPnt; ++i8)
                    {
                        double num18 = yPnt[i8 + 1] - yPnt[i8];
                        if (num18 > 0.008)
                        {
                            num16 = 0.5 * (yPnt[i8] + yPnt[i8 + 1]);
                            break;
                        }
                        if (num18 < 0.003)
                            ++num17;
                    }
                    if (num17 == 0)
                        break;
                }
                int i9 = i5 + 1;
                yAxis[i9] = num16;
                int kPnt1 = -1;
                for (int i10 = 0; i10 <= kPnt; ++i10)
                {
                    if (yPnt[i10] > yAxis[i9 - 1])
                    {
                        ++kPnt1;
                        nt[kPnt1] = nPnt[i10];
                        xt[kPnt1] = xPnt[i10];
                        yt[kPnt1] = yPnt[i10];
                        zt[kPnt1] = zPnt[i10];
                    }
                }
                double xh = num14;
                double yh = num16;
                double xk = num15;
                double yk = num16;
                panel.Text = "Подождите.....Третья сортировка ";
                int kTin1;
                BorderX(xh, yh, xk, yk, kBord, xBord, yBord, kPnt1, nt, xt, yt, zt, out kTin1, nTre, xTre, yTre, zTre, nt1, nt2, xAxis);
                if (kTin1 == 0)
                    return;
                TriangRemove(kBord, xBord, yBord, ref kTin1, ref nTre, ref xTre, ref yTre, ref zTre, nt1, nt2, xDop, yDop);
                int i11 = i4 + 1;
                ktt[i11] = kTin1;
                for (int i12 = 1; i12 <= kTin1; ++i12)
                {
                    ++kTin;
                    nTin[kTin] = nTre[i12];
                    xTin[kTin] = xTre[i12];
                    yTin[kTin] = yTre[i12];
                    zTin[kTin] = zTre[i12];
                    if (kTin > num2)
                    {
                        int num19 = (int)MessageBox.Show("Индекс массива DivideArea");
                        return;
                    }
                }
                int i13 = 3;
                yAxis[i13] = num11;
                kt1[1] = 1;
                kt2[1] = ktt[1];
                for (int i14 = 1; i14 <= 2; ++i14)
                {
                    double num20 = num14;
                    double num21 = num15;
                    if (i14 == 1)
                    {
                        yh = num10;
                        yk = num16;
                    }
                    if (i14 == 2)
                    {
                        yh = num16;
                        yk = num11;
                    }
                    int num22 = 0;
                    for (int i15 = 0; i15 <= kPnt1; ++i15)
                    {
                        if (yt[i15] > yh && yt[i15] < yk)
                        {
                            ++num22;
                            ++i3;
                            nTch[i3] = nt[i15];
                            xTch[i3] = xt[i15];
                            yTch[i3] = yt[i15];
                            zTch[i3] = zt[i15];
                        }
                    }
                    ++kPart;
                    nPart[kPart] = num22;
                    xPart1[kPart] = num20;
                    yPart1[kPart] = yh;
                    xPart2[kPart] = num21;
                    yPart2[kPart] = yk;
                }
                kPart1[1] = 1;
                kPart2[1] = nPart[1];
                kPart1[2] = kPart2[1] + 1;
                kPart2[2] = kPart2[1] + nPart[2];
            }
            else
            {
                double ym = yPnt[0];
                do
                {
                    ym += num3;
                    ++i5;
                    yAxis[i5] = ym;
                }
                while (ym < yPnt[kPnt]);
                yAxis[i5] = num11;
                int num23 = 0;
                for (int i16 = 0; i16 < kPnt && yPnt[i16] <= yAxis[i5 - 1]; ++i16)
                    ++num23;
                if (kPnt - num23 < 5)
                {
                    --i5;
                    yAxis[i5] = num11;
                }
                for (int i17 = 2; i17 < i5; ++i17)
                {
                    double yAxi1 = yAxis[i17 - 1];
                    double yAxi2 = yAxis[i17 + 1];
                    ym = yAxis[i17];
                    for (int i18 = 1; i18 < kPnt; ++i18)
                    {
                        if (yPnt[i18] > yAxi1 && yPnt[i18] < yAxi2)
                        {
                            double num24 = Math.Abs(yPnt[i18] - ym);
                            if (num24 <= 0.003)
                            {
                                if (num24 < 0.003)
                                {
                                    if (num24 >= 0.0)
                                        yPnt[i18] = ym + 1.0 / 400.0;
                                    if (num24 < 0.0)
                                        yPnt[i18] = ym - 1.0 / 400.0;
                                }
                            }
                            else
                                break;
                        }
                    }
                }
                int kTin2;
                for (int i19 = 2; i19 < i5; ++i19)
                {
                    double yAxi3 = yAxis[i19 - 1];
                    double yAxi4 = yAxis[i19 + 1];
                    ym = yAxis[i19];
                    int kPnt2 = -1;
                    for (int i20 = 0; i20 <= kPnt && yPnt[i20] <= yAxi4; ++i20)
                    {
                        if (yPnt[i20] > yAxi3 && yPnt[i20] < yAxi4)
                        {
                            ++kPnt2;
                            nt[kPnt2] = nPnt[i20];
                            xt[kPnt2] = xPnt[i20];
                            yt[kPnt2] = yPnt[i20];
                            zt[kPnt2] = zPnt[i20];
                        }
                    }
                    double xh = num14;
                    double yh = ym;
                    double xk = num15;
                    double yk = ym;
                    panel.Text = "Подождите..... Сортировка точек " + string.Format("{0}", (object)i19);
                    BorderX(xh, yh, xk, yk, kBord, xBord, yBord, kPnt2, nt, xt, yt, zt, out kTin2, nTre, xTre, yTre, zTre, nt1, nt2, xAxis);
                    if (kTin2 != 0)
                    {
                        TriangRemove(kBord, xBord, yBord, ref kTin2, ref nTre, ref xTre, ref yTre, ref zTre, nt1, nt2, xDop, yDop);
                        ++i4;
                        ktt[i4] = kTin2;
                        for (int i21 = 1; i21 <= kTin2; ++i21)
                        {
                            ++kTin;
                            nTin[kTin] = nTre[i21];
                            xTin[kTin] = xTre[i21];
                            yTin[kTin] = yTre[i21];
                            zTin[kTin] = zTre[i21];
                            if (kTin > num2)
                            {
                                int num25 = (int)MessageBox.Show("Индекс массива DivideArea");
                                return;
                            }
                        }
                    }
                }
                kt1[1] = 1;
                kt2[1] = ktt[1];
                if (i4 > 1)
                {
                    for (int i22 = 2; i22 <= i4; ++i22)
                    {
                        kt1[i22] = kt2[i22 - 1] + 1;
                        kt2[i22] = kt2[i22 - 1] + ktt[i22];
                    }
                }
                for (int i23 = 2; i23 <= i5; ++i23)
                {
                    int kPnt3 = -1;
                    double num26 = 9999999.9;
                    double num27 = -9999999.9;
                    for (int i24 = 0; i24 <= kPnt; ++i24)
                    {
                        if (yPnt[i24] > yAxis[i23 - 1] && yPnt[i24] < yAxis[i23])
                        {
                            ++kPnt3;
                            nt[kPnt3] = nPnt[i24];
                            xt[kPnt3] = xPnt[i24];
                            yt[kPnt3] = yPnt[i24];
                            zt[kPnt3] = zPnt[i24];
                            if (xPnt[i24] < num26)
                                num26 = xPnt[i24];
                            if (xPnt[i24] > num27)
                                num27 = xPnt[i24];
                        }
                    }
                    double num28 = num26 - 1.0;
                    double num29 = num27 + 1.0;
                    int num30 = kPnt3 / num1;
                    if (kPnt3 - num30 * num1 > num1 / 2)
                        ++num30;
                    if (num30 == 0 || num30 == 1)
                    {
                        int num31 = 0;
                        for (int i25 = 0; i25 <= kPnt3; ++i25)
                        {
                            ++num31;
                            ++i3;
                            nTch[i3] = nt[i25];
                            xTch[i3] = xt[i25];
                            yTch[i3] = yt[i25];
                            zTch[i3] = zt[i25];
                        }
                        ++kPart;
                        nPart[kPart] = num31;
                        xPart1[kPart] = num28;
                        yPart1[kPart] = yAxis[i23 - 1];
                        xPart2[kPart] = num29;
                        yPart2[kPart] = yAxis[i23];
                    }
                    else
                    {
                        for (int i26 = 0; i26 < kPnt3; ++i26)
                        {
                            for (int i27 = i26 + 1; i27 <= kPnt3; ++i27)
                            {
                                if (xt[i26] > xt[i27])
                                {
                                    int num32 = nt[i26];
                                    double num33 = xt[i26];
                                    ym = yt[i26];
                                    double num34 = zt[i26];
                                    nt[i26] = nt[i27];
                                    xt[i26] = xt[i27];
                                    yt[i26] = yt[i27];
                                    zt[i26] = zt[i27];
                                    nt[i27] = num32;
                                    xt[i27] = num33;
                                    yt[i27] = ym;
                                    zt[i27] = num34;
                                }
                            }
                        }
                        x[0] = num14;
                        y[0] = yAxis[i23 - 1];
                        x[1] = num14;
                        y[1] = yAxis[i23];
                        x[2] = num15;
                        y[2] = yAxis[i23];
                        x[3] = num15;
                        y[3] = yAxis[i23 - 1];
                        x[4] = x[0];
                        y[4] = y[0];
                        int i28 = 0;
                        for (int i29 = 1; i29 <= kBord; ++i29)
                        {
                            int num35 = in_out(4, ref x, ref y, xBord[i29 - 1], yBord[i29 - 1]);
                            int num36 = in_out(4, ref x, ref y, xBord[i29], yBord[i29]);
                            if (num35 > 0 || num36 > 0)
                            {
                                ++i28;
                                nt2[i28] = i29;
                            }
                        }
                        double num37 = (num29 - num28) / (double)num30;
                        int num38 = kPnt3 / num30;
                        double num39 = num28;
                        int i30 = 0;
                        double num40;
                        double num41 = num40 = 0.0;
                        for (int i31 = 1; i31 <= num30; ++i31)
                        {
                            double yAxi5 = yAxis[i23 - 1];
                            double yAxi6 = yAxis[i23];
                            if (i31 == num30)
                            {
                                double num42 = num39;
                                double num43 = num29;
                                int num44 = 0;
                                for (int i32 = 0; i32 <= kPnt3; ++i32)
                                {
                                    if (xt[i32] > num42 && xt[i32] < num43)
                                    {
                                        ++num44;
                                        ++i3;
                                        nTch[i3] = nt[i32];
                                        xTch[i3] = xt[i32];
                                        yTch[i3] = yt[i32];
                                        zTch[i3] = zt[i32];
                                    }
                                }
                                ++kPart;
                                nPart[kPart] = num44;
                                xPart1[kPart] = num42;
                                yPart1[kPart] = yAxi5;
                                xPart2[kPart] = num43;
                                yPart2[kPart] = yAxi6;
                                break;
                            }
                            int i33 = 0;
                            int i34 = 0;
                            int kSect = 0;
                            i30 += num38;
                            double xm = 0.5 * (xt[i30] + xt[i30 + 1]);
                            for (int i35 = 1; i35 < kPnt3; ++i35)
                            {
                                int num45 = 0;
                                for (int i36 = i30; i36 < kPnt3; ++i36)
                                {
                                    double num46 = xt[i36 + 1] - xt[i36];
                                    if (num46 > 0.008)
                                    {
                                        xm = 0.5 * (xt[i36] + xt[i36 + 1]);
                                        break;
                                    }
                                    if (num46 < 0.003)
                                        ++num45;
                                }
                                if (num45 == 0)
                                    break;
                            }
                            double xh = num39;
                            num39 = xm;
                            double num47 = xm;
                            if (i28 > 0)
                            {
                                for (int i37 = 1; i37 <= i28; ++i37)
                                {
                                    int i38 = nt2[i37];
                                    int i39 = i38 - 1;
                                    double x3 = xBord[i39];
                                    double y3 = yBord[i39];
                                    double x4 = xBord[i38];
                                    double y4 = yBord[i38];
                                    int ip = 1;
                                    TwoLine(num47, yAxi5, x3, y3, num47, yAxi6, x4, y4, out xm, out ym, ref ip);
                                    if (xm != 0.0 && ym != 0.0)
                                    {
                                        ++i33;
                                        xs[i33] = xm;
                                        ys[i33] = ym;
                                        xs1[i33] = x3;
                                        ys1[i33] = y3;
                                        xs2[i33] = x4;
                                        ys2[i33] = y4;
                                    }
                                }
                            }
                            if (i23 == 2)
                            {
                                int num48 = kt1[i23 - 1];
                                int num49 = kt2[i23 - 1];
                                i34 = 0;
                                if (i33 > 0)
                                {
                                    double num50 = 0.0;
                                    int i40 = 0;
                                    for (int i41 = 1; i41 <= i33; ++i41)
                                    {
                                        double num51 = ys[i41] - yAxi5;
                                        if (num51 > num50)
                                        {
                                            num50 = num51;
                                            i40 = i41;
                                        }
                                    }
                                    ++i34;
                                    numArray5[i34] = xs[i40];
                                    numArray6[i34] = ys[i40];
                                    numArray1[i34] = xs1[i40];
                                    numArray2[i34] = ys1[i40];
                                    numArray3[i34] = xs2[i40];
                                    numArray4[i34] = ys2[i40];
                                }
                                kTin2 = 0;
                                for (int i42 = num48; i42 <= num49; ++i42)
                                {
                                    ++kTin2;
                                    nTre[kTin2] = nTin[i42];
                                    xTre[kTin2] = xTin[i42];
                                    yTre[kTin2] = yTin[i42];
                                    zTre[kTin2] = zTin[i42];
                                }
                                FindSection(num47, yAxi5, num47, yAxi6, kTin2, xTre, yTre, out kSect, xs, ys, xs1, ys1, xs2, ys2);
                                if (kSect > 0)
                                {
                                    double num52 = 9999999.9;
                                    int i43 = 0;
                                    for (int i44 = 1; i44 <= kSect; ++i44)
                                    {
                                        double num53 = ys[i44] - yAxi5;
                                        if (num53 < num52)
                                        {
                                            num52 = num53;
                                            i43 = i44;
                                        }
                                    }
                                    ++i34;
                                    numArray5[i34] = xs[i43];
                                    numArray6[i34] = ys[i43];
                                    numArray1[i34] = xs1[i43];
                                    numArray2[i34] = ys1[i43];
                                    numArray3[i34] = xs2[i43];
                                    numArray4[i34] = ys2[i43];
                                }
                            }
                            if (i23 > 2 && i23 < i5)
                            {
                                int num54 = kt1[i23 - 1];
                                int num55 = kt2[i23 - 1];
                                int num56 = kt1[i23 - 2];
                                int num57 = kt2[i23 - 2];
                                i34 = 0;
                                kTin2 = 0;
                                for (int i45 = num56; i45 <= num57; ++i45)
                                {
                                    ++kTin2;
                                    nTre[kTin2] = nTin[i45];
                                    xTre[kTin2] = xTin[i45];
                                    yTre[kTin2] = yTin[i45];
                                    zTre[kTin2] = zTin[i45];
                                }
                                FindSection(num47, yAxi5, num47, yAxi6, kTin2, xTre, yTre, out kSect, numArray5, numArray6, numArray1, numArray2, numArray3, numArray4);
                                if (kSect > 0)
                                {
                                    double num58 = 0.0;
                                    int i46 = 0;
                                    for (int i47 = 1; i47 <= kSect; ++i47)
                                    {
                                        double num59 = numArray6[i47] - yAxi5;
                                        if (num59 > num58)
                                        {
                                            num58 = num59;
                                            i46 = i47;
                                        }
                                    }
                                    ++i34;
                                    numArray5[i34] = numArray5[i46];
                                    numArray6[i34] = numArray6[i46];
                                    numArray1[i34] = numArray1[i46];
                                    numArray2[i34] = numArray2[i46];
                                    numArray3[i34] = numArray3[i46];
                                    numArray4[i34] = numArray4[i46];
                                }
                                kTin2 = 0;
                                for (int i48 = num54; i48 <= num55; ++i48)
                                {
                                    ++kTin2;
                                    nTre[kTin2] = nTin[i48];
                                    xTre[kTin2] = xTin[i48];
                                    yTre[kTin2] = yTin[i48];
                                    zTre[kTin2] = zTin[i48];
                                }
                                FindSection(num47, yAxi5, num47, yAxi6, kTin2, xTre, yTre, out kSect, xs, ys, xs1, ys1, xs2, ys2);
                                if (kSect > 0)
                                {
                                    double num60 = 9999999.9;
                                    int i49 = 0;
                                    for (int i50 = 1; i50 <= kSect; ++i50)
                                    {
                                        double num61 = ys[i50] - yAxi5;
                                        if (num61 < num60)
                                        {
                                            num60 = num61;
                                            i49 = i50;
                                        }
                                    }
                                    ++i34;
                                    numArray5[i34] = xs[i49];
                                    numArray6[i34] = ys[i49];
                                    numArray1[i34] = xs1[i49];
                                    numArray2[i34] = ys1[i49];
                                    numArray3[i34] = xs2[i49];
                                    numArray4[i34] = ys2[i49];
                                }
                            }
                            if (i23 == i5)
                            {
                                int num62 = kt1[i23 - 2];
                                int num63 = kt2[i23 - 2];
                                i34 = 0;
                                kTin2 = 0;
                                for (int i51 = num62; i51 <= num63; ++i51)
                                {
                                    ++kTin2;
                                    nTre[kTin2] = nTin[i51];
                                    xTre[kTin2] = xTin[i51];
                                    yTre[kTin2] = yTin[i51];
                                    zTre[kTin2] = zTin[i51];
                                }
                                FindSection(num47, yAxi5, num47, yAxi6, kTin2, xTre, yTre, out kSect, numArray5, numArray6, numArray1, numArray2, numArray3, numArray4);
                                if (kSect > 0)
                                {
                                    double num64 = 0.0;
                                    int i52 = 0;
                                    for (int i53 = 1; i53 <= kSect; ++i53)
                                    {
                                        double num65 = numArray6[i53] - yAxi5;
                                        if (num65 > num64)
                                        {
                                            num64 = num65;
                                            i52 = i53;
                                        }
                                    }
                                    ++i34;
                                    numArray5[i34] = numArray5[i52];
                                    numArray6[i34] = numArray6[i52];
                                    numArray1[i34] = numArray1[i52];
                                    numArray2[i34] = numArray2[i52];
                                    numArray3[i34] = numArray3[i52];
                                    numArray4[i34] = numArray4[i52];
                                }
                                if (i33 > 0)
                                {
                                    double num66 = 9999999.9;
                                    int i54 = 0;
                                    for (int i55 = 1; i55 <= i33; ++i55)
                                    {
                                        double num67 = ys[i55] - yAxi5;
                                        if (num67 < num66)
                                        {
                                            num66 = num67;
                                            i54 = i55;
                                        }
                                    }
                                    ++i34;
                                    numArray5[i34] = xs[i54];
                                    numArray6[i34] = ys[i54];
                                    numArray1[i34] = xs1[i54];
                                    numArray2[i34] = ys1[i54];
                                    numArray3[i34] = xs2[i54];
                                    numArray4[i34] = ys2[i54];
                                }
                            }
                            if (i34 == 1 && i33 > 0)
                            {
                                double num68 = xs[1];
                                ym = ys[1];
                                double num69 = xs1[1];
                                double num70 = ys1[1];
                                double num71 = xs2[1];
                                double num72 = ys2[1];
                                num37 = numArray5[1];
                                double num73 = numArray6[1];
                                if (ym > num73)
                                {
                                    ++i34;
                                    numArray5[i34] = num68;
                                    numArray6[i34] = ym;
                                    numArray1[i34] = num69;
                                    numArray2[i34] = num70;
                                    numArray3[i34] = num71;
                                    numArray4[i34] = num72;
                                }
                                if (num73 > ym)
                                {
                                    ++i34;
                                    xs[i34] = numArray5[1];
                                    ys[i34] = numArray6[1];
                                    xs1[i34] = numArray1[1];
                                    ys1[i34] = numArray2[1];
                                    xs2[i34] = numArray3[1];
                                    ys2[i34] = numArray4[1];
                                    for (int i56 = 1; i56 <= i34; ++i56)
                                    {
                                        numArray5[i56] = xs[i56];
                                        numArray6[i56] = ys[i56];
                                        numArray1[i56] = xs1[i56];
                                        numArray2[i56] = ys1[i56];
                                        numArray3[i56] = xs2[i56];
                                        numArray4[i56] = ys2[i56];
                                    }
                                }
                            }
                            if (i34 >= 2)
                            {
                                int kp = i34;
                                for (int i57 = 1; i57 <= kp; ++i57)
                                {
                                    for (int i58 = 0; i58 <= kPnt3; ++i58)
                                    {
                                        double num74 = numArray1[i57] - xt[i58];
                                        double num75 = numArray2[i57] - yt[i58];
                                        if (Math.Sqrt(num74 * num74 + num75 * num75) < 0.003)
                                        {
                                            np1[i57] = nt[i58];
                                            zp1[i57] = zt[i58];
                                        }
                                        double num76 = numArray3[i57] - xt[i58];
                                        double num77 = numArray4[i57] - yt[i58];
                                        if (Math.Sqrt(num76 * num76 + num77 * num77) < 0.003)
                                        {
                                            np2[i57] = nt[i58];
                                            zp2[i57] = zt[i58];
                                        }
                                    }
                                }
                                if (Math.Abs(numArray6[1] - numArray6[2]) >= 0.003 && numArray6[1] <= numArray6[2])
                                {
                                    panel.Text = "Подождите..... Сортировка точек " + string.Format("{0}", (object)i23);
                                    BorderY(xh, yAxi5, num47, yAxi6, kPnt3, nt, xt, yt, zt, out kTin2, nTre, xTre, yTre, zTre, nt1, kp, numArray5, numArray6, np1, numArray1, numArray2, zp1, np2, numArray3, numArray4, zp2);
                                    if (kTin2 > 0)
                                    {
                                        for (int i59 = 1; i59 <= kTin2; ++i59)
                                        {
                                            ++kTin;
                                            nTin[kTin] = nTre[i59];
                                            xTin[kTin] = xTre[i59];
                                            yTin[kTin] = yTre[i59];
                                            zTin[kTin] = zTre[i59];
                                            if (kTin > num2)
                                            {
                                                int num78 = (int)MessageBox.Show("Индекс массива DivideArea");
                                                return;
                                            }
                                        }
                                    }
                                    int num79 = 0;
                                    for (int i60 = 0; i60 <= kPnt3; ++i60)
                                    {
                                        if (xt[i60] > xh && xt[i60] < num47)
                                        {
                                            ++num79;
                                            ++i3;
                                            nTch[i3] = nt[i60];
                                            xTch[i3] = xt[i60];
                                            yTch[i3] = yt[i60];
                                            zTch[i3] = zt[i60];
                                        }
                                    }
                                    ++kPart;
                                    nPart[kPart] = num79;
                                    xPart1[kPart] = xh;
                                    yPart1[kPart] = yAxi5;
                                    xPart2[kPart] = num47;
                                    yPart2[kPart] = yAxi6;
                                }
                            }
                        }
                    }
                }
                kPart1[1] = 1;
                kPart2[1] = nPart[1];
                if (kPart <= 1)
                    return;
                for (int i61 = 2; i61 <= kPart; ++i61)
                {
                    kPart1[i61] = kPart2[i61 - 1] + 1;
                    kPart2[i61] = kPart2[i61 - 1] + nPart[i61];
                }
            }
        }

        public static void TinInBorder(
          int kBord,
          double[] xBord,
          double[] yBord,
          ref int kTin,
          int[] nTin,
          double[] xTin,
          double[] yTin,
          double[] zTin)
        {
            int[] numArray1 = new int[10];
            double[] numArray2 = new double[10];
            double[] numArray3 = new double[10];
            double[] numArray4 = new double[10];
            int i1 = 0;
            int num = kTin / 4;
            int i2 = -3;
            for (int i3 = 1; i3 <= num; ++i3)
            {
                i2 += 4;
                numArray1[1] = nTin[i2];
                numArray2[1] = xTin[i2];
                numArray3[1] = yTin[i2];
                numArray4[1] = zTin[i2];
                numArray1[2] = nTin[i2 + 1];
                numArray2[2] = xTin[i2 + 1];
                numArray3[2] = yTin[i2 + 1];
                numArray4[2] = zTin[i2 + 1];
                numArray1[3] = nTin[i2 + 2];
                numArray2[3] = xTin[i2 + 2];
                numArray3[3] = yTin[i2 + 2];
                numArray4[3] = zTin[i2 + 2];
                numArray1[4] = nTin[i2];
                numArray2[4] = xTin[i2];
                numArray3[4] = yTin[i2];
                numArray4[4] = zTin[i2];
                double xt = (numArray2[1] + numArray2[2] + numArray2[3]) / 3.0;
                double yt = (numArray3[1] + numArray3[2] + numArray3[3]) / 3.0;
                if (in_out(kBord, ref xBord, ref yBord, xt, yt) != 0)
                {
                    for (int i4 = 1; i4 <= 4; ++i4)
                    {
                        ++i1;
                        nTin[i1] = numArray1[i4];
                        xTin[i1] = numArray2[i4];
                        yTin[i1] = numArray3[i4];
                        zTin[i1] = numArray4[i4];
                    }
                }
            }
            kTin = i1;
        }

        public static void TreArea(
          string fileAdd,
          int kSqu,
          double[] sqPntx1,
          double[] sqPnty1,
          double[] sqPntx2,
          double[] sqPnty2,
          int[] sqPntk1,
          int[] sqPntk2,
          int[] sqPntkt,
          int[] sqPntnt,
          double[] sqPntx,
          double[] sqPnty,
          double[] sqPntz,
          ref int ktin,
          ref int[] tPntnt,
          ref double[] tPntx,
          ref double[] tPnty,
          ref double[] tPntz,
          int[] nt,
          double[] xt,
          double[] yt,
          double[] zt,
          int[] ntr,
          double[] xtr,
          double[] ytr,
          double[] ztr,
          int[] nth,
          double[] xth,
          double[] yth,
          double[] zth,
          double[] tPntxc,
          double[] tPntyc,
          int[] ntk,
          double[] xtk,
          double[] ytk,
          double[] ztk,
          int[] ind,
          double[] xnd,
          double[] ynd,
          double[] znd,
          double[] xcs,
          double[] ycs,
          int[] ntd,
          double[] xtd,
          double[] ytd,
          double[] ztd,
          double[] xp1,
          double[] yp1,
          double[] xp2,
          double[] yp2,
          int kMaxTre,
          StatusBarPanel panel1)
        {
            int[] numArray1 = new int[10];
            double[] xg = new double[10];
            double[] yg = new double[10];
            double[] numArray2 = new double[10];
            double[] numArray3 = new double[10];
            double[] numArray4 = new double[10];
            int num1;
            int num2 = num1 = 0;
            int kti = 0;
            int num3 = 0;
            int num4 = sqPntk2[kSqu];
            Cursor.Current = Cursors.WaitCursor;
            if (File.Exists(fileAdd))
                File.Delete(fileAdd);
            FileStream output = new FileStream(fileAdd, FileMode.CreateNew);
            BinaryWriter binaryWriter = new BinaryWriter((Stream)output);
            binaryWriter.Write(kSqu);
            for (int i1 = 1; i1 <= kSqu; ++i1)
            {
                xg[0] = sqPntx1[i1];
                yg[0] = sqPnty1[i1];
                xg[1] = sqPntx1[i1];
                yg[1] = sqPnty2[i1];
                xg[2] = sqPntx2[i1];
                yg[2] = sqPnty2[i1];
                xg[3] = sqPntx2[i1];
                yg[3] = sqPnty1[i1];
                xg[4] = xg[0];
                yg[4] = yg[0];
                int kg = 4;
                int num5 = sqPntk1[i1];
                int num6 = sqPntk2[i1];
                int kt = 0;
                for (int i2 = num5; i2 <= num6; ++i2)
                {
                    ++kt;
                    nt[kt] = sqPntnt[i2];
                    xt[kt] = sqPntx[i2];
                    yt[kt] = sqPnty[i2];
                    zt[kt] = sqPntz[i2];
                }
                int num7 = ktin / 4;
                int i3 = -3;
                int ktin1 = 0;
                for (int i4 = 1; i4 <= num7; ++i4)
                {
                    i3 += 4;
                    numArray1[1] = tPntnt[i3];
                    numArray2[1] = tPntx[i3];
                    numArray3[1] = tPnty[i3];
                    numArray4[1] = tPntz[i3];
                    numArray1[2] = tPntnt[i3 + 1];
                    numArray2[2] = tPntx[i3 + 1];
                    numArray3[2] = tPnty[i3 + 1];
                    numArray4[2] = tPntz[i3 + 1];
                    numArray1[3] = tPntnt[i3 + 2];
                    numArray2[3] = tPntx[i3 + 2];
                    numArray3[3] = tPnty[i3 + 2];
                    numArray4[3] = tPntz[i3 + 2];
                    numArray1[4] = tPntnt[i3 + 3];
                    numArray2[4] = tPntx[i3 + 3];
                    numArray3[4] = tPnty[i3 + 3];
                    numArray4[4] = tPntz[i3 + 3];
                    int num8 = 4;
                    for (int i5 = 2; i5 <= num8; ++i5)
                    {
                        double x1 = numArray2[i5 - 1];
                        double y1 = numArray3[i5 - 1];
                        double x2 = numArray2[i5];
                        double y2 = numArray3[i5];
                        int num9 = 0;
                        for (int i6 = 1; i6 <= kg; ++i6)
                        {
                            double x3 = xg[i6 - 1];
                            double y3 = yg[i6 - 1];
                            double x4 = xg[i6];
                            double y4 = yg[i6];
                            int ip = 1;
                            double xm = 0.0;
                            double ym = 0.0;
                            TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip);
                            if (xm != 0.0 && ym != 0.0)
                            {
                                ++num9;
                                break;
                            }
                        }
                        if (num9 > 0)
                        {
                            for (int i7 = 1; i7 <= num8; ++i7)
                            {
                                ++ktin1;
                                ntr[ktin1] = numArray1[i7];
                                xtr[ktin1] = numArray2[i7];
                                ytr[ktin1] = numArray3[i7];
                                ztr[ktin1] = numArray4[i7];
                            }
                            break;
                        }
                    }
                }
                panel1.Text = "Подождите..Модель рельефа " + string.Format("{0}", (object)i1);
                SecondTre(kg, xg, yg, kt, nt, xt, yt, zt, ktin1, ntr, xtr, ytr, ztr, out kti, tPntxc, tPntyc, nth, xth, yth, zth, ntk, xtk, ytk, ztk, ind, xnd, ynd, znd, xcs, ycs, ntd, xtd, ytd, ztd, xp1, yp1, xp2, yp2, panel1);
                if (kti >= 1)
                {
                    binaryWriter.Write(kg);
                    for (int i8 = 0; i8 <= kg; ++i8)
                    {
                        binaryWriter.Write(xg[i8]);
                        binaryWriter.Write(yg[i8]);
                    }
                    binaryWriter.Write(kt);
                    if (kt > 0)
                    {
                        for (int i9 = 1; i9 <= kt; ++i9)
                        {
                            binaryWriter.Write(nt[i9]);
                            binaryWriter.Write(xt[i9]);
                            binaryWriter.Write(yt[i9]);
                            binaryWriter.Write(zt[i9]);
                        }
                    }
                    binaryWriter.Write(kti);
                    if (kti > 0)
                    {
                        for (int i10 = 1; i10 <= kti; ++i10)
                        {
                            ++num3;
                            binaryWriter.Write(ntr[i10]);
                            binaryWriter.Write(xtr[i10]);
                            binaryWriter.Write(ytr[i10]);
                            binaryWriter.Write(ztr[i10]);
                        }
                    }
                    if (num3 > kMaxTre)
                    {
                        int num10 = (int)MessageBox.Show("Достигнуто МАКСИМАЛЬНОЕ количество информации");
                        break;
                    }
                    if (num4 > 5000)
                    {
                        int num11 = num3 / 4;
                        panel1.Text = "Подождите..Начало = " + string.Format("{0}", (object)num11);
                    }
                }
            }
            binaryWriter.Close();
            output.Close();
            int i11 = 0;
            if (File.Exists(fileAdd))
            {
                FileStream input = new FileStream(fileAdd, FileMode.Open, FileAccess.Read);
                BinaryReader binaryReader = new BinaryReader((Stream)input);
                try
                {
                    kSqu = binaryReader.ReadInt32();
                    for (int i12 = 1; i12 <= kSqu; ++i12)
                    {
                        int num12 = binaryReader.ReadInt32();
                        for (int i13 = 0; i13 <= num12; ++i13)
                        {
                            xg[i13] = binaryReader.ReadDouble();
                            yg[i13] = binaryReader.ReadDouble();
                        }
                        int num13 = binaryReader.ReadInt32();
                        if (num13 > 0)
                        {
                            for (int i14 = 1; i14 <= num13; ++i14)
                            {
                                nt[i14] = binaryReader.ReadInt32();
                                xt[i14] = binaryReader.ReadDouble();
                                yt[i14] = binaryReader.ReadDouble();
                                zt[i14] = binaryReader.ReadDouble();
                            }
                        }
                        kti = binaryReader.ReadInt32();
                        if (kti > 0)
                        {
                            for (int i15 = 1; i15 <= kti; ++i15)
                            {
                                ntr[i15] = binaryReader.ReadInt32();
                                xtr[i15] = binaryReader.ReadDouble();
                                ytr[i15] = binaryReader.ReadDouble();
                                ztr[i15] = binaryReader.ReadDouble();
                            }
                            for (int i16 = 1; i16 <= kti; ++i16)
                            {
                                ++i11;
                                tPntnt[i11] = ntr[i16];
                                tPntx[i11] = xtr[i16];
                                tPnty[i11] = ytr[i16];
                                tPntz[i11] = ztr[i16];
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
                }
                finally
                {
                    input.Close();
                    binaryReader.Close();
                }
            }
            int num14 = i11 / 4;
            int i17 = -3;
            int i18 = 0;
            int i19 = 0;
            for (int i20 = 1; i20 <= num14; ++i20)
            {
                i17 += 4;
                double num15 = (tPntx[i17] + tPntx[i17 + 1] + tPntx[i17 + 2]) / 3.0;
                double num16 = (tPnty[i17] + tPnty[i17 + 1] + tPnty[i17 + 2]) / 3.0;
                int num17 = 0;
                if (i19 > 0)
                {
                    for (int i21 = 1; i21 <= i19; ++i21)
                    {
                        double num18 = tPntxc[i21] - num15;
                        double num19 = tPntyc[i21] - num16;
                        if (Math.Sqrt(num18 * num18 + num19 * num19) < 0.003)
                        {
                            ++num17;
                            break;
                        }
                    }
                }
                if (num17 <= 0)
                {
                    ++i19;
                    tPntxc[i19] = num15;
                    tPntyc[i19] = num16;
                    int i22 = i18 + 1;
                    tPntnt[i22] = tPntnt[i17];
                    tPntx[i22] = tPntx[i17];
                    tPnty[i22] = tPnty[i17];
                    tPntz[i22] = tPntz[i17];
                    int i23 = i22 + 1;
                    tPntnt[i23] = tPntnt[i17 + 1];
                    tPntx[i23] = tPntx[i17 + 1];
                    tPnty[i23] = tPnty[i17 + 1];
                    tPntz[i23] = tPntz[i17 + 1];
                    int i24 = i23 + 1;
                    tPntnt[i24] = tPntnt[i17 + 2];
                    tPntx[i24] = tPntx[i17 + 2];
                    tPnty[i24] = tPnty[i17 + 2];
                    tPntz[i24] = tPntz[i17 + 2];
                    i18 = i24 + 1;
                    tPntnt[i18] = tPntnt[i17 + 3];
                    tPntx[i18] = tPntx[i17 + 3];
                    tPnty[i18] = tPnty[i17 + 3];
                    tPntz[i18] = tPntz[i17 + 3];
                    if (num4 > 5000)
                    {
                        int num20 = i19 / 500;
                        if (i19 - num20 * 500 == 0)
                            panel1.Text = "Wait..Triangle = " + string.Format("{0}", (object)i19);
                    }
                }
            }
            ktin = i18;
        }

        public static void TriangleForm(
          ref int kTin,
          int[] nTin,
          double[] xTin,
          double[] yTin,
          double[] zTin,
          StatusBarPanel panel)
        {
            int[] numArray1 = new int[10];
            double[] numArray2 = new double[10];
            double[] numArray3 = new double[10];
            double[] numArray4 = new double[10];
            int[] numArray5 = new int[10];
            double[] numArray6 = new double[10];
            double[] numArray7 = new double[10];
            double[] numArray8 = new double[10];
            double num1 = 0.3;
            double num2 = 0.1;
            int i1;
            int i2 = i1 = 0;
            double num3;
            double num4 = num3 = 0.0;
            double ym = num3;
            double xm = num3;
            int num5;
            int num6 = num5 = 0;
            int num7 = num5;
            int num8 = num5;
            int num9 = num5;
            double y2;
            double x2 = y2 = 0.0;
            double num10;
            double y4 = num10 = 0.0;
            double x4 = num10;
            double y3 = num10;
            double x3 = num10;
            double num11;
            double num12 = num11 = 0.0;
            double num13 = num11;
            double num14 = num11;
            double num15 = num11;
            int num16 = 0;
            int num17 = 2;
            if (kTin > 20000)
                num17 = 1;
            for (int i3 = 1; i3 <= num17; ++i3)
            {
                int num18 = kTin / 4;
                int i4 = -3;
                int num19 = 0;
                for (int i5 = 1; i5 <= num18; ++i5)
                {
                    panel.Text = "Подождите... Коррекция треугольников-" + string.Format("{0}", (object)i5);
                    i4 += 4;
                    numArray1[1] = nTin[i4];
                    numArray2[1] = xTin[i4];
                    numArray3[1] = yTin[i4];
                    numArray4[1] = zTin[i4];
                    numArray1[2] = nTin[i4 + 1];
                    numArray2[2] = xTin[i4 + 1];
                    numArray3[2] = yTin[i4 + 1];
                    numArray4[2] = zTin[i4 + 1];
                    numArray1[3] = nTin[i4 + 2];
                    numArray2[3] = xTin[i4 + 2];
                    numArray3[3] = yTin[i4 + 2];
                    numArray4[3] = zTin[i4 + 2];
                    numArray1[4] = nTin[i4];
                    numArray2[4] = xTin[i4];
                    numArray3[4] = yTin[i4];
                    numArray4[4] = zTin[i4];
                    int i6 = i4;
                    for (int i7 = 2; i7 <= 4; ++i7)
                    {
                        double x1 = 0.5 * (numArray2[i7 - 1] + numArray2[i7]);
                        double y1 = 0.5 * (numArray3[i7 - 1] + numArray3[i7]);
                        int i8 = i7;
                        int i9 = -3;
                        int i10 = 0;
                        for (int i11 = 1; i11 <= num18; ++i11)
                        {
                            i9 += 4;
                            if (i11 > i5)
                            {
                                numArray5[1] = nTin[i9];
                                numArray6[1] = xTin[i9];
                                numArray7[1] = yTin[i9];
                                numArray8[1] = zTin[i9];
                                numArray5[2] = nTin[i9 + 1];
                                numArray6[2] = xTin[i9 + 1];
                                numArray7[2] = yTin[i9 + 1];
                                numArray8[2] = zTin[i9 + 1];
                                numArray5[3] = nTin[i9 + 2];
                                numArray6[3] = xTin[i9 + 2];
                                numArray7[3] = yTin[i9 + 2];
                                numArray8[3] = zTin[i9 + 2];
                                numArray5[4] = nTin[i9];
                                numArray6[4] = xTin[i9];
                                numArray7[4] = yTin[i9];
                                numArray8[4] = zTin[i9];
                                int num20 = 0;
                                for (int i12 = 2; i12 <= 4; ++i12)
                                {
                                    double num21 = numArray6[i12] - numArray6[i12 - 1];
                                    double num22 = numArray7[i12] - numArray7[i12 - 1];
                                    num4 = Math.Sqrt(num21 * num21 + num22 * num22);
                                    x2 = 0.5 * (numArray6[i12 - 1] + numArray6[i12]);
                                    y2 = 0.5 * (numArray7[i12 - 1] + numArray7[i12]);
                                    double num23 = x2 - x1;
                                    double num24 = y2 - y1;
                                    if (Math.Sqrt(num23 * num23 + num24 * num24) < 0.003)
                                    {
                                        num20 = i12;
                                        break;
                                    }
                                }
                                if (num20 != 0)
                                {
                                    if (i8 == 2)
                                        i2 = 3;
                                    if (i8 == 3)
                                        i2 = 1;
                                    if (i8 == 4)
                                        i2 = 2;
                                    if (num20 == 2)
                                        i1 = 3;
                                    if (num20 == 3)
                                        i1 = 1;
                                    if (num20 == 4)
                                        i1 = 2;
                                    double num25 = numArray2[i2] - numArray6[i1];
                                    double num26 = numArray3[i2] - numArray7[i1];
                                    double num27 = Math.Sqrt(num25 * num25 + num26 * num26);
                                    if (num4 < num27)
                                    {
                                        num9 = numArray1[i8 - 1];
                                        x1 = numArray2[i8 - 1];
                                        y1 = numArray3[i8 - 1];
                                        num15 = numArray4[i8 - 1];
                                        num8 = numArray1[i8];
                                        x2 = numArray2[i8];
                                        y2 = numArray3[i8];
                                        num14 = numArray4[i8];
                                        num7 = numArray1[i2];
                                        x3 = numArray2[i2];
                                        y3 = numArray3[i2];
                                        num13 = numArray4[i2];
                                        num6 = numArray5[i1];
                                        x4 = numArray6[i1];
                                        y4 = numArray7[i1];
                                        num12 = numArray8[i1];
                                        int ip = 1;
                                        TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip);
                                        if (xm != 0.0 || ym != 0.0)
                                        {
                                            double num28 = x2 - x1;
                                            double num29 = y2 - y1;
                                            double num30 = Math.Sqrt(num28 * num28 + num29 * num29);
                                            double num31 = x1 - xm;
                                            double num32 = y1 - ym;
                                            double num33 = Math.Sqrt(num31 * num31 + num32 * num32);
                                            double num34 = num30 - num33;
                                            double num35 = num33;
                                            if (num34 < num33)
                                                num35 = num34;
                                            double num36 = x4 - x3;
                                            double num37 = y4 - y3;
                                            double num38 = Math.Sqrt(num36 * num36 + num37 * num37);
                                            double num39 = x3 - xm;
                                            double num40 = y3 - ym;
                                            double num41 = Math.Sqrt(num39 * num39 + num40 * num40);
                                            double num42 = num38 - num41;
                                            double num43 = num41;
                                            if (num42 < num41)
                                                num43 = num42;
                                            if (num38 != num30)
                                            {
                                                double num44 = num43 / num38;
                                                double num45 = num35 / num30;
                                                if (num38 > num30 && num45 > num1 && num44 < num2)
                                                {
                                                    i10 = i9;
                                                    break;
                                                }
                                                if (num30 > num38 && num44 > num1 && num45 < num2)
                                                {
                                                    i10 = i9;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (i10 != 0)
                        {
                            ++num16;
                            panel.Text = "Подождите... Коррекция треугольников-" + string.Format("{0}", (object)num16);
                            ++num19;
                            nTin[i6] = num9;
                            xTin[i6] = x1;
                            yTin[i6] = y1;
                            zTin[i6] = num15;
                            nTin[i6 + 1] = num7;
                            xTin[i6 + 1] = x3;
                            yTin[i6 + 1] = y3;
                            zTin[i6 + 1] = num13;
                            nTin[i6 + 2] = num6;
                            xTin[i6 + 2] = x4;
                            yTin[i6 + 2] = y4;
                            zTin[i6 + 2] = num12;
                            nTin[i6 + 3] = num9;
                            xTin[i6 + 3] = x1;
                            yTin[i6 + 3] = y1;
                            zTin[i6 + 3] = num15;
                            nTin[i10] = num8;
                            xTin[i10] = x2;
                            yTin[i10] = y2;
                            zTin[i10] = num14;
                            nTin[i10 + 1] = num7;
                            xTin[i10 + 1] = x3;
                            yTin[i10 + 1] = y3;
                            zTin[i10 + 1] = num13;
                            nTin[i10 + 2] = num6;
                            xTin[i10 + 2] = x4;
                            yTin[i10 + 2] = y4;
                            zTin[i10 + 2] = num12;
                            nTin[i10 + 3] = num8;
                            xTin[i10 + 3] = x2;
                            yTin[i10 + 3] = y2;
                            zTin[i10 + 3] = num14;
                            break;
                        }
                    }
                }
                if (num19 == 0)
                    break;
            }
        }

        public static void Gmprd(double[] a, double[] b, ref double[] r, int n, int m, int l)
        {
            int i1 = 0;
            int num = -m;
            for (int i2 = 1; i2 <= l; ++i2)
            {
                num += m;
                for (int i3 = 1; i3 <= n; ++i3)
                {
                    ++i1;
                    int i4 = i3 - n;
                    int i5 = num;
                    r[i1] = 0.0;
                    for (int i6 = 1; i6 <= m; ++i6)
                    {
                        i4 += n;
                        ++i5;
                        r[i1] = r[i1] + a[i4] * b[i5];
                    }
                }
            }
        }

        public static void Minv(ref double[] a, int n, out double d, ref int[] l, ref int[] m)
        {
            d = 1.0;
            int num1 = -n;
            for (int i1 = 1; i1 <= n; ++i1)
            {
                num1 += n;
                l[i1] = i1;
                m[i1] = i1;
                int i2 = num1 + i1;
                double num2 = a[i2];
                for (int i3 = i1; i3 <= n; ++i3)
                {
                    int num3 = n * (i3 - 1);
                    for (int i4 = i1; i4 <= n; ++i4)
                    {
                        int i5 = num3 + i4;
                        if (Math.Abs(num2) < Math.Abs(a[i5]))
                        {
                            num2 = a[i5];
                            l[i1] = i4;
                            m[i1] = i3;
                        }
                    }
                }
                int num4 = l[i1];
                if (num4 > i1)
                {
                    int i6 = i1 - n;
                    for (int i7 = 1; i7 <= n; ++i7)
                    {
                        i6 += n;
                        double num5 = -a[i6];
                        int i8 = i6 - i1 + num4;
                        a[i6] = a[i8];
                        a[i8] = num5;
                    }
                }
                int num6 = m[i1];
                if (num6 > i1)
                {
                    int num7 = n * (num6 - 1);
                    for (int i9 = 1; i9 <= n; ++i9)
                    {
                        int i10 = num1 + i9;
                        int i11 = num7 + i9;
                        double num8 = -a[i10];
                        a[i10] = a[i11];
                        a[i11] = num8;
                    }
                }
                if (num2 == 0.0)
                {
                    d = 0.0;
                    return;
                }
                for (int i12 = 1; i12 <= n; ++i12)
                {
                    if (i12 != i1)
                    {
                        int i13 = num1 + i12;
                        a[i13] = a[i13] / -num2;
                    }
                }
                for (int i14 = 1; i14 <= n; ++i14)
                {
                    int i15 = num1 + i14;
                    double num9 = a[i15];
                    int i16 = i14 - n;
                    for (int i17 = 1; i17 <= n; ++i17)
                    {
                        i16 += n;
                        if (i14 != i1 && i17 != i1)
                        {
                            int i18 = i16 - i14 + i1;
                            a[i16] = num9 * a[i18] + a[i16];
                        }
                    }
                }
                int i19 = i1 - n;
                for (int i20 = 1; i20 <= n; ++i20)
                {
                    i19 += n;
                    if (i20 != i1)
                        a[i19] = a[i19] / num2;
                }
                a[i2] = 1.0 / num2;
            }
            int i21 = n;
            do
            {
                --i21;
                if (i21 <= 0)
                    break;
                int num10 = l[i21];
                if (num10 > i21)
                {
                    int num11 = n * (i21 - 1);
                    int num12 = n * (num10 - 1);
                    for (int i22 = 1; i22 <= n; ++i22)
                    {
                        int i23 = num11 + i22;
                        double num13 = a[i23];
                        int i24 = num12 + i22;
                        a[i23] = -a[i24];
                        a[i24] = num13;
                    }
                }
                int num14 = m[i21];
                if (num10 > i21)
                {
                    int i25 = i21 - n;
                    for (int i26 = 1; i26 <= n; ++i26)
                    {
                        i25 += n;
                        double num15 = a[i25];
                        int i27 = i25 - i21 + num14;
                        a[i25] = -a[i27];
                        a[i27] = num15;
                    }
                }
            }
            while (i21 > 0);
        }

        public static void CoordCentre(
          int k,
          ref double[] x,
          ref double[] y,
          ref double[] z,
          ref double xCent,
          ref double yCent,
          ref double zCent)
        {
            xCent = 0.0;
            yCent = 0.0;
            zCent = 0.0;
            for (int i = 1; i <= k; ++i)
            {
                xCent += x[i];
                yCent += y[i];
                zCent += z[i];
            }
            xCent /= (double)k;
            yCent /= (double)k;
            zCent /= (double)k;
            for (int i = 1; i <= k; ++i)
            {
                x[i] = x[i] - xCent;
                y[i] = y[i] - yCent;
                z[i] = z[i] - zCent;
            }
        }

        public static void Spal(
          int n,
          int m,
          int n1,
          ref double ro,
          ref double[,] ao,
          ref double[,] a,
          ref double[,] h,
          ref int[,] j1,
          ref int[,] j2,
          ref int ii,
          ref int n2,
          ref double amin,
          ref double amax,
          ref double dm,
          ref int ie)
        {
            amin = 0.0;
            amax = 0.0;
            dm = 0.0;
            ie = 0;
            double num1 = 0.0;
            int num2 = n1 - 1;
            int num3 = n + 1;
            int num4 = m - 1;
            if (n <= ii || n1 > m * 2)
            {
                ie = 1;
            }
            else
            {
                amin = 9999999.9;
                amax = -9999999.9;
                for (int i1 = 1; i1 <= n; ++i1)
                {
                    for (int i2 = 1; i2 <= n1; ++i2)
                    {
                        if (ao[i1, i2] < amin)
                            amin = ao[i1, i2];
                        if (ao[i1, i2] > amax)
                            amax = ao[i1, i2];
                    }
                }
                amin -= 1E-05;
                dm = amax - amin;
                for (int i3 = 1; i3 <= n; ++i3)
                {
                    for (int i4 = 1; i4 <= n1; ++i4)
                        a[i3, i4] = (ao[i3, i4] - amin) / dm;
                }
                double d = 0.0;
                for (int i5 = 1; i5 <= n1; ++i5)
                {
                    for (int i6 = 1; i6 <= ii; ++i6)
                    {
                        j2[i5, i6] = 0;
                        j1[i5, i6] = 0;
                    }
                }
                for (int i = 1; i <= m; ++i)
                {
                    j1[1, i] = i - 1;
                    j2[1, i] = j1[1, i];
                }
                int num5 = m;
                for (int i7 = 1; i7 <= num2; ++i7)
                {
                    int num6 = num5;
                    for (int i8 = 1; i8 <= num6; ++i8)
                    {
                        int num7 = 0;
                        for (int i9 = 1; i9 <= n1; ++i9)
                            num7 += j2[i9, i8];
                        if (num7 < num4)
                        {
                            int num8 = num5 + 1;
                            int num9 = num5 + m - 1 - num7;
                            for (int i10 = num8; i10 <= num9; ++i10)
                            {
                                for (int i11 = 1; i11 <= i7; ++i11)
                                {
                                    j2[i11, i10] = j2[i11, i8];
                                    j2[i7 + 1, i10] = i10 - num5;
                                }
                            }
                            num5 = num5 + m - num7 - 1;
                        }
                        if (num5 >= ii)
                            break;
                    }
                    for (int i12 = 1; i12 <= ii; ++i12)
                    {
                        for (int i13 = 1; i13 <= n1; ++i13)
                            j1[i13, i12] = j2[i13, i12];
                    }
                }
                for (int i14 = 1; i14 <= n; ++i14)
                {
                    for (int i15 = 1; i15 <= ii; ++i15)
                    {
                        d = 1.0;
                        for (int i16 = 1; i16 <= n1; ++i16)
                        {
                            if (a[i14, i16] != 0.0)
                            {
                                double num10 = Math.Exp((double)j1[i16, i15] * Math.Log(a[i14, i16]));
                                d *= num10;
                            }
                            else
                                d = 0.0;
                        }
                        h[i14, i15 + n] = d;
                        h[i15 + n, i14] = d;
                    }
                }
                int num11 = n1 / 2;
                double num12 = 1.0 * (double)(n1 - 2 * num11);
                if (num12 != 0.0)
                {
                    int num13 = 2 * m - n1;
                    for (int i17 = 1; i17 <= n; ++i17)
                    {
                        for (int i18 = i17 + 1; i18 <= n; ++i18)
                        {
                            d = 0.0;
                            for (int i19 = 1; i19 <= n1; ++i19)
                                d += (a[i17, i19] - a[i18, i19]) * (a[i17, i19] - a[i18, i19]);
                            if (d != 0.0)
                            {
                                h[i17, i18] = Math.Exp((double)num13 * Math.Log(Math.Sqrt(d)));
                                h[i18, i17] = 0.0;
                            }
                            if (d == 0.0)
                                h[i17, i18] = 0.0;
                            h[i18, i17] = h[i17, i18];
                        }
                    }
                }
                if (num12 == 0.0)
                {
                    int num14 = m - n1 / 2;
                    int num15 = n - 1;
                    for (int i20 = 1; i20 <= num15; ++i20)
                    {
                        for (int i21 = i20 + 1; i21 <= n; ++i21)
                        {
                            d = 0.0;
                            for (int i22 = 1; i22 <= n1; ++i22)
                                d += (a[i20, i22] - a[i21, i22]) * (a[i20, i22] - a[i21, i22]);
                            if (d != 0.0)
                                h[i20, i21] = Math.Log(d) * Math.Exp((double)num14 * Math.Log(d));
                            if (d == 0.0)
                                h[i20, i21] = 0.0;
                            h[i21, i20] = h[i20, i21];
                        }
                    }
                }
                if (ro != 0.0)
                {
                    int int32 = Convert.ToInt32((double)((n1 - 1) / 2) + 0.1);
                    double num16 = num1 % (double)(int32 / 2);
                    if (num16 != 0.0)
                        d = -1.0 / ro;
                    if (num16 == 0.0)
                        d = 1.0;
                }
                if (ro == 0.0)
                    d = 0.0;
                for (int i = 1; i <= n; ++i)
                    h[i, i] = d;
                for (int i23 = num3; i23 <= n2; ++i23)
                {
                    for (int i24 = num3; i24 <= n2; ++i24)
                        h[i23, i24] = 0.0;
                }
            }
        }

        public static void Jobal(
          ref double h,
          ref double s,
          ref double p,
          ref int m,
          ref double[,] aa,
          ref double[] bb,
          ref double[] c,
          ref double[] dd,
          ref double[] g,
          ref double[] gg,
          ref int[] ll,
          ref int[,] mm,
          ref double[] bx,
          ref double[] by,
          ref double[] aDop,
          ref int[] jDop)
        {
            int num1 = 1;
            double d = 0.0;
            int num2 = m;
            double num3 = h;
            int num4 = m * m;
            int i1 = 0;
            for (int i2 = 1; i2 <= m; ++i2)
            {
                for (int i3 = 1; i3 <= m; ++i3)
                {
                    ++i1;
                    aDop[i1] = aa[i2, i3];
                }
            }
            for (int i4 = 1; i4 <= m; ++i4)
                jDop[i4] = mm[i4, 1];
            int num5 = m + 1;
            Gmprd(aDop, aDop, ref g, m, m, m);
            for (int i5 = 1; i5 <= num1; ++i5)
            {
                for (int i6 = 1; i6 <= num4; ++i6)
                    dd[i6] = g[i6];
                num3 += s;
                bx[i5] = num3;
                double num6 = 0.0;
                double num7 = 0.0;
                for (int i7 = 1; i7 <= num4; i7 += num5)
                    dd[i7] = g[i7] + num3;
                Minv(ref dd, m, out d, ref ll, ref jDop);
                Gmprd(dd, aDop, ref gg, m, m, m);
                Gmprd(gg, bb, ref c, m, m, 1);
                Gmprd(aDop, c, ref dd, m, m, 1);
                int num8 = 0;
                for (int i8 = 1; i8 <= num2; ++i8)
                {
                    if (Math.Abs(dd[i8] - bb[i8]) > p)
                    {
                        ++num8;
                        break;
                    }
                }
                if (num8 == 0)
                    break;
                for (int i9 = 1; i9 <= num2; ++i9)
                {
                    double num9 = Math.Abs(dd[i9] - bb[i9]);
                    ++num7;
                    num6 += num9;
                }
                by[i5] = num6 / num7;
            }
        }

        public static void Spl_apro(
          ref int k,
          ref double[] x,
          ref double[] y,
          ref double[] z,
          ref double dps,
          ref double xh,
          ref double yh,
          ref double zh,
          ref int[,] j1,
          ref double[,] aDop,
          ref int m,
          ref int ii,
          ref int n1,
          ref int n2,
          ref double amin,
          ref double dm,
          ref double[] yd)
        {
            int[,] j2 = new int[30, 30];
            double[,] ao = new double[30, 30];
            double[,] h = new double[30, 30];
            int[] jj1 = new int[800];
            int[] jj2 = new int[800];
            double[] ata = new double[800];
            double[] asa = new double[800];
            double[] rvek = new double[800];
            double[] t1 = new double[800];
            double[] av = new double[800];
            double[] hh = new double[800];
            double[] hDop = new double[800];
            int[] jDop = new int[800];
            xh = yh = zh = 0.0;
            n2 = 0;
            dm = 0.0;
            ii = 0;
            if (k > 25)
                k = 25;
            CoordCentre(k, ref x, ref y, ref z, ref xh, ref yh, ref zh);
            double num = 1E-07;
            m = 2;
            n1 = 2;
            double ro = 0.0;
            double al = num;
            double p = dps;
            amin = -num;
            Vas1(ref ao, k, ref x, ref y, ref z, ref h, ref m, ref n2, ref j1, ref j2, ref ro, ref al, ref p, ref ata, ref asa, ref rvek, ref t1, ref yd, ref av, ref n1, ref jj1, ref amin, ref dm, ref ii, ref hh, ref jj2, ref aDop, ref hDop, ref jDop);
            for (int i = 1; i <= k; ++i)
            {
                x[i] = x[i] + xh;
                y[i] = y[i] + yh;
                z[i] = z[i] + zh;
            }
        }

        public static void Vas2(
          int k,
          ref double x,
          ref double y,
          ref int m,
          ref int n1,
          ref int ii,
          ref int n2,
          ref int[,] j1,
          ref double[,] ao,
          ref double amin,
          ref double dm,
          ref double z,
          ref double[] y1)
        {
            double[] c = new double[10];
            double[] c1 = new double[10];
            z = 0.0;
            c1[1] = x;
            c1[2] = y;
            Val(ref k, ref m, ref n1, ref ii, ref n2, ref c1, ref c, ref y1, ref j1, ref ao, ref amin, ref dm, ref z);
        }

        public static void Vas1(
          ref double[,] ao,
          int k,
          ref double[] x,
          ref double[] y,
          ref double[] z,
          ref double[,] h,
          ref int m,
          ref int n2,
          ref int[,] j1,
          ref int[,] j2,
          ref double ro,
          ref double al,
          ref double p,
          ref double[] ata,
          ref double[] asa,
          ref double[] rvek,
          ref double[] t1,
          ref double[] yd,
          ref double[] av,
          ref int n1,
          ref int[] jj1,
          ref double amin,
          ref double dm,
          ref int ii,
          ref double[] hh,
          ref int[] jj2,
          ref double[,] a,
          ref double[] hDop,
          ref int[] jDop)
        {
            int num1 = n1 + m - 1;
            int num2 = m - 1;
            int num3 = 1;
            int num4 = 1;
            int num5 = 1;
            int ie = 0;
            double amax = 0.0;
            for (int i = 1; i <= num1; ++i)
                num3 *= i;
            for (int i = 1; i <= n1; ++i)
                num4 *= i;
            for (int i = 1; i <= num2; ++i)
                num5 *= i;
            ii = num3 / (num4 * num5);
            n2 = k + ii;
            for (int i = 1; i <= k; ++i)
            {
                ao[i, 1] = x[i];
                ao[i, 2] = y[i];
            }
            Spal(k, m, n1, ref ro, ref ao, ref a, ref h, ref j1, ref j2, ref ii, ref n2, ref amin, ref amax, ref dm, ref ie);
            double h1 = al;
            for (int i = k + 1; i <= n2; ++i)
                z[i] = 0.0;
            Jobal(ref h1, ref al, ref p, ref n2, ref h, ref z, ref yd, ref ata, ref asa, ref rvek, ref jj1, ref j2, ref t1, ref av, ref hDop, ref jDop);
        }

        public static void Val(
          ref int n,
          ref int m,
          ref int n1,
          ref int ii,
          ref int n2,
          ref double[] c1,
          ref double[] c,
          ref double[] b,
          ref int[,] j1,
          ref double[,] a,
          ref double amin,
          ref double dm,
          ref double tk)
        {
            for (int i = 1; i <= n1; ++i)
                c[i] = (c1[i] - amin) / dm;
            tk = 0.0;
            int num1 = n1 / 2;
            double num2 = 1.0 * (double)(n1 - 2 * num1);
            if (num2 != 0.0)
            {
                int num3 = 2 * m - n1;
                for (int i1 = 1; i1 <= n; ++i1)
                {
                    double d = 0.0;
                    for (int i2 = 1; i2 <= n1; ++i2)
                        d += (c[i2] - a[i1, i2]) * (c[i2] - a[i1, i2]);
                    tk += b[i1] * Math.Exp((double)num3 * Math.Log(Math.Sqrt(d)));
                }
            }
            if (num2 == 0.0)
            {
                int num4 = m - n1 / 2;
                for (int i3 = 1; i3 <= n; ++i3)
                {
                    double d = 0.0;
                    for (int i4 = 1; i4 <= n1; ++i4)
                        d += (c[i4] - a[i3, i4]) * (c[i4] - a[i3, i4]);
                    if (d > 1E-06)
                        tk += b[i3] * Math.Exp((double)num4 * Math.Log(d)) * Math.Log(d);
                }
            }
            for (int i = 1; i <= n1; ++i)
            {
                if (Math.Abs(c[i]) <= 1E-06)
                    c[i] = 1E-06;
            }
            for (int i5 = 1; i5 <= ii; ++i5)
            {
                double num5 = b[i5 + n];
                for (int i6 = 1; i6 <= n1; ++i6)
                    num5 *= Math.Exp((double)j1[i6, i5] * Math.Log(c[i6]));
                tk += num5;
            }
        }

        public static void Treyg(
          double[] x,
          double[] y,
          double[] z,
          double xt,
          double yt,
          out double zt)
        {
            zt = 0.0;
            double num1 = x[1] - x[0];
            double num2 = x[2] - x[0];
            double num3 = y[1] - y[0];
            double num4 = y[2] - y[0];
            double num5 = z[1] - z[0];
            double num6 = z[2] - z[0];
            double num7 = xt - x[0];
            double num8 = yt - y[0];
            double num9 = num3 * num6 - num4 * num5;
            double num10 = num1 * num6 - num2 * num5;
            double num11 = num1 * num4 - num2 * num3;
            double num12 = num7 * num9 / num11;
            double num13 = num8 * num10 / num11;
            zt = z[0] - num12 + num13;
        }

        public static void CoordInscr(
          int ks,
          double[] xs,
          double[] ys,
          out double xins,
          out double yins,
          out double angle,
          out int j1,
          out int j2)
        {
            double num1 = 3.1415926;
            xins = 0.0;
            yins = 0.0;
            angle = 0.0;
            j1 = 0;
            j2 = 0;
            int kArray = 999999;
            doubleArray(xs, ref kArray);
            doubleArray(ys, ref kArray);
            if (ks > kArray)
            {
                int num2 = (int)MessageBox.Show("Индекс массива CoordInscr");
            }
            else
            {
                double num3 = 9999999.9;
                int i1 = 1;
                int num4 = 2;
                int i2 = 0;
                int i3 = 0;
                for (int i4 = 1; i4 <= ks; ++i4)
                {
                    ++i1;
                    int i5 = i1 + num4;
                    if (i5 < ks)
                    {
                        int i6 = (i1 + i5) / 2;
                        for (int i7 = i1; i7 <= i5; ++i7)
                        {
                            double dist;
                            int ip;
                            DistPnt(xs[i6], ys[i6], xs[i1], ys[i1], xs[i5], ys[i5], out dist, out ip, out double _, out double _);
                            if (ip > 0 && num3 > dist)
                            {
                                num3 = dist;
                                i2 = i1;
                                i3 = i5;
                            }
                        }
                    }
                    else
                        break;
                }
                if (i3 <= i2)
                    return;
                double x = xs[i3] - xs[i2];
                double y = ys[i3] - ys[i2];
                angle = Math.Atan2(y, x);
                if (angle < 0.0)
                    angle += 2.0 * num1;
                xins = 0.5 * (xs[i2] + xs[i3]);
                yins = 0.5 * (ys[i2] + ys[i3]);
                j1 = i2;
                j2 = i3;
            }
        }

        public static void Smooth2(int k, double[] x, double[] y, int ks, double[] xs, double[] ys)
        {
            double num1 = 3.1415926;
            int num2 = 2;
            int num3;
            int num4 = num3 = 0;
            int kArray1 = 999999;
            doubleArray(x, ref kArray1);
            doubleArray(y, ref kArray1);
            if (k > kArray1)
            {
                int num5 = (int)MessageBox.Show("Индекс массива Smooth1");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(xs, ref kArray2);
                doubleArray(ys, ref kArray2);
                if (ks > kArray2)
                {
                    int num6 = (int)MessageBox.Show("Индекс массива Smooth1");
                }
                else
                {
                    int i1 = -1;
                    for (int i2 = 0; i2 <= k; ++i2)
                    {
                        double num7 = 9999999.9;
                        for (int i3 = 0; i3 <= ks; ++i3)
                        {
                            double num8 = xs[i3] - x[i2];
                            double num9 = ys[i3] - y[i2];
                            double num10 = Math.Sqrt(num8 * num8 + num9 * num9);
                            if (num10 < num7)
                                num7 = num10;
                        }
                        if (num7 < 0.6)
                        {
                            ++i1;
                            x[i1] = x[i2];
                            y[i1] = y[i2];
                        }
                        if (num7 >= 0.6 && i2 == k)
                        {
                            ++i1;
                            x[i1] = xs[ks];
                            y[i1] = ys[ks];
                        }
                    }
                    int num11 = i1;
                    for (int i4 = 1; i4 <= num11; ++i4)
                    {
                        double num12 = 9999999.9;
                        for (int i5 = 0; i5 <= ks; ++i5)
                        {
                            double num13 = xs[i5] - x[i4 - 1];
                            double num14 = ys[i5] - y[i4 - 1];
                            double num15 = Math.Sqrt(num13 * num13 + num14 * num14);
                            if (num15 < num12)
                            {
                                num12 = num15;
                                num4 = i5;
                            }
                        }
                        if (i4 == 1)
                            num4 = 0;
                        double num16 = 9999999.9;
                        for (int i6 = 0; i6 <= ks; ++i6)
                        {
                            double num17 = xs[i6] - x[i4];
                            double num18 = ys[i6] - y[i4];
                            double num19 = Math.Sqrt(num17 * num17 + num18 * num18);
                            if (num19 < num16)
                            {
                                num16 = num19;
                                num3 = i6;
                            }
                        }
                        if (i4 == num11)
                            num3 = ks;
                        if (num3 - num4 >= 4)
                        {
                            for (int i7 = num4 + 1; i7 < num3; ++i7)
                            {
                                double xp = 0.0;
                                double yp = 0.0;
                                int ip;
                                DistPnt(xs[i7], ys[i7], x[i4 - 1], y[i4 - 1], x[i4], y[i4], out double _, out ip, out xp, out yp);
                                if (ip != 0)
                                {
                                    if (num2 == 2)
                                    {
                                        double num20 = 0.5 * (xs[i7] + xp);
                                        double num21 = 0.5 * (ys[i7] + yp);
                                        xs[i7] = num20;
                                        ys[i7] = num21;
                                    }
                                    else
                                    {
                                        double x1 = xs[i7] - xp;
                                        double y1 = ys[i7] - yp;
                                        double num22 = Math.Sqrt(x1 * x1 + y1 * y1);
                                        if (num22 >= 0.05)
                                        {
                                            double num23 = Math.Atan2(y1, x1);
                                            if (num23 < 0.0)
                                                num23 += 2.0 * num1;
                                            double num24 = num22 / (double)num2;
                                            xs[i7] = xp + num24 * Math.Cos(num23);
                                            ys[i7] = yp + num24 * Math.Sin(num23);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void Clip_Line(
          int iParam,
          int kPol,
          int[] kp1,
          int[] kp2,
          double[] x,
          double[] y,
          int kt,
          double[] xt,
          double[] yt,
          out int kc,
          int[] kp,
          int[] k1,
          int[] k2,
          double[] xc,
          double[] yc,
          out int kr,
          double[] xr,
          double[] yr)
        {
            int num1;
            int num2 = num1 = 0;
            int num3;
            int num4 = num3 = 0;
            double num5;
            double num6 = num5 = 0.0;
            double num7;
            double num8 = num7 = 0.0;
            double num9;
            double num10 = num9 = 0.0;
            int i1 = 0;
            kc = 0;
            kr = 0;
            int kArray1 = 999999;
            intArray(kp1, ref kArray1);
            intArray(kp2, ref kArray1);
            intArray(kp, ref kArray1);
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            if (kPol > kArray1)
            {
                int num11 = (int)MessageBox.Show("Индекс массива Clip_line");
            }
            else
            {
                int num12 = kp2[kPol];
                int kArray2 = 999999;
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                doubleArray(xt, ref kArray2);
                doubleArray(yt, ref kArray2);
                doubleArray(xc, ref kArray2);
                doubleArray(yc, ref kArray2);
                doubleArray(xr, ref kArray2);
                doubleArray(yr, ref kArray2);
                kArray2 -= 3;
                if (num12 > kArray2)
                {
                    int num13 = (int)MessageBox.Show("Индекс массива Clip_line");
                }
                else
                {
                    num4 = 0;
                    int ip;
                    if (iParam == 0)
                    {
                        int num14 = 0;
                        for (int i2 = 1; i2 <= kPol; ++i2)
                        {
                            int num15 = kp1[i2];
                            int num16 = kp2[i2];
                            int k = -1;
                            for (int i3 = num15; i3 <= num16; ++i3)
                            {
                                ++k;
                                xc[k] = x[i3];
                                yc[k] = y[i3];
                            }
                            int num17 = 0;
                            i1 = 0;
                            xr[i1] = xt[0];
                            yr[i1] = yt[0];
                            for (int i4 = 1; i4 <= kt; ++i4)
                            {
                                double x1 = xt[i4 - 1];
                                double y1 = yt[i4 - 1];
                                double x2 = xt[i4];
                                double y2 = yt[i4];
                                for (int i5 = 1; i5 <= k; ++i5)
                                {
                                    double x3 = xc[i5 - 1];
                                    double y3 = yc[i5 - 1];
                                    double x4 = xc[i5];
                                    double y4 = yc[i5];
                                    ip = 1;
                                    double xm = 0.0;
                                    double ym = 0.0;
                                    TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip);
                                    if (xm != 0.0 && ym != 0.0)
                                    {
                                        ++num17;
                                        double num18 = xt[i4] - xm;
                                        double num19 = yt[i4] - ym;
                                        if (Math.Sqrt(num18 * num18 + num19 * num19) >= 0.003)
                                        {
                                            ++i1;
                                            xr[i1] = xm;
                                            yr[i1] = ym;
                                        }
                                        else
                                            break;
                                    }
                                }
                                ++i1;
                                xr[i1] = xt[i4];
                                yr[i1] = yt[i4];
                            }
                            if (num17 > 0)
                            {
                                ++num14;
                                kt = i1;
                                for (int i6 = 0; i6 <= i1; ++i6)
                                {
                                    xt[i6] = xr[i6];
                                    yt[i6] = yr[i6];
                                }
                            }
                            if (num17 == 0)
                            {
                                int num20 = 0;
                                for (int i7 = 0; i7 <= kt; ++i7)
                                {
                                    ip = in_out(k, ref xc, ref yc, xt[i7], yt[i7]);
                                    if (ip > 0)
                                    {
                                        ++num20;
                                        break;
                                    }
                                }
                                if (num20 > 0)
                                {
                                    ++num14;
                                    i1 = kt;
                                    for (int i8 = 0; i8 <= i1; ++i8)
                                    {
                                        xr[i8] = xt[i8];
                                        yr[i8] = yt[i8];
                                    }
                                    break;
                                }
                            }
                        }
                        if (num14 == 0)
                            return;
                        int i9 = 0;
                        for (int i10 = 1; i10 <= i1; ++i10)
                        {
                            double num21 = xr[i10] - xr[i9];
                            double num22 = yr[i10] - yr[i9];
                            if (Math.Sqrt(num21 * num21 + num22 * num22) >= 0.003)
                            {
                                ++i9;
                                xr[i9] = xr[i10];
                                yr[i9] = yr[i10];
                            }
                        }
                        kr = i9;
                    }
                    if (iParam <= 0)
                        return;
                    int i11 = 0;
                    int num23 = 0;
                    int i12 = 0;
                    for (int i13 = 1; i13 <= kt; ++i13)
                    {
                        double xt1 = 0.5 * (xt[i13 - 1] + xt[i13]);
                        double yt1 = 0.5 * (yt[i13 - 1] + yt[i13]);
                        int num24 = 0;
                        for (int i14 = 1; i14 <= kPol; ++i14)
                        {
                            int num25 = kp1[i14];
                            int num26 = kp2[i14];
                            int k = -1;
                            for (int i15 = num25; i15 <= num26; ++i15)
                            {
                                ++k;
                                xr[k] = x[i15];
                                yr[k] = y[i15];
                            }
                            ip = in_out(k, ref xr, ref yr, xt1, yt1);
                            if (ip > 0)
                            {
                                ++num24;
                                break;
                            }
                        }
                        if (num24 > 0)
                        {
                            if (num23 > 0)
                            {
                                ++i11;
                                kp[i11] = num23;
                                num23 = 0;
                            }
                        }
                        else if (num23 == 0)
                        {
                            int num27 = num23 + 1;
                            int i16 = i12 + 1;
                            xc[i16] = xt[i13 - 1];
                            yc[i16] = yt[i13 - 1];
                            num23 = num27 + 1;
                            i12 = i16 + 1;
                            xc[i12] = xt[i13];
                            yc[i12] = yt[i13];
                        }
                        else if (num23 > 0)
                        {
                            ++num23;
                            ++i12;
                            xc[i12] = xt[i13];
                            yc[i12] = yt[i13];
                        }
                    }
                    if (i12 < 2)
                        return;
                    if (num23 > 0)
                    {
                        ++i11;
                        kp[i11] = num23;
                    }
                    double num28 = xc[1] - xc[i12];
                    double num29 = yc[1] - yc[i12];
                    if (Math.Sqrt(num28 * num28 + num29 * num29) < 0.003 && i11 > 1)
                    {
                        int num30 = kp[1];
                        int num31 = kp[i11];
                        for (int i17 = 2; i17 <= num30; ++i17)
                        {
                            ++num31;
                            ++i12;
                            xc[i12] = xc[i17];
                            yc[i12] = yc[i17];
                        }
                        kp[i11] = num31;
                        ip = num30 + 1;
                        int i18 = 0;
                        for (int i19 = ip; i19 <= i12; ++i19)
                        {
                            ++i18;
                            xc[i18] = xc[i19];
                            yc[i18] = yc[i19];
                        }
                        num2 = i18;
                        int i20 = 0;
                        for (int i21 = 2; i21 <= i11; ++i21)
                        {
                            ++i20;
                            kp[i20] = kp[i21];
                        }
                        i11 = i20;
                    }
                    kc = i11;
                    if (i11 <= 0)
                        return;
                    k1[1] = 1;
                    k2[1] = kp[1];
                    if (i11 <= 1)
                        return;
                    for (int i22 = 2; i22 <= i11; ++i22)
                    {
                        k1[i22] = k2[i22 - 1] + 1;
                        k2[i22] = k2[i22 - 1] + kp[i22];
                    }
                }
            }
        }

        public static void ContourClip(
          int k,
          double[] x,
          double[] y,
          int kt,
          double[] xt,
          double[] yt,
          out int kc,
          int[] kp,
          int[] k1,
          int[] k2,
          double[] xc,
          double[] yc)
        {
            kc = 0;
            int kArray1 = 999999;
            doubleArray(x, ref kArray1);
            doubleArray(y, ref kArray1);
            if (k > kArray1)
            {
                int num1 = (int)MessageBox.Show("Индекс массива ContourClip");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(xt, ref kArray2);
                doubleArray(yt, ref kArray2);
                doubleArray(xc, ref kArray2);
                doubleArray(yc, ref kArray2);
                int num2 = kArray2 - 2;
                if (kt > num2)
                {
                    int num3 = (int)MessageBox.Show("Индекс массива ContourClip");
                }
                else
                {
                    int kArray3 = 999999;
                    intArray(k1, ref kArray3);
                    intArray(k2, ref kArray3);
                    intArray(kp, ref kArray3);
                    int num4 = kArray3 - 2;
                    int i1 = 0;
                    int num5 = 0;
                    int i2 = 0;
                    for (int i3 = 1; i3 <= kt; ++i3)
                    {
                        double xt1 = 0.5 * (xt[i3 - 1] + xt[i3]);
                        double yt1 = 0.5 * (yt[i3 - 1] + yt[i3]);
                        if (in_out(k, ref x, ref y, xt1, yt1) == 0)
                        {
                            if (num5 > 0)
                            {
                                ++i1;
                                if (i1 > num4)
                                {
                                    int num6 = (int)MessageBox.Show("Индекс массива ContourClip");
                                    return;
                                }
                                kp[i1] = num5;
                                num5 = 0;
                            }
                        }
                        else if (num5 == 0)
                        {
                            int num7 = num5 + 1;
                            int i4 = i2 + 1;
                            xc[i4] = xt[i3 - 1];
                            yc[i4] = yt[i3 - 1];
                            num5 = num7 + 1;
                            i2 = i4 + 1;
                            xc[i2] = xt[i3];
                            yc[i2] = yt[i3];
                        }
                        else if (num5 > 0)
                        {
                            ++num5;
                            ++i2;
                            xc[i2] = xt[i3];
                            yc[i2] = yt[i3];
                        }
                    }
                    if (i2 < 2)
                        return;
                    if (num5 > 0)
                    {
                        ++i1;
                        if (i1 > num4)
                        {
                            int num8 = (int)MessageBox.Show("Индекс массива ContourClip");
                            return;
                        }
                        kp[i1] = num5;
                    }
                    kc = i1;
                    if (i1 <= 0)
                        return;
                    k1[1] = 1;
                    k2[1] = kp[1];
                    if (i1 <= 1)
                        return;
                    for (int i5 = 2; i5 <= i1; ++i5)
                    {
                        k1[i5] = k2[i5 - 1] + 1;
                        k2[i5] = k2[i5 - 1] + kp[i5];
                    }
                }
            }
        }

        public static void SmoothChange(
          string fAdd,
          string fCont,
          int iParam,
          double[] xtd,
          double[] ytd,
          double[] xnd,
          double[] ynd,
          double[] xta,
          double[] yta,
          StatusBarPanel panel1,
          int nVertex)
        {
            double num1 = 0.5;
            double num2;
            double num3 = num2 = 0.0;
            int num4;
            int num5 = num4 = 0;
            int num6;
            int num7 = num6 = 0;
            if (iParam == 1)
                panel1.Text = "Уменьшение плавности";
            if (iParam == 2)
                panel1.Text = "Повышение плавности";
            Cursor.Current = Cursors.WaitCursor;
            if (!File.Exists(fCont))
                return;
            FileStream input1 = new FileStream(fCont, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader1 = new BinaryReader((Stream)input1);
            double num8 = binaryReader1.ReadDouble();
            int num9 = binaryReader1.ReadInt32();
            if (File.Exists(fAdd))
                File.Delete(fAdd);
            FileStream output1 = new FileStream(fAdd, FileMode.CreateNew);
            BinaryWriter binaryWriter1 = new BinaryWriter((Stream)output1);
            binaryWriter1.Write(num8);
            binaryWriter1.Write(num9);
            int k;
            for (int i1 = 1; i1 <= num9; ++i1)
            {
                int num10 = binaryReader1.ReadInt32();
                for (int i2 = 0; i2 <= num10; ++i2)
                {
                    xtd[i2] = binaryReader1.ReadDouble();
                    ytd[i2] = binaryReader1.ReadDouble();
                }
                binaryWriter1.Write(num10);
                for (int i3 = 0; i3 <= num10; ++i3)
                {
                    binaryWriter1.Write(xtd[i3]);
                    binaryWriter1.Write(ytd[i3]);
                }
                double num11 = binaryReader1.ReadDouble();
                double num12 = binaryReader1.ReadDouble();
                double num13 = binaryReader1.ReadDouble();
                double num14 = binaryReader1.ReadDouble();
                int num15 = binaryReader1.ReadInt32();
                int num16 = binaryReader1.ReadInt32();
                k = binaryReader1.ReadInt32();
                for (int i4 = 0; i4 <= k; ++i4)
                {
                    xta[i4] = binaryReader1.ReadDouble();
                    yta[i4] = binaryReader1.ReadDouble();
                }
                if (iParam == 1)
                    Smooth2(num10, xtd, ytd, k, xta, yta);
                if (iParam == 2)
                {
                    Line_Spl(num10, ref xtd, ref ytd, out k, ref xta, ref yta, ref xnd, ref ynd, nVertex);
                    if (k >= 2)
                    {
                        int i5 = 0;
                        for (int i6 = 1; i6 <= k; ++i6)
                        {
                            double num17 = xta[i6] - xta[i5];
                            double num18 = yta[i6] - yta[i5];
                            double num19 = Math.Sqrt(num17 * num17 + num18 * num18);
                            if ((num19 >= num1 || i6 >= k) && (num19 >= 0.003 || i6 != k))
                            {
                                ++i5;
                                xta[i5] = xta[i6];
                                yta[i5] = yta[i6];
                            }
                        }
                        k = i5;
                    }
                    else
                        continue;
                }
                int num20 = i1 / 50;
                if (i1 - num20 * 50 == 0)
                    panel1.Text = "Подождите... Контуры = " + string.Format("{0}", (object)i1);
                binaryWriter1.Write(num11);
                binaryWriter1.Write(num12);
                binaryWriter1.Write(num13);
                binaryWriter1.Write(num14);
                binaryWriter1.Write(num15);
                binaryWriter1.Write(num16);
                binaryWriter1.Write(k);
                for (int i7 = 0; i7 <= k; ++i7)
                {
                    binaryWriter1.Write(xta[i7]);
                    binaryWriter1.Write(yta[i7]);
                }
            }
            binaryWriter1.Close();
            output1.Close();
            binaryReader1.Close();
            input1.Close();
            FileStream input2 = new FileStream(fAdd, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader2 = new BinaryReader((Stream)input2);
            double num21 = binaryReader2.ReadDouble();
            int num22 = binaryReader2.ReadInt32();
            if (File.Exists(fCont))
                File.Delete(fCont);
            FileStream output2 = new FileStream(fCont, FileMode.CreateNew);
            BinaryWriter binaryWriter2 = new BinaryWriter((Stream)output2);
            binaryWriter2.Write(num21);
            binaryWriter2.Write(num22);
            for (int i8 = 1; i8 <= num22; ++i8)
            {
                int num23 = binaryReader2.ReadInt32();
                for (int i9 = 0; i9 <= num23; ++i9)
                {
                    xtd[i9] = binaryReader2.ReadDouble();
                    ytd[i9] = binaryReader2.ReadDouble();
                }
                double num24 = binaryReader2.ReadDouble();
                double num25 = binaryReader2.ReadDouble();
                double num26 = binaryReader2.ReadDouble();
                double num27 = binaryReader2.ReadDouble();
                int num28 = binaryReader2.ReadInt32();
                int num29 = binaryReader2.ReadInt32();
                k = binaryReader2.ReadInt32();
                for (int i10 = 0; i10 <= k; ++i10)
                {
                    xta[i10] = binaryReader2.ReadDouble();
                    yta[i10] = binaryReader2.ReadDouble();
                }
                binaryWriter2.Write(num23);
                for (int i11 = 0; i11 <= num23; ++i11)
                {
                    binaryWriter2.Write(xtd[i11]);
                    binaryWriter2.Write(ytd[i11]);
                }
                binaryWriter2.Write(num24);
                binaryWriter2.Write(num25);
                binaryWriter2.Write(num26);
                binaryWriter2.Write(num27);
                binaryWriter2.Write(num28);
                binaryWriter2.Write(num29);
                binaryWriter2.Write(k);
                for (int i12 = 0; i12 <= k; ++i12)
                {
                    binaryWriter2.Write(xta[i12]);
                    binaryWriter2.Write(yta[i12]);
                }
            }
            binaryWriter2.Close();
            output2.Close();
            binaryReader2.Close();
            input2.Close();
        }

        public static void TinCorrect(
          int iParam,
          double sRel,
          ref int kTin,
          int[] nTin,
          double[] xTin,
          double[] yTin,
          double[] zTin,
          double[] x,
          double[] y,
          double[] z,
          double[] ds,
          out int kChange)
        {
            double[] numArray1 = new double[10];
            double[] numArray2 = new double[10];
            double[] numArray3 = new double[10];
            double[] numArray4 = new double[10];
            double[] numArray5 = new double[10];
            double[] numArray6 = new double[10];
            double[] numArray7 = new double[10];
            double[] numArray8 = new double[10];
            double[] numArray9 = new double[10];
            double[] x1 = new double[5];
            double[] y1 = new double[5];
            double[] z1 = new double[5];
            double dps = 0.01;
            double num1 = 0.2;
            double num2 = sRel / 3.0;
            int[,] j1 = new int[30, 30];
            double[,] numArray10 = new double[30, 30];
            kChange = 0;
            double num3;
            double num4 = num3 = 0.0;
            double yy = num3;
            double xx = num3;
            double num5;
            double num6 = num5 = 0.0;
            double num7;
            double num8 = num7 = 0.0;
            double y3 = num7;
            double x3 = num7;
            double num9;
            double num10 = num9 = 0.0;
            double y4 = num9;
            double x4 = num9;
            double num11;
            double z2 = num11 = 0.0;
            double ym = num11;
            double xm = num11;
            int ip1;
            int ip2 = ip1 = 0;
            double yp;
            double xp = yp = 0.0;
            double num12;
            double y2 = num12 = 0.0;
            double x2 = num12;
            double y1_1 = num12;
            double x1_1 = num12;
            double num13;
            double num14 = num13 = 0.0;
            int num15 = kTin / 4;
            int i1 = -3;
            int num16 = 0;
            for (int i2 = 1; i2 <= num15; ++i2)
            {
                i1 += 4;
                numArray1[1] = xTin[i1];
                numArray2[1] = yTin[i1];
                numArray3[1] = zTin[i1];
                numArray1[2] = xTin[i1 + 1];
                numArray2[2] = yTin[i1 + 1];
                numArray3[2] = zTin[i1 + 1];
                numArray1[3] = xTin[i1 + 2];
                numArray2[3] = yTin[i1 + 2];
                numArray3[3] = zTin[i1 + 2];
                numArray1[4] = xTin[i1];
                numArray2[4] = yTin[i1];
                numArray3[4] = zTin[i1];
                double num17 = 0.0;
                double dist;
                for (int i3 = 2; i3 <= 4; ++i3)
                {
                    if (i3 == 2)
                    {
                        xx = numArray1[3];
                        yy = numArray2[3];
                        num4 = numArray3[3];
                    }
                    if (i3 == 3)
                    {
                        xx = numArray1[1];
                        yy = numArray2[1];
                        num4 = numArray3[1];
                    }
                    if (i3 == 4)
                    {
                        xx = numArray1[2];
                        yy = numArray2[2];
                        num4 = numArray3[2];
                    }
                    DistPnt(xx, yy, numArray1[i3 - 1], numArray2[i3 - 1], numArray1[i3], numArray2[i3], out dist, out ip2, out xp, out yp);
                    if (ip2 > 0)
                    {
                        double num18 = xp - numArray1[i3 - 1];
                        double num19 = yp - numArray2[i3 - 1];
                        double num20 = Math.Sqrt(num18 * num18 + num19 * num19);
                        double num21 = xp - numArray1[i3];
                        double num22 = yp - numArray2[i3];
                        double num23 = Math.Sqrt(num21 * num21 + num22 * num22);
                        if (num20 >= num23)
                            dist = num23 / num20;
                        if (num23 > num20)
                            dist = num20 / num23;
                        if (dist > num17)
                        {
                            num16 = i1;
                            num17 = dist;
                            x3 = xx;
                            y3 = yy;
                            num8 = num4;
                            x1_1 = numArray1[i3 - 1];
                            y1_1 = numArray2[i3 - 1];
                            num14 = numArray3[i3 - 1];
                            x2 = numArray1[i3];
                            y2 = numArray2[i3];
                            num13 = numArray3[i3];
                            xm = xp;
                            ym = yp;
                        }
                    }
                }
                if (num17 >= num1)
                {
                    if (i2 == num15)
                        break;
                    int num24 = 0;
                    int i4 = -3;
                    for (int i5 = 1; i5 <= num15; ++i5)
                    {
                        i4 += 4;
                        if (i4 != num16)
                        {
                            numArray7[1] = xTin[i4];
                            numArray8[1] = yTin[i4];
                            numArray9[1] = zTin[i4];
                            numArray7[2] = xTin[i4 + 1];
                            numArray8[2] = yTin[i4 + 1];
                            numArray9[2] = zTin[i4 + 1];
                            numArray7[3] = xTin[i4 + 2];
                            numArray8[3] = yTin[i4 + 2];
                            numArray9[3] = zTin[i4 + 2];
                            numArray7[4] = xTin[i4];
                            numArray8[4] = yTin[i4];
                            numArray9[4] = zTin[i4];
                            ip2 = 0;
                            for (int i6 = 2; i6 <= 4; ++i6)
                            {
                                if (i6 == 2)
                                {
                                    xx = numArray7[3];
                                    yy = numArray8[3];
                                    num4 = numArray9[3];
                                }
                                if (i6 == 3)
                                {
                                    xx = numArray7[1];
                                    yy = numArray8[1];
                                    num4 = numArray9[1];
                                }
                                if (i6 == 4)
                                {
                                    xx = numArray7[2];
                                    yy = numArray8[2];
                                    num4 = numArray9[2];
                                }
                                DistPnt(xm, ym, numArray7[i6 - 1], numArray8[i6 - 1], numArray7[i6], numArray8[i6], out dist, out ip1, out xp, out yp);
                                if (ip1 > 0 && dist < 0.003)
                                {
                                    ++ip2;
                                    x4 = xx;
                                    y4 = yy;
                                    num10 = num4;
                                    break;
                                }
                            }
                            if (ip2 > 0)
                            {
                                ++num24;
                                break;
                            }
                        }
                    }
                    if (num24 != 0)
                    {
                        ip2 = 1;
                        TwoLine(x1_1, y1_1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip2);
                        if (xm != 0.0 || ym != 0.0)
                        {
                            dist = 0.0;
                            double num25 = x1_1 - xm;
                            double num26 = y1_1 - ym;
                            double num27 = Math.Sqrt(num25 * num25 + num26 * num26);
                            double num28 = x2 - xm;
                            double num29 = y2 - ym;
                            double num30 = Math.Sqrt(num28 * num28 + num29 * num29);
                            if (num27 >= num30)
                                dist = num30 / num27;
                            if (num30 > num27)
                                dist = num27 / num30;
                            if (dist >= num1)
                            {
                                double num31 = x3 - xm;
                                double num32 = y3 - ym;
                                double num33 = Math.Sqrt(num31 * num31 + num32 * num32);
                                double num34 = x4 - xm;
                                double num35 = y4 - ym;
                                double num36 = Math.Sqrt(num34 * num34 + num35 * num35);
                                if (num33 >= num36)
                                    dist = num36 / num33;
                                if (num36 > num33)
                                    dist = num33 / num36;
                                if (dist >= num1)
                                {
                                    double num37 = x2 - x1_1;
                                    double num38 = y2 - y1_1;
                                    double num39 = Math.Sqrt(num37 * num37 + num38 * num38);
                                    double num40 = xm - x1_1;
                                    double num41 = ym - y1_1;
                                    double num42 = Math.Sqrt(num40 * num40 + num41 * num41);
                                    double num43 = num14 + num42 * (num13 - num14) / num39;
                                    double num44 = x4 - x3;
                                    double num45 = y4 - y3;
                                    dist = Math.Sqrt(num44 * num44 + num45 * num45);
                                    double num46 = xm - x3;
                                    double num47 = ym - y3;
                                    double num48 = Math.Sqrt(num46 * num46 + num47 * num47);
                                    double num49 = num8 + num48 * (num10 - num8) / dist;
                                    double dm = Math.Abs(num43 - num49);
                                    if (dm >= num2)
                                    {
                                        int num50 = 4;
                                        numArray4[1] = x1_1;
                                        numArray5[1] = y1_1;
                                        numArray6[1] = num14;
                                        numArray4[2] = x3;
                                        numArray5[2] = y3;
                                        numArray6[2] = num8;
                                        numArray4[3] = x2;
                                        numArray5[3] = y2;
                                        numArray6[3] = num13;
                                        numArray4[4] = x4;
                                        numArray5[4] = y4;
                                        numArray6[4] = num10;
                                        double xt = (numArray4[1] + numArray4[2] + numArray4[3] + numArray4[4]) / 4.0;
                                        double yt = (numArray5[1] + numArray5[2] + numArray5[3] + numArray5[4]) / 4.0;
                                        x1[0] = numArray1[1];
                                        y1[0] = numArray2[1];
                                        z1[0] = numArray3[1];
                                        x1[1] = numArray1[2];
                                        y1[1] = numArray2[2];
                                        z1[1] = numArray3[2];
                                        x1[2] = numArray1[3];
                                        y1[2] = numArray2[3];
                                        z1[2] = numArray3[3];
                                        x1[3] = numArray1[4];
                                        y1[3] = numArray2[4];
                                        z1[3] = numArray3[4];
                                        double zt1 = 0.0;
                                        if (in_out(3, ref x1, ref y1, xt, yt) > 0)
                                            Treyg(x1, y1, z1, xt, yt, out zt1);
                                        x1[0] = numArray7[1];
                                        y1[0] = numArray8[1];
                                        z1[0] = numArray9[1];
                                        x1[1] = numArray7[2];
                                        y1[1] = numArray8[2];
                                        z1[1] = numArray9[2];
                                        x1[2] = numArray7[3];
                                        y1[2] = numArray8[3];
                                        z1[2] = numArray9[3];
                                        x1[3] = numArray7[4];
                                        y1[3] = numArray8[4];
                                        z1[3] = numArray9[4];
                                        if (zt1 == 0.0 && in_out(3, ref x1, ref y1, xt, yt) > 0)
                                            Treyg(x1, y1, z1, xt, yt, out zt1);
                                        x1[0] = x3;
                                        y1[0] = y3;
                                        z1[0] = num8;
                                        x1[1] = x4;
                                        y1[1] = y4;
                                        z1[1] = num10;
                                        x1[2] = x2;
                                        y1[2] = y2;
                                        z1[2] = num13;
                                        x1[3] = x3;
                                        y1[3] = y3;
                                        z1[3] = num8;
                                        double zt2 = 0.0;
                                        ip2 = in_out(3, ref x1, ref y1, xt, yt);
                                        if (ip2 > 0)
                                            Treyg(x1, y1, z1, xt, yt, out zt2);
                                        x1[0] = x1_1;
                                        y1[0] = y1_1;
                                        z1[0] = num14;
                                        x1[1] = x4;
                                        y1[1] = y4;
                                        z1[1] = num10;
                                        x1[2] = x3;
                                        y1[2] = y3;
                                        z1[2] = num8;
                                        x1[3] = x1_1;
                                        y1[3] = y1_1;
                                        z1[3] = num14;
                                        if (zt2 == 0.0)
                                        {
                                            ip2 = in_out(3, ref x1, ref y1, xt, yt);
                                            if (ip2 > 0)
                                                Treyg(x1, y1, z1, xt, yt, out zt2);
                                        }
                                        int k = 0;
                                        int i7 = -3;
                                        for (int i8 = 1; i8 <= num15; ++i8)
                                        {
                                            i7 += 4;
                                            numArray1[1] = xTin[i7];
                                            numArray2[1] = yTin[i7];
                                            numArray3[1] = zTin[i7];
                                            numArray1[2] = xTin[i7 + 1];
                                            numArray2[2] = yTin[i7 + 1];
                                            numArray3[2] = zTin[i7 + 1];
                                            numArray1[3] = xTin[i7 + 2];
                                            numArray2[3] = yTin[i7 + 2];
                                            numArray3[3] = zTin[i7 + 2];
                                            numArray1[4] = xTin[i7];
                                            numArray2[4] = yTin[i7];
                                            numArray3[4] = zTin[i7];
                                            ip2 = 0;
                                            for (int i9 = 1; i9 <= 3; ++i9)
                                            {
                                                for (int i10 = 1; i10 <= num50; ++i10)
                                                {
                                                    double num51 = numArray1[i9] - numArray4[i10];
                                                    double num52 = numArray2[i9] - numArray5[i10];
                                                    dist = Math.Sqrt(num51 * num51 + num52 * num52);
                                                    if (dist < 0.003)
                                                    {
                                                        ++ip2;
                                                        break;
                                                    }
                                                }
                                                if (ip2 > 0)
                                                    break;
                                            }
                                            if (ip2 != 0)
                                            {
                                                for (int i11 = 1; i11 <= 3; ++i11)
                                                {
                                                    ++k;
                                                    x[k] = numArray1[i11];
                                                    y[k] = numArray2[i11];
                                                    z[k] = numArray3[i11];
                                                }
                                            }
                                        }
                                        for (int i12 = 1; i12 < k; ++i12)
                                        {
                                            if (x[i12] != 0.0 || y[i12] != 0.0)
                                            {
                                                ip2 = i12 + 1;
                                                for (int i13 = ip2; i13 <= k; ++i13)
                                                {
                                                    if (x[i13] != 0.0 || y[i13] != 0.0)
                                                    {
                                                        double num53 = x[i12] - x[i13];
                                                        double num54 = y[i12] - y[i13];
                                                        dist = Math.Sqrt(num53 * num53 + num54 * num54);
                                                        if (dist < 0.003)
                                                        {
                                                            x[i13] = 0.0;
                                                            y[i13] = 0.0;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        int i14 = 0;
                                        for (int i15 = 1; i15 <= k; ++i15)
                                        {
                                            if (x[i15] != 0.0 || y[i15] != 0.0)
                                            {
                                                ++i14;
                                                x[i14] = x[i15];
                                                y[i14] = y[i15];
                                                z[i14] = z[i15];
                                            }
                                        }
                                        k = i14;
                                        double num55;
                                        double zh = num55 = 0.0;
                                        double yh = num55;
                                        double xh = num55;
                                        int num56;
                                        int n2 = num56 = 0;
                                        int n1 = num56;
                                        int ii = num56;
                                        int m = num56;
                                        double amin = dm = 0.0;
                                        Spl_apro(ref k, ref x, ref y, ref z, ref dps, ref xh, ref yh, ref zh, ref j1, ref numArray10, ref m, ref ii, ref n1, ref n2, ref amin, ref dm, ref ds);
                                        if (iParam == 1)
                                        {
                                            xp = xm - xh;
                                            yp = ym - yh;
                                            Vas2(k, ref xp, ref yp, ref m, ref n1, ref ii, ref n2, ref j1, ref numArray10, ref amin, ref dm, ref z2, ref ds);
                                            z2 += zh;
                                            double num57 = Math.Abs(num43 - z2);
                                            dist = Math.Abs(num49 - z2);
                                            if (dist < num57)
                                            {
                                                ++kChange;
                                                NewDiagonal(xm, ym, ref kTin, nTin, xTin, yTin, zTin);
                                            }
                                        }
                                        if (iParam == 2)
                                        {
                                            xp = xt - xh;
                                            yp = yt - yh;
                                            Vas2(k, ref xp, ref yp, ref m, ref n1, ref ii, ref n2, ref j1, ref numArray10, ref amin, ref dm, ref z2, ref ds);
                                            z2 += zh;
                                            double num58 = Math.Abs(zt1 - z2);
                                            dist = Math.Abs(zt2 - z2);
                                            if (dist < num58)
                                            {
                                                ++kChange;
                                                NewDiagonal(xm, ym, ref kTin, nTin, xTin, yTin, zTin);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void VertexAdd(
          int kCycle,
          int kLine,
          int[] k1,
          int[] k2,
          double[] radLine,
          double[] xLin,
          double[] yLin,
          int kPnt,
          double[] xPnt,
          double[] yPnt,
          double[] zPnt,
          out int kVert,
          double[] xVert,
          double[] yVert,
          double[] zVert,
          double[] xr,
          double[] yr,
          double[] zr,
          int[] nr,
          double[] radDop,
          double[] xDop,
          double[] yDop,
          int[] nDop)
        {
            int i1 = kPnt;
            kVert = 0;
            if (kCycle == 0)
                kCycle = 1;
            int kArray = 999999;
            doubleArray(xVert, ref kArray);
            doubleArray(yVert, ref kArray);
            doubleArray(zVert, ref kArray);
            kArray -= 3;
            for (int i2 = 1; i2 <= kCycle; ++i2)
            {
                int num1 = 0;
                int ip;
                double xp;
                double yp;
                double dist;
                for (int i3 = 1; i3 <= kLine; ++i3)
                {
                    int num2 = k1[i3];
                    int num3 = k2[i3];
                    int i4 = 0;
                    for (int i5 = num2; i5 <= num3; ++i5)
                    {
                        ++i4;
                        xr[i4] = xLin[i5];
                        yr[i4] = yLin[i5];
                        zr[i4] = 0.0;
                    }
                    if (radLine[i3] > 0.0)
                    {
                        int i6 = 0;
                        for (int i7 = 1; i7 <= i4; ++i7)
                        {
                            for (int i8 = 0; i8 <= i1; ++i8)
                            {
                                double num4 = xr[i7] - xPnt[i8];
                                double num5 = yr[i7] - yPnt[i8];
                                if (Math.Sqrt(num4 * num4 + num5 * num5) < 0.003)
                                {
                                    zr[i7] = zPnt[i8];
                                    ++i6;
                                    nr[i6] = i7;
                                    break;
                                }
                            }
                        }
                        for (int i9 = 2; i9 <= i6; ++i9)
                        {
                            int i10 = nr[i9 - 1];
                            int i11 = nr[i9];
                            ip = i11 - i10;
                            if (ip >= 7)
                            {
                                int i12 = (i10 + i11) / 2;
                                xp = xr[i12];
                                yp = yr[i12];
                                double num6 = 0.5 * (zr[i10] + zr[i11]);
                                double num7 = xp - xr[i10];
                                double num8 = yp - yr[i10];
                                double num9 = 2.0 * Math.Sqrt(num7 * num7 + num8 * num8);
                                ip = 0;
                                for (int i13 = 0; i13 <= i1; ++i13)
                                {
                                    double num10 = xr[i10] - xPnt[i13];
                                    double num11 = yr[i10] - yPnt[i13];
                                    dist = Math.Sqrt(num10 * num10 + num11 * num11);
                                    if (dist >= 0.003)
                                    {
                                        double num12 = xr[i11] - xPnt[i13];
                                        double num13 = yr[i11] - yPnt[i13];
                                        dist = Math.Sqrt(num12 * num12 + num13 * num13);
                                        if (dist >= 0.003)
                                        {
                                            double num14 = xp - xPnt[i13];
                                            double num15 = yp - yPnt[i13];
                                            dist = Math.Sqrt(num14 * num14 + num15 * num15);
                                            if (dist < num9)
                                            {
                                                ++ip;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (ip > 0)
                                {
                                    if (kVert > kArray)
                                    {
                                        int num16 = (int)MessageBox.Show("Индекс массива VertexAdd");
                                        return;
                                    }
                                    ++num1;
                                    ++kVert;
                                    xVert[kVert] = xp;
                                    yVert[kVert] = yp;
                                    zVert[kVert] = num6;
                                    ++i1;
                                    xPnt[i1] = xp;
                                    yPnt[i1] = yp;
                                    zPnt[i1] = num6;
                                }
                            }
                        }
                    }
                    else
                    {
                        for (int i14 = 1; i14 <= i4; ++i14)
                        {
                            for (int i15 = 0; i15 <= i1; ++i15)
                            {
                                double num17 = xr[i14] - xPnt[i15];
                                double num18 = yr[i14] - yPnt[i15];
                                if (Math.Sqrt(num17 * num17 + num18 * num18) < 0.003)
                                {
                                    zr[i14] = zPnt[i15];
                                    break;
                                }
                            }
                            if (zr[i14] == 0.0)
                            {
                                dist = 9999999.9;
                                for (int i16 = 0; i16 <= i1; ++i16)
                                {
                                    double num19 = xr[i14] - xPnt[i16];
                                    double num20 = yr[i14] - yPnt[i16];
                                    double num21 = Math.Sqrt(num19 * num19 + num20 * num20);
                                    if (num21 < dist)
                                    {
                                        dist = num21;
                                        zr[i14] = zPnt[i16];
                                    }
                                }
                            }
                        }
                        for (int i17 = 2; i17 <= i4; ++i17)
                        {
                            xp = 0.5 * (xr[i17 - 1] + xr[i17]);
                            yp = 0.5 * (yr[i17 - 1] + yr[i17]);
                            double num22 = 0.5 * (zr[i17 - 1] + zr[i17]);
                            double num23 = xr[i17] - xr[i17 - 1];
                            double num24 = yr[i17] - yr[i17 - 1];
                            double num25 = 0.5 * Math.Sqrt(num23 * num23 + num24 * num24);
                            ip = 0;
                            for (int i18 = 0; i18 <= i1; ++i18)
                            {
                                double num26 = xr[i17 - 1] - xPnt[i18];
                                double num27 = yr[i17 - 1] - yPnt[i18];
                                dist = Math.Sqrt(num26 * num26 + num27 * num27);
                                if (dist >= 0.003)
                                {
                                    double num28 = xr[i17] - xPnt[i18];
                                    double num29 = yr[i17] - yPnt[i18];
                                    dist = Math.Sqrt(num28 * num28 + num29 * num29);
                                    if (dist >= 0.003)
                                    {
                                        double num30 = xp - xPnt[i18];
                                        double num31 = yp - yPnt[i18];
                                        dist = Math.Sqrt(num30 * num30 + num31 * num31);
                                        if (dist < num25)
                                        {
                                            ++ip;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (ip > 0)
                            {
                                if (kVert > kArray)
                                {
                                    int num32 = (int)MessageBox.Show("Индекс массива VertexAdd");
                                    return;
                                }
                                ++num1;
                                ++kVert;
                                xVert[kVert] = xp;
                                yVert[kVert] = yp;
                                zVert[kVert] = num22;
                                ++i1;
                                xPnt[i1] = xp;
                                yPnt[i1] = yp;
                                zPnt[i1] = num22;
                            }
                        }
                    }
                }
                if (num1 == 0)
                    break;
                int i19 = 0;
                for (int i20 = 1; i20 <= kLine; ++i20)
                {
                    int i21 = k1[i20];
                    int num33 = k2[i20];
                    radDop[i20] = radLine[i20];
                    if (radLine[i20] > 0.0)
                    {
                        int num34 = 0;
                        for (int i22 = i21; i22 <= num33; ++i22)
                        {
                            ++num34;
                            ++i19;
                            xDop[i19] = xLin[i22];
                            yDop[i19] = yLin[i22];
                        }
                        nDop[i20] = num34;
                    }
                    else
                    {
                        int i23 = 1;
                        xr[i23] = xLin[i21];
                        yr[i23] = yLin[i21];
                        for (int i24 = i21 + 1; i24 <= num33; ++i24)
                        {
                            double x1 = xLin[i24 - 1];
                            double y1 = yLin[i24 - 1];
                            double x2 = xLin[i24];
                            double y2 = yLin[i24];
                            for (int i25 = 1; i25 <= kVert; ++i25)
                            {
                                double num35 = xVert[i25] - x1;
                                double num36 = yVert[i25] - y1;
                                if (Math.Sqrt(num35 * num35 + num36 * num36) >= 0.003)
                                {
                                    double num37 = xVert[i25] - x2;
                                    double num38 = yVert[i25] - y2;
                                    if (Math.Sqrt(num37 * num37 + num38 * num38) >= 0.003)
                                    {
                                        DistPnt(xVert[i25], yVert[i25], x1, y1, x2, y2, out dist, out ip, out xp, out yp);
                                        if (ip > 0 && dist < 0.003)
                                        {
                                            ++i23;
                                            xr[i23] = xp;
                                            yr[i23] = yp;
                                            break;
                                        }
                                    }
                                }
                            }
                            ++i23;
                            xr[i23] = x2;
                            yr[i23] = y2;
                        }
                        nDop[i20] = i23;
                        for (int i26 = 1; i26 <= i23; ++i26)
                        {
                            ++i19;
                            xDop[i19] = xr[i26];
                            yDop[i19] = yr[i26];
                        }
                    }
                }
                if (i19 > 0)
                {
                    for (int i27 = 1; i27 <= i19; ++i27)
                    {
                        xLin[i27] = xDop[i27];
                        yLin[i27] = yDop[i27];
                    }
                    k1[1] = 1;
                    k2[1] = nDop[1];
                    radLine[1] = radDop[1];
                    if (kLine > 1)
                    {
                        for (int i28 = 2; i28 <= kLine; ++i28)
                        {
                            k1[i28] = k2[i28 - 1] + 1;
                            k2[i28] = k2[i28 - 1] + nDop[i28];
                            radLine[i28] = radDop[i28];
                        }
                    }
                }
            }
        }

        public static void TreDelete(
          double xSelect,
          double ySelect,
          ref int kt,
          ref int[] nt,
          ref double[] xt,
          ref double[] yt,
          ref double[] zt)
        {
            int[] numArray1 = new int[5];
            double[] x = new double[5];
            double[] y = new double[5];
            double[] numArray2 = new double[5];
            double num1;
            double num2 = num1 = 0.0;
            Cursor.Current = Cursors.WaitCursor;
            int kArray = 999999;
            intArray(nt, ref kArray);
            doubleArray(xt, ref kArray);
            doubleArray(yt, ref kArray);
            doubleArray(zt, ref kArray);
            if (kt > kArray)
            {
                int num3 = (int)MessageBox.Show("Индекс массива TreDelete");
            }
            else
            {
                int num4 = kt / 4;
                int i1 = -3;
                int i2 = 0;
                int num5 = 0;
                for (int i3 = 1; i3 <= num4; ++i3)
                {
                    i1 += 4;
                    numArray1[0] = nt[i1];
                    x[0] = xt[i1];
                    y[0] = yt[i1];
                    numArray2[0] = zt[i1];
                    numArray1[1] = nt[i1 + 1];
                    x[1] = xt[i1 + 1];
                    y[1] = yt[i1 + 1];
                    numArray2[1] = zt[i1 + 1];
                    numArray1[2] = nt[i1 + 2];
                    x[2] = xt[i1 + 2];
                    y[2] = yt[i1 + 2];
                    numArray2[2] = zt[i1 + 2];
                    numArray1[3] = nt[i1 + 3];
                    x[3] = xt[i1 + 3];
                    y[3] = yt[i1 + 3];
                    numArray2[3] = zt[i1 + 3];
                    if (in_out(3, ref x, ref y, xSelect, ySelect) > 0)
                    {
                        ++num5;
                    }
                    else
                    {
                        int i4 = i2 + 1;
                        nt[i4] = numArray1[0];
                        xt[i4] = x[0];
                        yt[i4] = y[0];
                        zt[i4] = numArray2[0];
                        int i5 = i4 + 1;
                        nt[i5] = numArray1[1];
                        xt[i5] = x[1];
                        yt[i5] = y[1];
                        zt[i5] = numArray2[1];
                        int i6 = i5 + 1;
                        nt[i6] = numArray1[2];
                        xt[i6] = x[2];
                        yt[i6] = y[2];
                        zt[i6] = numArray2[2];
                        i2 = i6 + 1;
                        nt[i2] = numArray1[3];
                        xt[i2] = x[3];
                        yt[i2] = y[3];
                        zt[i2] = numArray2[3];
                    }
                }
                kt = i2;
                if (num5 > 0)
                    return;
                double num6 = 9999999.9;
                int num7 = 0;
                int i7 = -3;
                for (int i8 = 1; i8 <= num4; ++i8)
                {
                    i7 += 4;
                    x[1] = xt[i7];
                    y[1] = yt[i7];
                    x[2] = xt[i7 + 1];
                    y[2] = yt[i7 + 1];
                    x[3] = xt[i7 + 2];
                    y[3] = yt[i7 + 2];
                    double num8 = (x[1] + x[2] + x[3]) / 3.0;
                    double num9 = (y[1] + y[2] + y[3]) / 3.0;
                    double num10 = xSelect - num8;
                    double num11 = ySelect - num9;
                    double num12 = Math.Sqrt(num10 * num10 + num11 * num11);
                    if (num12 < num6)
                    {
                        num6 = num12;
                        num7 = i7;
                    }
                }
                int i9 = -3;
                int i10 = 0;
                for (int i11 = 1; i11 <= num4; ++i11)
                {
                    i9 += 4;
                    numArray1[0] = nt[i9];
                    x[0] = xt[i9];
                    y[0] = yt[i9];
                    numArray2[0] = zt[i9];
                    numArray1[1] = nt[i9 + 1];
                    x[1] = xt[i9 + 1];
                    y[1] = yt[i9 + 1];
                    numArray2[1] = zt[i9 + 1];
                    numArray1[2] = nt[i9 + 2];
                    x[2] = xt[i9 + 2];
                    y[2] = yt[i9 + 2];
                    numArray2[2] = zt[i9 + 2];
                    numArray1[3] = nt[i9 + 3];
                    x[3] = xt[i9 + 3];
                    y[3] = yt[i9 + 3];
                    numArray2[3] = zt[i9 + 3];
                    if (num7 != i9)
                    {
                        int i12 = i10 + 1;
                        nt[i12] = numArray1[0];
                        xt[i12] = x[0];
                        yt[i12] = y[0];
                        zt[i12] = numArray2[0];
                        int i13 = i12 + 1;
                        nt[i13] = numArray1[1];
                        xt[i13] = x[1];
                        yt[i13] = y[1];
                        zt[i13] = numArray2[1];
                        int i14 = i13 + 1;
                        nt[i14] = numArray1[2];
                        xt[i14] = x[2];
                        yt[i14] = y[2];
                        zt[i14] = numArray2[2];
                        i10 = i14 + 1;
                        nt[i10] = numArray1[3];
                        xt[i10] = x[3];
                        yt[i10] = y[3];
                        zt[i10] = numArray2[3];
                    }
                }
                kt = i10;
            }
        }

        public static void AddTriangle(
          ref int kNew,
          ref double[] xNew,
          ref double[] yNew,
          int kp,
          double[] xp,
          double[] yp,
          double[] zp,
          ref int kt,
          ref int[] nt,
          ref double[] xt,
          ref double[] yt,
          ref double[] zt)
        {
            int[] numArray1 = new int[9];
            double[] numArray2 = new double[9];
            double[] numArray3 = new double[9];
            double[] numArray4 = new double[9];
            int kArray1 = 999999;
            doubleArray(xNew, ref kArray1);
            doubleArray(yNew, ref kArray1);
            int num1 = kArray1 - 5;
            if (kNew > num1)
            {
                int num2 = (int)MessageBox.Show("Индекс массива AddTriangle");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(xp, ref kArray2);
                doubleArray(yp, ref kArray2);
                doubleArray(zp, ref kArray2);
                int num3 = kArray2 - 5;
                if (kp > num3)
                {
                    int num4 = (int)MessageBox.Show("Индекс массива AddTriangle");
                }
                else
                {
                    int kArray3 = 999999;
                    intArray(nt, ref kArray3);
                    doubleArray(xt, ref kArray3);
                    doubleArray(yt, ref kArray3);
                    doubleArray(zt, ref kArray3);
                    kArray3 -= 5;
                    if (kt > kArray3)
                    {
                        int num5 = (int)MessageBox.Show("Индекс массива AddTriangle");
                    }
                    else
                    {
                        int num6 = 0;
                        if (kt < 4)
                            return;
                        for (int i = 1; i <= kt; ++i)
                        {
                            if (nt[i] > num6)
                                num6 = nt[i];
                        }
                        int i1 = 0;
                        for (int i2 = 1; i2 <= kNew; ++i2)
                        {
                            ++i1;
                            numArray1[i1] = 0;
                            numArray2[i1] = xNew[i2];
                            numArray3[i1] = yNew[i2];
                            numArray4[i1] = 0.0;
                        }
                        for (int i3 = 1; i3 <= i1; ++i3)
                        {
                            double num7 = 999999.0;
                            int i4 = 0;
                            for (int i5 = 1; i5 <= kp; ++i5)
                            {
                                double num8 = numArray2[i3] - xp[i5];
                                double num9 = numArray3[i3] - yp[i5];
                                double num10 = Math.Sqrt(num8 * num8 + num9 * num9);
                                if (num7 > num10)
                                {
                                    num7 = num10;
                                    i4 = i5;
                                }
                            }
                            int i6 = 0;
                            double num11 = 9999999.9;
                            for (int i7 = 1; i7 <= kt; ++i7)
                            {
                                double num12 = numArray2[i3] - xt[i7];
                                double num13 = numArray3[i3] - yt[i7];
                                double num14 = Math.Sqrt(num12 * num12 + num13 * num13);
                                if (num14 < num11)
                                {
                                    num11 = num14;
                                    i6 = i7;
                                }
                            }
                            if (num11 <= num7)
                            {
                                numArray1[i3] = nt[i6];
                                numArray2[i3] = xt[i6];
                                numArray3[i3] = yt[i6];
                                numArray4[i3] = zt[i6];
                            }
                            if (num7 < num11)
                            {
                                numArray2[i3] = xp[i4];
                                numArray3[i3] = yp[i4];
                                numArray4[i3] = zp[i4];
                            }
                        }
                        for (int i8 = 1; i8 < i1; ++i8)
                        {
                            if (numArray2[i8] != 0.0 || numArray3[i8] != 0.0)
                            {
                                for (int i9 = i8 + 1; i9 <= i1; ++i9)
                                {
                                    if (numArray2[i9] != 0.0 || numArray3[i9] != 0.0)
                                    {
                                        double num15 = numArray2[i8] - numArray2[i9];
                                        double num16 = numArray3[i8] - numArray3[i9];
                                        if (Math.Sqrt(num15 * num15 + num16 * num16) < 0.003)
                                        {
                                            numArray2[i9] = 0.0;
                                            numArray3[i9] = 0.0;
                                        }
                                    }
                                }
                            }
                        }
                        int i10 = 0;
                        for (int i11 = 1; i11 <= i1; ++i11)
                        {
                            if (numArray2[i11] != 0.0 || numArray3[i11] != 0.0)
                            {
                                if (numArray1[i11] == 0)
                                {
                                    ++num6;
                                    numArray1[i11] = num6;
                                }
                                ++i10;
                                numArray1[i10] = numArray1[i11];
                                numArray2[i10] = numArray2[i11];
                                numArray3[i10] = numArray3[i11];
                                numArray4[i10] = numArray4[i11];
                            }
                        }
                        int num17 = i10;
                        if (num17 < 3)
                        {
                            int num18 = (int)MessageBox.Show("Выбраны точки < 3", nameof(AddTriangle));
                        }
                        else
                        {
                            int i12 = num17 + 1;
                            numArray1[i12] = numArray1[1];
                            numArray2[i12] = numArray2[1];
                            numArray3[i12] = numArray3[1];
                            numArray4[i12] = numArray4[1];
                            for (int i13 = 1; i13 <= i12; ++i13)
                            {
                                if (kt > kArray3)
                                {
                                    int num19 = (int)MessageBox.Show("Индекс массива AddTriangle");
                                    break;
                                }
                                ++kt;
                                nt[kt] = numArray1[i13];
                                xt[kt] = numArray2[i13];
                                yt[kt] = numArray3[i13];
                                zt[kt] = numArray4[i13];
                            }
                        }
                    }
                }
            }
        }

        public static void BorderBuilding(
          ref int kPnt,
          ref double[] xPnt,
          ref double[] yPnt,
          out int kOut,
          double[] xOut,
          double[] yOut,
          int[] na,
          double[] xa,
          double[] ya,
          double[] azim,
          int[] nOut,
          int[] ni,
          StatusBarPanel panel)
        {
            int num1 = 30;
            double num2 = 3.1415926;
            kOut = 0;
            double ym;
            double xm = ym = 0.0;
            panel.Text = "Подождите..... Сортировка точек";
            Cursor.Current = Cursors.WaitCursor;
            int kArray = 999999;
            doubleArray(xOut, ref kArray);
            doubleArray(yOut, ref kArray);
            doubleArray(xa, ref kArray);
            doubleArray(ya, ref kArray);
            doubleArray(azim, ref kArray);
            int num3 = kArray - 3;
            double num4 = 9999999.9;
            double num5 = 9999999.9;
            double num6 = -9999999.9;
            double num7 = -9999999.9;
            for (int i = 0; i <= kPnt; ++i)
            {
                if (xPnt[i] < num4)
                    num4 = xPnt[i];
                if (yPnt[i] < num5)
                    num5 = yPnt[i];
                if (xPnt[i] > num6)
                    num6 = xPnt[i];
                if (yPnt[i] > num7)
                    num7 = yPnt[i];
            }
            int ip;
            double xp;
            double yp;
            for (int i1 = 0; i1 < kPnt; ++i1)
            {
                ip = i1 + 1;
                for (int i2 = ip; i2 <= kPnt; ++i2)
                {
                    if (yPnt[i1] > yPnt[i2])
                    {
                        xp = xPnt[i1];
                        yp = yPnt[i1];
                        xPnt[i1] = xPnt[i2];
                        yPnt[i1] = yPnt[i2];
                        xPnt[i2] = xp;
                        yPnt[i2] = yp;
                    }
                }
            }
            double num8 = (num6 - num4) * (num7 - num5);
            double num9 = Math.Sqrt(Convert.ToDouble((double)num1 * num8 / (double)kPnt));
            int i3 = 1;
            na[i3] = 0;
            xa[i3] = xPnt[0];
            ya[i3] = yPnt[0];
            double dirLine1 = num2 + 0.5 * num2;
            int num10 = 1;
            for (int i4 = 0; i4 <= kPnt; ++i4)
            {
                panel.Text = "Подождите..... Построение границы-1- " + Convert.ToString(i4);
                if (i3 > 1)
                    num10 = 2;
                int kDir = -1;
                for (int i5 = 0; i5 <= kPnt; ++i5)
                {
                    ip = 0;
                    if (i3 > 0)
                    {
                        for (int i6 = num10; i6 <= i3; ++i6)
                        {
                            if (na[i6] == i5)
                            {
                                ++ip;
                                break;
                            }
                        }
                    }
                    if (ip <= 0)
                    {
                        int num11 = 0;
                        if (i3 > 2)
                        {
                            double x3 = xa[i3];
                            double y3 = ya[i3];
                            double x4 = xPnt[i5];
                            double y4 = yPnt[i5];
                            for (int i7 = 2; i7 < i3; ++i7)
                            {
                                double x1 = xa[i7 - 1];
                                double y1 = ya[i7 - 1];
                                double x2 = xa[i7];
                                double y2 = ya[i7];
                                xm = 0.0;
                                ym = 0.0;
                                ip = 1;
                                TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip);
                                if (xm != 0.0 && ym != 0.0)
                                {
                                    double num12 = xa[1] - xm;
                                    double num13 = ya[1] - ym;
                                    if (Math.Sqrt(num12 * num12 + num13 * num13) >= 0.003)
                                    {
                                        ++num11;
                                        break;
                                    }
                                    break;
                                }
                            }
                        }
                        if (num11 <= 0)
                        {
                            double num14 = xPnt[i5] - xa[i3];
                            double num15 = yPnt[i5] - ya[i3];
                            if (Math.Sqrt(num14 * num14 + num15 * num15) <= num9)
                            {
                                double x = xPnt[i5] - xa[i3];
                                double num16 = Math.Atan2(yPnt[i5] - ya[i3], x);
                                if (num16 < 0.0)
                                    num16 += 2.0 * num2;
                                ++kDir;
                                azim[kDir] = num16;
                                ni[kDir] = i5;
                                xOut[kDir] = xPnt[i5];
                                yOut[kDir] = yPnt[i5];
                            }
                        }
                    }
                }
                if (kDir >= 0)
                {
                    NearLine(kDir, azim, ni, dirLine1, out ip, 1);
                    xm = xPnt[ip];
                    ym = yPnt[ip];
                    ++i3;
                    na[i3] = ip;
                    xa[i3] = xm;
                    ya[i3] = ym;
                    double num17 = xa[i3] - xa[1];
                    double num18 = ya[i3] - ya[1];
                    if (Math.Sqrt(num17 * num17 + num18 * num18) >= 0.003)
                    {
                        double x = xa[i3 - 1] - xa[i3];
                        double num19 = Math.Atan2(ya[i3 - 1] - ya[i3], x);
                        if (num19 < 0.0)
                            num19 += 2.0 * num2;
                        dirLine1 = num19 + 0.03 * num2;
                        if (dirLine1 >= 2.0 * num2)
                            dirLine1 -= 2.0 * num2;
                    }
                    else
                        break;
                }
                else
                    break;
            }
            if (i3 < 4)
                return;
            int i8 = -1;
            for (int i9 = 1; i9 <= i3; ++i9)
            {
                ++i8;
                nOut[i8] = na[i9];
                xOut[i8] = xa[i9];
                yOut[i8] = ya[i9];
            }
            kOut = i8;
            double num20 = xOut[kOut] - xOut[0];
            double num21 = yOut[kOut] - yOut[0];
            if (Math.Sqrt(num20 * num20 + num21 * num21) > 0.003)
            {
                i3 = 1;
                na[i3] = 0;
                xa[i3] = xPnt[0];
                ya[i3] = yPnt[0];
                double dirLine2 = num2 + 0.5 * num2;
                int num22 = 1;
                for (int i10 = 0; i10 <= kPnt; ++i10)
                {
                    panel.Text = "Подождите.....Построение границы-2- " + Convert.ToString(i10);
                    if (i3 > 1)
                        num22 = 2;
                    int kDir = -1;
                    for (int i11 = 0; i11 <= kPnt; ++i11)
                    {
                        ip = 0;
                        if (i3 > 0)
                        {
                            for (int i12 = num22; i12 <= i3; ++i12)
                            {
                                if (na[i12] == i11)
                                {
                                    ++ip;
                                    break;
                                }
                            }
                        }
                        if (ip <= 0)
                        {
                            int num23 = 0;
                            if (i3 > 2)
                            {
                                double x3 = xa[i3];
                                double y3 = ya[i3];
                                double x4 = xPnt[i11];
                                double y4 = yPnt[i11];
                                for (int i13 = 2; i13 < i3; ++i13)
                                {
                                    double x1 = xa[i13 - 1];
                                    double y1 = ya[i13 - 1];
                                    double x2 = xa[i13];
                                    double y2 = ya[i13];
                                    xm = 0.0;
                                    ym = 0.0;
                                    ip = 1;
                                    TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip);
                                    if (xm != 0.0 && ym != 0.0)
                                    {
                                        double num24 = xa[1] - xm;
                                        double num25 = ya[1] - ym;
                                        if (Math.Sqrt(num24 * num24 + num25 * num25) >= 0.003)
                                        {
                                            ++num23;
                                            break;
                                        }
                                        break;
                                    }
                                }
                            }
                            if (num23 <= 0)
                            {
                                double num26 = xPnt[i11] - xa[i3];
                                double num27 = yPnt[i11] - ya[i3];
                                if (Math.Sqrt(num26 * num26 + num27 * num27) <= num9)
                                {
                                    double x = xPnt[i11] - xa[i3];
                                    double num28 = Math.Atan2(yPnt[i11] - ya[i3], x);
                                    if (num28 < 0.0)
                                        num28 += 2.0 * num2;
                                    ++kDir;
                                    azim[kDir] = num28;
                                    ni[kDir] = i11;
                                    xOut[kDir] = xPnt[i11];
                                    yOut[kDir] = yPnt[i11];
                                }
                            }
                        }
                    }
                    if (kDir >= 0)
                    {
                        NearLine(kDir, azim, ni, dirLine2, out ip, 2);
                        xm = xPnt[ip];
                        ym = yPnt[ip];
                        ++i3;
                        na[i3] = ip;
                        xa[i3] = xm;
                        ya[i3] = ym;
                        double num29 = xa[i3] - xa[1];
                        double num30 = ya[i3] - ya[1];
                        if (Math.Sqrt(num29 * num29 + num30 * num30) >= 0.003)
                        {
                            double x = xa[i3 - 1] - xa[i3];
                            double num31 = Math.Atan2(ya[i3 - 1] - ya[i3], x);
                            if (num31 < 0.0)
                                num31 += 2.0 * num2;
                            dirLine2 = num31 - 0.5 * num2;
                            if (dirLine2 < 0.0)
                                dirLine2 += 2.0 * num2;
                        }
                        else
                            break;
                    }
                    else
                        break;
                }
                if (i3 < 4)
                    return;
                int i14 = -1;
                for (int i15 = 1; i15 <= i3; ++i15)
                {
                    ++i14;
                    nOut[i14] = na[i15];
                    xOut[i14] = xa[i15];
                    yOut[i14] = ya[i15];
                }
                kOut = i14;
            }
            int i16 = 0;
            nOut[i16] = na[1];
            xOut[i16] = xa[1];
            yOut[i16] = ya[1];
            double num32;
            double num33 = num32 = 0.0;
            for (int i17 = 1; i17 <= kPnt; ++i17)
            {
                panel.Text = "Подождите.....Корректировка границы " + Convert.ToString(i17);
                int num34 = 0;
                i16 = 0;
                nOut[i16] = na[1];
                xOut[i16] = xa[1];
                yOut[i16] = ya[1];
                for (int i18 = 2; i18 <= i3; ++i18)
                {
                    double x1 = xa[i18 - 1];
                    double y1 = ya[i18 - 1];
                    double x2 = xa[i18];
                    double y2 = ya[i18];
                    double num35 = x2 - x1;
                    double num36 = y2 - y1;
                    double num37 = Math.Sqrt(num35 * num35 + num36 * num36);
                    double num38 = 9999999.0;
                    int num39 = -1;
                    for (int i19 = 0; i19 <= kPnt; ++i19)
                    {
                        ip = 0;
                        for (int i20 = 1; i20 <= i3; ++i20)
                        {
                            if (na[i20] == i19)
                            {
                                ++ip;
                                break;
                            }
                        }
                        if (ip <= 0)
                        {
                            double num40 = xPnt[i19] - x1;
                            double num41 = yPnt[i19] - y1;
                            if (Math.Sqrt(num40 * num40 + num41 * num41) <= num37)
                            {
                                double num42 = xPnt[i19] - x2;
                                double num43 = yPnt[i19] - y2;
                                if (Math.Sqrt(num42 * num42 + num43 * num43) <= num37)
                                {
                                    double dist;
                                    DistPnt(xPnt[i19], yPnt[i19], x1, y1, x2, y2, out dist, out ip, out xp, out yp);
                                    if (ip != 0)
                                    {
                                        double num44 = xp - x1;
                                        double num45 = yp - y1;
                                        double num46 = Math.Sqrt(num44 * num44 + num45 * num45);
                                        double num47 = xp - x2;
                                        double num48 = yp - y2;
                                        double num49 = Math.Sqrt(num47 * num47 + num48 * num48);
                                        if (num46 > 0.05 * num37 && num49 > 0.05 * num37 && num38 > dist)
                                        {
                                            num38 = dist;
                                            num39 = i19;
                                            xm = xPnt[i19];
                                            ym = yPnt[i19];
                                            num33 = xp;
                                            num32 = yp;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (num38 < 0.16 * num37)
                    {
                        if (i16 > num3)
                        {
                            int num50 = (int)MessageBox.Show("Индекс массива PolyExterior");
                            return;
                        }
                        ++num34;
                        ++i16;
                        nOut[i16] = num39;
                        xOut[i16] = xm;
                        yOut[i16] = ym;
                    }
                    if (i16 > num3)
                    {
                        int num51 = (int)MessageBox.Show("Индекс массива PolyExterior");
                        return;
                    }
                    ++i16;
                    nOut[i16] = na[i18];
                    xOut[i16] = xa[i18];
                    yOut[i16] = ya[i18];
                }
                if (num34 != 0)
                {
                    i3 = 0;
                    for (int i21 = 0; i21 <= i16; ++i21)
                    {
                        if (i3 > num3)
                        {
                            int num52 = (int)MessageBox.Show("Индекс массива PolyExterior");
                            return;
                        }
                        ++i3;
                        na[i3] = nOut[i21];
                        xa[i3] = xOut[i21];
                        ya[i3] = yOut[i21];
                    }
                }
                else
                    break;
            }
            kOut = i16;
            panel.Text = "Готово...";
        }

        public static void TinCreate(
          string fileAdd,
          int kBorder,
          double[] xBorder,
          double[] yBorder,
          int kPntVert,
          int[] nHeig,
          double[] xPnt,
          double[] yPnt,
          double[] zPnt,
          out int kSqu,
          double[] xWork1,
          double[] yWork1,
          double[] xWork2,
          double[] yWork2,
          int[] nDop1,
          int[] nDop2,
          int[] nDop3,
          int[] nPik,
          double[] xPik,
          double[] yPik,
          double[] zPik,
          out int kTriang,
          int[] nTre,
          double[] xTre,
          double[] yTre,
          double[] zTre,
          int[] nWork1,
          double[] xAdd,
          double[] yAdd,
          double[] zAdd,
          int[] nSour1,
          int[] nSour2,
          int[] nSpot,
          double[] xSpot,
          double[] ySpot,
          double[] zSpot,
          double[] xOut,
          double[] yOut,
          int[] nWork2,
          int[] np1,
          int[] np2,
          double[] xDop,
          double[] yDop,
          double[] zDop,
          int[] nCent,
          double[] xCent,
          double[] yCent,
          double[] zCent,
          double[] xPol,
          double[] yPol,
          int[] nWork,
          double[] xWork,
          double[] yWork,
          double[] zWork,
          int[] nParc,
          double[] xParc,
          double[] yParc,
          double[] zParc,
          double[] pWork,
          double[] rWork,
          double[] xSel,
          double[] ySel,
          int kMaxTre,
          StatusBarPanel panel1)
        {
            kTriang = 0;
            kSqu = 0;
            int kArray = 999999;
            intArray(nTre, ref kArray);
            doubleArray(xTre, ref kArray);
            doubleArray(yTre, ref kArray);
            doubleArray(zTre, ref kArray);
            int num1 = kArray - 4;
            DivideArea(kBorder, xBorder, yBorder, kPntVert, nHeig, xPnt, yPnt, zPnt, out kSqu, xWork1, yWork1, xWork2, yWork2, nDop1, nDop2, nDop3, nPik, xPik, yPik, zPik, out kTriang, nTre, xTre, yTre, zTre, nWork1, xAdd, yAdd, zAdd, nSour1, nSour2, nSpot, xSpot, ySpot, zSpot, xOut, yOut, nWork2, np1, np2, xDop, yDop, panel1);
            if (kTriang > num1)
            {
                int num2 = (int)MessageBox.Show("Индекс массива TinCreate");
            }
            else
            {
                panel1.Text = "Подождите......TIN сортировка - 1";
                TinInBorder(kBorder, xBorder, yBorder, ref kTriang, nTre, xTre, yTre, zTre);
                panel1.Text = "Готов..";
                TreArea(fileAdd, kSqu, xWork1, yWork1, xWork2, yWork2, nDop1, nDop2, nDop3, nPik, xPik, yPik, zPik, ref kTriang, ref nTre, ref xTre, ref yTre, ref zTre, nWork1, xDop, yDop, zDop, nWork2, xAdd, yAdd, zAdd, nCent, xCent, yCent, zCent, xPol, yPol, nSpot, xSpot, ySpot, zSpot, nWork, xWork, yWork, zWork, xOut, yOut, nParc, xParc, yParc, zParc, pWork, rWork, xSel, ySel, kMaxTre, panel1);
                if (kTriang > num1)
                {
                    int num3 = (int)MessageBox.Show("Индекс массива TinCreate");
                }
                else
                {
                    panel1.Text = "Подождите......TIN сортировка - 2";
                    TinInBorder(kBorder, xBorder, yBorder, ref kTriang, nTre, xTre, yTre, zTre);
                    panel1.Text = "Готово..";
                    panel1.Text = "Подождите......TIN коррекция";
                    TriangleForm(ref kTriang, nTre, xTre, yTre, zTre, panel1);
                    panel1.Text = "Готов..";
                    for (int i1 = 1; i1 <= kTriang; ++i1)
                    {
                        for (int i2 = 0; i2 <= kPntVert; ++i2)
                        {
                            double num4 = xTre[i1] - xPnt[i2];
                            double num5 = yTre[i1] - yPnt[i2];
                            if (Math.Sqrt(num4 * num4 + num5 * num5) < 0.09)
                            {
                                zTre[i1] = zPnt[i2];
                                break;
                            }
                        }
                    }
                }
            }
        }

        public static void ContToDraw(
          string fileAdd,
          string fCurContour,
          double hSect,
          int kCont,
          double[] zcon,
          int[] k1,
          int[] k2,
          double[] xg,
          double[] yg,
          int[] ntd,
          double[] xtd,
          double[] ytd,
          double[] xnd,
          double[] ynd,
          double[] xta,
          double[] yta,
          double[] xSel,
          double[] ySel,
          StatusBarPanel panel1,
          int nVertex)
        {
            int num1 = 0;
            double num2 = 0.5;
            int kt = 0;
            double num3;
            double num4 = num3 = 0.0;
            int num5;
            int num6 = num5 = 0;
            double num7;
            double num8 = num7 = 0.0;
            int num9;
            int num10 = num9 = 0;
            panel1.Text = "Сглаживание контуров";
            double num11 = 0.0;
            if (hSect == 0.1)
                num11 = 10.0 * hSect;
            if (hSect == 0.2 || hSect == 1.0 || hSect == 2.0 || hSect == 10.0 || hSect == 20.0)
                num11 = 5.0 * hSect;
            if (hSect == 0.25 || hSect == 0.5 || hSect == 5.0 || hSect == 25.0)
                num11 = 4.0 * hSect;
            if (File.Exists(fileAdd))
                File.Delete(fileAdd);
            FileStream output1 = new FileStream(fileAdd, FileMode.CreateNew);
            BinaryWriter binaryWriter1 = new BinaryWriter((Stream)output1);
            int k3;
            double angle;
            for (int i1 = 1; i1 <= kCont; ++i1)
            {
                int num12 = k1[i1];
                int num13 = k2[i1];
                double num14 = zcon[i1];
                int i2 = -1;
                for (int i3 = num12; i3 <= num13; ++i3)
                {
                    ++i2;
                    xtd[i2] = xg[i3];
                    ytd[i2] = yg[i3];
                }
                if (i2 >= 2)
                {
                    int i4 = 0;
                    for (int i5 = 1; i5 <= i2; ++i5)
                    {
                        double num15 = xtd[i5] - xtd[i4];
                        double num16 = ytd[i5] - ytd[i4];
                        if (Math.Sqrt(num15 * num15 + num16 * num16) >= num2)
                        {
                            ++i4;
                            xtd[i4] = xtd[i5];
                            ytd[i4] = ytd[i5];
                        }
                    }
                    int k4 = i4;
                    if (k4 >= 2)
                    {
                        if (k4 > 4)
                        {
                            NewLine(ref k4, xtd, ytd, ntd, xnd, ynd, xta, yta, out kt, xSel, ySel);
                            if (kt < 1)
                                continue;
                        }
                        if (k4 < 5)
                        {
                            kt = k4;
                            for (int i6 = 0; i6 <= kt; ++i6)
                            {
                                xSel[i6] = xtd[i6];
                                ySel[i6] = ytd[i6];
                            }
                        }
                        int i7 = 0;
                        for (int i8 = 1; i8 <= kt; ++i8)
                        {
                            double num17 = xSel[i8] - xSel[i7];
                            double num18 = ySel[i8] - ySel[i7];
                            if (Math.Sqrt(num17 * num17 + num18 * num18) >= num2)
                            {
                                ++i7;
                                xSel[i7] = xSel[i8];
                                ySel[i7] = ySel[i8];
                            }
                        }
                        kt = i7;
                        int k5 = kt;
                        for (int i9 = 0; i9 <= k5; ++i9)
                        {
                            xtd[i9] = xSel[i9];
                            ytd[i9] = ySel[i9];
                        }
                        if (kt >= 2)
                        {
                            Line_Spl(kt, ref xSel, ref ySel, out k3, ref xta, ref yta, ref xnd, ref ynd, nVertex);
                            if (k3 >= 2)
                            {
                                int i10 = 0;
                                for (int i11 = 1; i11 <= k3; ++i11)
                                {
                                    double num19 = xta[i11] - xta[i10];
                                    double num20 = yta[i11] - yta[i10];
                                    double num21 = Math.Sqrt(num19 * num19 + num20 * num20);
                                    if ((num21 >= num2 || i11 >= k3) && (num21 >= 0.003 || i11 != k3))
                                    {
                                        ++i10;
                                        xta[i10] = xta[i11];
                                        yta[i10] = yta[i11];
                                    }
                                }
                                k3 = i10;
                                Smooth1(hSect, k5, xtd, ytd, k3, xta, yta);
                                double num22 = 0.0;
                                double num23 = 0.0;
                                int j1 = 0;
                                int j2 = 0;
                                double xins = 0.0;
                                double yins = 0.0;
                                angle = 0.0;
                                int int32 = Convert.ToInt32(num14 / num11 + 1E-05);
                                if (Math.Abs(num14 - (double)int32 * num11) < 0.01)
                                {
                                    CoordInscr(k3, xta, yta, out xins, out yins, out angle, out j1, out j2);
                                    num22 = xins;
                                    num23 = yins;
                                    Convert.ToInt32(num14 + 1E-06);
                                }
                                ++num1;
                                binaryWriter1.Write(k5);
                                for (int i12 = 0; i12 <= k5; ++i12)
                                {
                                    binaryWriter1.Write(xtd[i12]);
                                    binaryWriter1.Write(ytd[i12]);
                                }
                                binaryWriter1.Write(num14);
                                binaryWriter1.Write(angle);
                                binaryWriter1.Write(num22);
                                binaryWriter1.Write(num23);
                                binaryWriter1.Write(j1);
                                binaryWriter1.Write(j2);
                                binaryWriter1.Write(k3);
                                for (int i13 = 0; i13 <= k3; ++i13)
                                {
                                    binaryWriter1.Write(xta[i13]);
                                    binaryWriter1.Write(yta[i13]);
                                }
                            }
                        }
                    }
                }
            }
            binaryWriter1.Close();
            output1.Close();
            if (num1 == 0)
                return;
            kCont = num1;
            if (File.Exists(fCurContour))
                File.Delete(fCurContour);
            FileStream output2 = new FileStream(fCurContour, FileMode.CreateNew);
            BinaryWriter binaryWriter2 = new BinaryWriter((Stream)output2);
            binaryWriter2.Write(hSect);
            binaryWriter2.Write(kCont);
            FileStream input = new FileStream(fileAdd, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            try
            {
                for (int i14 = 1; i14 <= kCont; ++i14)
                {
                    int num24 = binaryReader.ReadInt32();
                    for (int i15 = 0; i15 <= num24; ++i15)
                    {
                        xtd[i15] = binaryReader.ReadDouble();
                        ytd[i15] = binaryReader.ReadDouble();
                    }
                    double num25 = binaryReader.ReadDouble();
                    angle = binaryReader.ReadDouble();
                    double num26 = binaryReader.ReadDouble();
                    double num27 = binaryReader.ReadDouble();
                    int num28 = binaryReader.ReadInt32();
                    int num29 = binaryReader.ReadInt32();
                    k3 = binaryReader.ReadInt32();
                    for (int i16 = 0; i16 <= k3; ++i16)
                    {
                        xta[i16] = binaryReader.ReadDouble();
                        yta[i16] = binaryReader.ReadDouble();
                    }
                    binaryWriter2.Write(num24);
                    for (int i17 = 0; i17 <= num24; ++i17)
                    {
                        binaryWriter2.Write(xtd[i17]);
                        binaryWriter2.Write(ytd[i17]);
                    }
                    binaryWriter2.Write(num25);
                    binaryWriter2.Write(angle);
                    binaryWriter2.Write(num26);
                    binaryWriter2.Write(num27);
                    binaryWriter2.Write(num28);
                    binaryWriter2.Write(num29);
                    binaryWriter2.Write(k3);
                    for (int i18 = 0; i18 <= k3; ++i18)
                    {
                        binaryWriter2.Write(xta[i18]);
                        binaryWriter2.Write(yta[i18]);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            finally
            {
                binaryWriter2.Close();
                output2.Close();
                binaryReader.Close();
                input.Close();
            }
        }

        public static void NewDiagonal(
          double xSel,
          double ySel,
          ref int kTin,
          int[] nTin,
          double[] xTin,
          double[] yTin,
          double[] zTin)
        {
            int[] numArray1 = new int[10];
            double[] numArray2 = new double[10];
            double[] numArray3 = new double[10];
            double[] numArray4 = new double[10];
            int[] numArray5 = new int[10];
            double[] numArray6 = new double[10];
            double[] numArray7 = new double[10];
            double[] numArray8 = new double[10];
            int num1;
            int i1 = num1 = 0;
            int ip1 = num1;
            int i2 = num1;
            int ip2 = num1;
            double num2;
            double num3 = num2 = 0.0;
            int num4;
            int num5 = num4 = 0;
            double num6;
            double num7 = num6 = 0.0;
            double num8;
            double num9 = num8 = 0.0;
            double num10;
            double num11 = num10 = 0.0;
            int num12 = kTin / 4;
            int i3 = -3;
            int num13 = 0;
            double num14 = 9999999.9;
            double dist;
            for (int i4 = 1; i4 <= num12; ++i4)
            {
                i3 += 4;
                numArray1[1] = nTin[i3];
                numArray2[1] = xTin[i3];
                numArray3[1] = yTin[i3];
                numArray4[1] = zTin[i3];
                numArray1[2] = nTin[i3 + 1];
                numArray2[2] = xTin[i3 + 1];
                numArray3[2] = yTin[i3 + 1];
                numArray4[2] = zTin[i3 + 1];
                numArray1[3] = nTin[i3 + 2];
                numArray2[3] = xTin[i3 + 2];
                numArray3[3] = yTin[i3 + 2];
                numArray4[3] = zTin[i3 + 2];
                numArray1[4] = nTin[i3];
                numArray2[4] = xTin[i3];
                numArray3[4] = yTin[i3];
                numArray4[4] = zTin[i3];
                for (int i5 = 2; i5 <= 4; ++i5)
                {
                    DistPnt(xSel, ySel, numArray2[i5 - 1], numArray3[i5 - 1], numArray2[i5], numArray3[i5], out dist, out ip2, out num3, out num2);
                    if (ip2 > 0 && num14 > dist)
                    {
                        num14 = dist;
                        num13 = i3;
                        i2 = i5;
                    }
                }
            }
            int i6 = -3;
            int num15 = 0;
            double num16 = 9999999.9;
            for (int i7 = 1; i7 <= num12; ++i7)
            {
                i6 += 4;
                if (num13 != i6)
                {
                    numArray1[1] = nTin[i6];
                    numArray2[1] = xTin[i6];
                    numArray3[1] = yTin[i6];
                    numArray4[1] = zTin[i6];
                    numArray1[2] = nTin[i6 + 1];
                    numArray2[2] = xTin[i6 + 1];
                    numArray3[2] = yTin[i6 + 1];
                    numArray4[2] = zTin[i6 + 1];
                    numArray1[3] = nTin[i6 + 2];
                    numArray2[3] = xTin[i6 + 2];
                    numArray3[3] = yTin[i6 + 2];
                    numArray4[3] = zTin[i6 + 2];
                    numArray1[4] = nTin[i6];
                    numArray2[4] = xTin[i6];
                    numArray3[4] = yTin[i6];
                    numArray4[4] = zTin[i6];
                    for (int i8 = 2; i8 <= 4; ++i8)
                    {
                        DistPnt(xSel, ySel, numArray2[i8 - 1], numArray3[i8 - 1], numArray2[i8], numArray3[i8], out dist, out ip1, out num3, out num2);
                        if (ip1 > 0 && num16 > dist)
                        {
                            num16 = dist;
                            num15 = i6;
                            ip2 = i8;
                        }
                    }
                }
            }
            int i9 = num13;
            numArray1[1] = nTin[i9];
            numArray2[1] = xTin[i9];
            numArray3[1] = yTin[i9];
            numArray4[1] = zTin[i9];
            numArray1[2] = nTin[i9 + 1];
            numArray2[2] = xTin[i9 + 1];
            numArray3[2] = yTin[i9 + 1];
            numArray4[2] = zTin[i9 + 1];
            numArray1[3] = nTin[i9 + 2];
            numArray2[3] = xTin[i9 + 2];
            numArray3[3] = yTin[i9 + 2];
            numArray4[3] = zTin[i9 + 2];
            numArray1[4] = nTin[i9];
            numArray2[4] = xTin[i9];
            numArray3[4] = yTin[i9];
            numArray4[4] = zTin[i9];
            int i10 = num15;
            numArray5[1] = nTin[i10];
            numArray6[1] = xTin[i10];
            numArray7[1] = yTin[i10];
            numArray8[1] = zTin[i10];
            numArray5[2] = nTin[i10 + 1];
            numArray6[2] = xTin[i10 + 1];
            numArray7[2] = yTin[i10 + 1];
            numArray8[2] = zTin[i10 + 1];
            numArray5[3] = nTin[i10 + 2];
            numArray6[3] = xTin[i10 + 2];
            numArray7[3] = yTin[i10 + 2];
            numArray8[3] = zTin[i10 + 2];
            numArray5[4] = nTin[i10];
            numArray6[4] = xTin[i10];
            numArray7[4] = yTin[i10];
            numArray8[4] = zTin[i10];
            if (i2 == 2)
                ip1 = 3;
            if (i2 == 3)
                ip1 = 1;
            if (i2 == 4)
                ip1 = 2;
            if (ip2 == 2)
                i1 = 3;
            if (ip2 == 3)
                i1 = 1;
            if (ip2 == 4)
                i1 = 2;
            int num17 = numArray1[i2 - 1];
            double x1 = numArray2[i2 - 1];
            double y1 = numArray3[i2 - 1];
            double num18 = numArray4[i2 - 1];
            int num19 = numArray1[i2];
            double x2 = numArray2[i2];
            double y2 = numArray3[i2];
            double num20 = numArray4[i2];
            int num21 = numArray1[ip1];
            double x3 = numArray2[ip1];
            double y3 = numArray3[ip1];
            double num22 = numArray4[ip1];
            int num23 = numArray5[i1];
            double x4 = numArray6[i1];
            double y4 = numArray7[i1];
            double num24 = numArray8[i1];
            int ip3 = 1;
            TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out num3, out num2, ref ip3);
            if (num3 == 0.0 && num2 == 0.0)
                return;
            numArray5[1] = num17;
            numArray6[1] = x1;
            numArray7[1] = y1;
            numArray8[1] = num18;
            numArray5[2] = num21;
            numArray6[2] = x3;
            numArray7[2] = y3;
            numArray8[2] = num22;
            numArray5[3] = num23;
            numArray6[3] = x4;
            numArray7[3] = y4;
            numArray8[3] = num24;
            numArray5[4] = num17;
            numArray6[4] = x1;
            numArray7[4] = y1;
            numArray8[4] = num18;
            numArray5[5] = num19;
            numArray6[5] = x2;
            numArray7[5] = y2;
            numArray8[5] = num20;
            numArray5[6] = num21;
            numArray6[6] = x3;
            numArray7[6] = y3;
            numArray8[6] = num22;
            numArray5[7] = num23;
            numArray6[7] = x4;
            numArray7[7] = y4;
            numArray8[7] = num24;
            numArray5[8] = num19;
            numArray6[8] = x2;
            numArray7[8] = y2;
            numArray8[8] = num20;
            int i11 = -3;
            int i12 = 0;
            for (int i13 = 1; i13 <= num12; ++i13)
            {
                i11 += 4;
                if (i11 != num13 && i11 != num15)
                {
                    numArray1[1] = nTin[i11];
                    numArray2[1] = xTin[i11];
                    numArray3[1] = yTin[i11];
                    numArray4[1] = zTin[i11];
                    numArray1[2] = nTin[i11 + 1];
                    numArray2[2] = xTin[i11 + 1];
                    numArray3[2] = yTin[i11 + 1];
                    numArray4[2] = zTin[i11 + 1];
                    numArray1[3] = nTin[i11 + 2];
                    numArray2[3] = xTin[i11 + 2];
                    numArray3[3] = yTin[i11 + 2];
                    numArray4[3] = zTin[i11 + 2];
                    numArray1[4] = nTin[i11];
                    numArray2[4] = xTin[i11];
                    numArray3[4] = yTin[i11];
                    numArray4[4] = zTin[i11];
                    for (int i14 = 1; i14 <= 4; ++i14)
                    {
                        ++i12;
                        nTin[i12] = numArray1[i14];
                        xTin[i12] = numArray2[i14];
                        yTin[i12] = numArray3[i14];
                        zTin[i12] = numArray4[i14];
                    }
                }
            }
            for (int i15 = 1; i15 <= 8; ++i15)
            {
                ++i12;
                nTin[i12] = numArray5[i15];
                xTin[i12] = numArray6[i15];
                yTin[i12] = numArray7[i15];
                zTin[i12] = numArray8[i15];
            }
            kTin = i12;
        }

        public static void ContSquare(
          double sRel,
          int ktr,
          double[] xtr,
          double[] ytr,
          double[] ztr,
          int[] nd,
          double[] xd,
          double[] yd,
          double[] xr,
          double[] yr,
          double[] xdp,
          double[] ydp,
          double[] zdp,
          double[] xcs,
          double[] ycs,
          double[] zcs,
          out int kzap,
          double[] zcon,
          int[] k1,
          int[] k2,
          int[] kt,
          double[] xg,
          double[] yg,
          StatusBarPanel panel1)
        {
            double[] x1 = new double[10];
            double[] y1 = new double[10];
            double[] z = new double[10];
            kzap = 0;
            if (sRel < 0.1)
                return;
            Cursor.Current = Cursors.WaitCursor;
            double num1 = 3.1415926;
            int i1 = 0;
            double zt1;
            double zt2 = zt1 = 0.0;
            double num2;
            double yt1 = num2 = 0.0;
            double xt1 = num2;
            double yt2 = num2;
            double xt2 = num2;
            double yt3 = num2;
            double xt3 = num2;
            int kArray = 999999;
            doubleArray(xtr, ref kArray);
            doubleArray(ytr, ref kArray);
            doubleArray(ztr, ref kArray);
            intArray(nd, ref kArray);
            kArray -= 4;
            if (ktr > kArray)
            {
                int num3 = (int)MessageBox.Show("Индекс массива 1-ContSquareMax");
            }
            else
            {
                kArray = 999999;
                doubleArray(xg, ref kArray);
                doubleArray(yg, ref kArray);
                kArray -= 4;
                double num4 = 9999999.9;
                double num5 = -9999999.9;
                for (int i2 = 1; i2 <= ktr; ++i2)
                {
                    if (ztr[i2] < num4)
                        num4 = ztr[i2];
                    if (ztr[i2] > num5)
                        num5 = ztr[i2];
                }
                double num6 = -500.0;
                int i3 = 0;
                for (long i4 = 1; i4 <= 100000L; ++i4)
                {
                    num6 += sRel;
                    if (num6 < num5)
                    {
                        if (num6 > num4)
                        {
                            ++i3;
                            zcs[i3] = num6;
                        }
                    }
                    else
                        break;
                }
                if (i3 == 0)
                    return;
                panel1.Text = "Wait...Contours Forming";
                int i5 = 0;
                kzap = 0;
                for (int i6 = 1; i6 <= i3; ++i6)
                {
                    int i7 = 0;
                    int i8 = -3;
                    int num7 = ktr / 4;
                    int i9 = -1;
                    for (int i10 = 1; i10 <= num7; ++i10)
                    {
                        i8 += 4;
                        x1[1] = xtr[i8];
                        y1[1] = ytr[i8];
                        z[1] = ztr[i8];
                        x1[2] = xtr[i8 + 1];
                        y1[2] = ytr[i8 + 1];
                        z[2] = ztr[i8 + 1];
                        x1[3] = xtr[i8 + 2];
                        y1[3] = ytr[i8 + 2];
                        z[3] = ztr[i8 + 2];
                        x1[4] = xtr[i8 + 3];
                        y1[4] = ytr[i8 + 3];
                        z[4] = ztr[i8 + 3];
                        int num8 = 4;
                        for (int i11 = 1; i11 <= num8; ++i11)
                        {
                            double num9 = z[i11] - zcs[i6];
                            if (Math.Abs(num9) < 0.05 * sRel)
                            {
                                if (num9 >= 0.0)
                                    z[i11] = z[i11] + 0.05 * sRel;
                                if (num9 < 0.0)
                                    z[i11] = z[i11] - 0.05 * sRel;
                            }
                        }
                        int num10 = 0;
                        for (int i12 = 2; i12 <= num8; ++i12)
                        {
                            if (z[i12 - 1] != z[i12])
                            {
                                if (z[i12 - 1] > z[i12])
                                {
                                    xt3 = x1[i12];
                                    yt3 = y1[i12];
                                    zt2 = z[i12];
                                    xt2 = x1[i12 - 1];
                                    yt2 = y1[i12 - 1];
                                    zt1 = z[i12 - 1];
                                }
                                if (z[i12 - 1] < z[i12])
                                {
                                    xt3 = x1[i12 - 1];
                                    yt3 = y1[i12 - 1];
                                    zt2 = z[i12 - 1];
                                    xt2 = x1[i12];
                                    yt2 = y1[i12];
                                    zt1 = z[i12];
                                }
                                if (zcs[i6] > zt2 && zcs[i6] < zt1)
                                {
                                    ++num10;
                                    double x2 = xt2 - xt3;
                                    double y2 = yt2 - yt3;
                                    double num11 = Math.Sqrt(x2 * x2 + y2 * y2);
                                    double num12 = Math.Atan2(y2, x2);
                                    if (num12 < 0.0)
                                        num12 += 2.0 * num1;
                                    double num13 = zcs[i6] - zt2;
                                    ++i7;
                                    nd[i7] = i10;
                                    xd[i7] = xt3 + num11 * Math.Cos(num12) * num13 / (zt1 - zt2);
                                    yd[i7] = yt3 + num11 * Math.Sin(num12) * num13 / (zt1 - zt2);
                                    if (num10 == 2)
                                    {
                                        int i13 = i9 + 1;
                                        xdp[i13] = x1[1];
                                        ydp[i13] = y1[1];
                                        zdp[i13] = z[1];
                                        int i14 = i13 + 1;
                                        xdp[i14] = x1[2];
                                        ydp[i14] = y1[2];
                                        zdp[i14] = z[2];
                                        int i15 = i14 + 1;
                                        xdp[i15] = x1[3];
                                        ydp[i15] = y1[3];
                                        zdp[i15] = z[3];
                                        i9 = i15 + 1;
                                        xdp[i9] = x1[4];
                                        ydp[i9] = y1[4];
                                        zdp[i9] = z[4];
                                    }
                                }
                            }
                        }
                    }
                    if (i7 >= 3)
                    {
                        int num14 = i7;
                        for (int i16 = 1; i16 <= num14 && i7 >= 3; ++i16)
                        {
                            int num15 = i7;
                            int i17 = 0;
                            for (int i18 = 2; i18 <= num15; i18 += 2)
                            {
                                int num16 = 0;
                                xt3 = xd[i18 - 1];
                                yt3 = yd[i18 - 1];
                                xt2 = xd[i18];
                                yt2 = yd[i18];
                                for (int i19 = 2; i19 <= i7; i19 += 2)
                                {
                                    if (i18 != i19)
                                    {
                                        double num17 = xt3 - xd[i19 - 1];
                                        double num18 = yt3 - yd[i19 - 1];
                                        if (Math.Sqrt(num17 * num17 + num18 * num18) < 0.001)
                                        {
                                            ++num16;
                                            break;
                                        }
                                        double num19 = xt3 - xd[i19];
                                        double num20 = yt3 - yd[i19];
                                        if (Math.Sqrt(num19 * num19 + num20 * num20) < 0.001)
                                        {
                                            ++num16;
                                            break;
                                        }
                                    }
                                }
                                if (num16 == 0)
                                {
                                    i17 = 2;
                                    nd[i18 - 1] = 0;
                                    nd[i18] = 0;
                                    xr[1] = xt3;
                                    yr[1] = yt3;
                                    xr[2] = xt2;
                                    yr[2] = yt2;
                                    break;
                                }
                                int num21 = 0;
                                for (int i20 = 2; i20 <= i7; i20 += 2)
                                {
                                    if (i18 != i20)
                                    {
                                        double num22 = xt2 - xd[i20 - 1];
                                        double num23 = yt2 - yd[i20 - 1];
                                        if (Math.Sqrt(num22 * num22 + num23 * num23) < 0.001)
                                        {
                                            ++num21;
                                            break;
                                        }
                                        double num24 = xt2 - xd[i20];
                                        double num25 = yt2 - yd[i20];
                                        if (Math.Sqrt(num24 * num24 + num25 * num25) < 0.001)
                                        {
                                            ++num21;
                                            break;
                                        }
                                    }
                                }
                                if (num21 == 0)
                                {
                                    i17 = 2;
                                    nd[i18 - 1] = 0;
                                    nd[i18] = 0;
                                    xr[1] = xt2;
                                    yr[1] = yt2;
                                    xr[2] = xt3;
                                    yr[2] = yt3;
                                    break;
                                }
                            }
                            if (i17 == 0)
                            {
                                i17 = 2;
                                nd[1] = 0;
                                nd[2] = 0;
                                xr[1] = xd[1];
                                yr[1] = yd[1];
                                xr[2] = xd[2];
                                yr[2] = yd[2];
                            }
                            int num26 = i7;
                            for (int i21 = 1; i21 <= num26; ++i21)
                            {
                                int num27 = 0;
                                for (int i22 = 2; i22 <= i7; i22 += 2)
                                {
                                    if (nd[i22 - 1] != 0 || nd[i22] != 0)
                                    {
                                        double num28 = xr[i17] - xd[i22 - 1];
                                        double num29 = yr[i17] - yd[i22 - 1];
                                        if (Math.Sqrt(num28 * num28 + num29 * num29) < 0.001)
                                        {
                                            ++num27;
                                            nd[i22 - 1] = 0;
                                            nd[i22] = 0;
                                            ++i17;
                                            xr[i17] = xd[i22];
                                            yr[i17] = yd[i22];
                                        }
                                        else
                                        {
                                            double num30 = xr[i17] - xd[i22];
                                            double num31 = yr[i17] - yd[i22];
                                            if (Math.Sqrt(num30 * num30 + num31 * num31) < 0.001)
                                            {
                                                ++num27;
                                                nd[i22 - 1] = 0;
                                                nd[i22] = 0;
                                                ++i17;
                                                xr[i17] = xd[i22 - 1];
                                                yr[i17] = yd[i22 - 1];
                                            }
                                        }
                                    }
                                }
                                if (num27 == 0 && i17 > 1)
                                {
                                    int num32 = i9 / 4;
                                    int i23 = -4;
                                    double num33 = 0.0;
                                    for (int i24 = 1; i24 <= num32; ++i24)
                                    {
                                        i23 += 4;
                                        x1[0] = xdp[i23];
                                        y1[0] = ydp[i23];
                                        z[0] = zdp[i23];
                                        x1[1] = xdp[i23 + 1];
                                        y1[1] = ydp[i23 + 1];
                                        z[1] = zdp[i23 + 1];
                                        x1[2] = xdp[i23 + 2];
                                        y1[2] = ydp[i23 + 2];
                                        z[2] = zdp[i23 + 2];
                                        x1[3] = xdp[i23 + 3];
                                        y1[3] = ydp[i23 + 3];
                                        z[3] = zdp[i23 + 3];
                                        int k = 3;
                                        int i25 = 0;
                                        for (int i26 = 2; i26 <= i17; ++i26)
                                        {
                                            xt1 = 0.5 * (xr[i26] + xr[i26 - 1]);
                                            yt1 = 0.5 * (yr[i26] + yr[i26 - 1]);
                                            i25 = in_out(k, ref x1, ref y1, xt1, yt1);
                                            if (i25 > 0)
                                            {
                                                i25 = i26;
                                                break;
                                            }
                                        }
                                        if (i25 > 0)
                                        {
                                            double x3 = xr[i25] - xr[i25 - 1];
                                            double num34 = Math.Atan2(yr[i25] - yr[i25 - 1], x3);
                                            if (num34 < 0.0)
                                                num34 += 2.0 * num1;
                                            double num35 = num34 + 0.5 * num1;
                                            if (num35 >= 2.0 * num1)
                                                num35 -= 2.0 * num1;
                                            xt3 = xt1 + 0.2 * Math.Cos(num35);
                                            yt3 = yt1 + 2.0 * Math.Sin(num35);
                                            xt2 = xt1 - 0.2 * Math.Cos(num35);
                                            yt2 = yt1 - 2.0 * Math.Sin(num35);
                                            Treyg(x1, y1, z, xt3, yt3, out zt2);
                                            Treyg(x1, y1, z, xt2, yt2, out zt1);
                                            if (zt2 != 0.0 && zt1 != 0.0)
                                            {
                                                num33 = zt2 - zt1;
                                                break;
                                            }
                                        }
                                    }
                                    if (num33 >= 0.0)
                                    {
                                        i1 = 0;
                                        for (int i27 = 1; i27 <= i17; ++i27)
                                        {
                                            ++i1;
                                            xcs[i1] = xr[i27];
                                            ycs[i1] = yr[i27];
                                        }
                                    }
                                    if (num33 < 0.0)
                                    {
                                        i1 = 0;
                                        int i28 = i17 + 1;
                                        for (int i29 = 1; i29 <= i17; ++i29)
                                        {
                                            --i28;
                                            ++i1;
                                            xcs[i1] = xr[i28];
                                            ycs[i1] = yr[i28];
                                        }
                                    }
                                    int i30 = 0;
                                    xcs[0] = xcs[1];
                                    ycs[0] = ycs[1];
                                    for (int i31 = 2; i31 <= i1; ++i31)
                                    {
                                        double num36 = xcs[i31] - xcs[i30];
                                        double num37 = ycs[i31] - ycs[i30];
                                        if (Math.Sqrt(num36 * num36 + num37 * num37) < 0.005)
                                        {
                                            if (i31 == i1)
                                            {
                                                ++i30;
                                                xcs[i30] = xcs[i31];
                                                ycs[i30] = ycs[i31];
                                            }
                                        }
                                        else
                                        {
                                            ++i30;
                                            xcs[i30] = xcs[i31];
                                            ycs[i30] = ycs[i31];
                                        }
                                    }
                                    i1 = i30;
                                    int num38 = 0;
                                    for (int i32 = 0; i32 <= i1; ++i32)
                                    {
                                        ++num38;
                                        ++i5;
                                        if (i5 > kArray)
                                        {
                                            int num39 = (int)MessageBox.Show("Индекс массива 2-ContSquareMax");
                                            kzap = 0;
                                            return;
                                        }
                                        xg[i5] = xcs[i32];
                                        yg[i5] = ycs[i32];
                                    }
                                    ++kzap;
                                    kt[kzap] = num38;
                                    zcon[kzap] = zcs[i6];
                                    panel1.Text = "Подождите..Контуры = " + string.Format("{0}", (object)kzap);
                                    int i33 = 0;
                                    for (int i34 = 2; i34 <= i7; i34 += 2)
                                    {
                                        if (nd[i34 - 1] != 0 || nd[i34] != 0)
                                        {
                                            int i35 = i33 + 1;
                                            nd[i35] = nd[i34 - 1];
                                            xd[i35] = xd[i34 - 1];
                                            yd[i35] = yd[i34 - 1];
                                            i33 = i35 + 1;
                                            nd[i33] = nd[i34];
                                            xd[i33] = xd[i34];
                                            yd[i33] = yd[i34];
                                        }
                                    }
                                    i7 = i33;
                                    break;
                                }
                            }
                        }
                    }
                }
                k1[1] = 1;
                k2[1] = kt[1];
                if (kzap <= 1)
                    return;
                for (int i36 = 2; i36 <= kzap; ++i36)
                {
                    k1[i36] = k2[i36 - 1] + 1;
                    k2[i36] = k2[i36 - 1] + kt[i36];
                }
            }
        }

        public static void DrawTre(
          PaintEventArgs e,
          int ktin,
          double[] xtin,
          double[] ytin,
          int kCent,
          double[] xCent,
          double[] yCent,
          double scaleWin,
          double xBeg,
          double yBeg,
          int xWin,
          int yWin)
        {
            Graphics graphics = e.Graphics;
            double[] numArray1 = new double[5];
            double[] numArray2 = new double[5];
            Cursor.Current = Cursors.WaitCursor;
            int kArray1 = 999999;
            doubleArray(xtin, ref kArray1);
            doubleArray(ytin, ref kArray1);
            if (ktin > kArray1)
            {
                int num1 = (int)MessageBox.Show("Индекс массива DrawTre");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(xCent, ref kArray2);
                doubleArray(yCent, ref kArray2);
                if (kCent > kArray2)
                {
                    int num2 = (int)MessageBox.Show("Индекс массива DrawTre");
                }
                else
                {
                    SolidBrush solidBrush = new SolidBrush(Color.Gray);
                    Pen pen = new Pen(Color.Gray);
                    int num3 = ktin / 4;
                    int i1 = -3;
                    int xWin1;
                    int yWin1;
                    for (int i2 = 1; i2 <= num3; ++i2)
                    {
                        i1 += 4;
                        numArray1[1] = xtin[i1];
                        numArray2[1] = ytin[i1];
                        numArray1[2] = xtin[i1 + 1];
                        numArray2[2] = ytin[i1 + 1];
                        numArray1[3] = xtin[i1 + 2];
                        numArray2[3] = ytin[i1 + 2];
                        numArray1[4] = xtin[i1 + 3];
                        numArray2[4] = ytin[i1 + 3];
                        int num4 = 4;
                        for (int i3 = 2; i3 <= num4; ++i3)
                        {
                            XYtoWIN(numArray1[i3 - 1], numArray2[i3 - 1], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                            if (xWin1 != 0 || yWin1 != 0)
                            {
                                int xWin2;
                                int yWin2;
                                XYtoWIN(numArray1[i3], numArray2[i3], scaleWin, xBeg, yBeg, xWin, yWin, out xWin2, out yWin2);
                                if (xWin2 != 0 || yWin2 != 0)
                                    graphics.DrawLine(pen, xWin1, yWin1, xWin2, yWin2);
                            }
                        }
                    }
                    if (kCent <= 0)
                        return;
                    for (int i4 = 1; i4 <= kCent; ++i4)
                    {
                        XYtoWIN(xCent[i4], yCent[i4], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                        if (xWin1 != 0 || yWin1 != 0)
                            graphics.FillRectangle((Brush)solidBrush, xWin1 - 1, yWin1 - 1, 3, 3);
                    }
                }
            }
        }

        public static void CenterTre(
          int ktin,
          double[] xtin,
          double[] ytin,
          out int kCenter,
          double[] xCenter,
          double[] yCenter)
        {
            double[] numArray1 = new double[5];
            double[] numArray2 = new double[5];
            kCenter = 0;
            int kArray1 = 999999;
            doubleArray(xtin, ref kArray1);
            doubleArray(ytin, ref kArray1);
            if (ktin > kArray1)
            {
                int num1 = (int)MessageBox.Show("Индекс массива CenterTre");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(xCenter, ref kArray2);
                doubleArray(yCenter, ref kArray2);
                int num2 = kArray2 - 2;
                int num3 = ktin / 4;
                int i1 = -3;
                for (int i2 = 1; i2 <= num3; ++i2)
                {
                    i1 += 4;
                    numArray1[1] = xtin[i1];
                    numArray2[1] = ytin[i1];
                    numArray1[2] = xtin[i1 + 1];
                    numArray2[2] = ytin[i1 + 1];
                    numArray1[3] = xtin[i1 + 2];
                    numArray2[3] = ytin[i1 + 2];
                    if (kCenter > num2)
                    {
                        int num4 = (int)MessageBox.Show("Индекс массива CenterTre");
                        break;
                    }
                    ++kCenter;
                    xCenter[kCenter] = (numArray1[1] + numArray1[2] + numArray1[3]) / 3.0;
                    yCenter[kCenter] = (numArray2[1] + numArray2[2] + numArray2[3]) / 3.0;
                }
            }
        }

        public static void LineСлияние(
          double tol,
          int kLin,
          ref int[] k1,
          ref int[] k2,
          ref double[] x,
          ref double[] y,
          out int kp,
          ref double[] xp,
          ref double[] yp,
          ref int[] nd)
        {
            int num1;
            int num2 = num1 = 0;
            double num3;
            double num4 = num3 = 0.0;
            kp = 0;
            int kArray = 999999;
            doubleArray(xp, ref kArray);
            doubleArray(yp, ref kArray);
            int num5 = kArray - 3;
            int num6 = k1[1];
            int num7 = k2[1];
            for (int i = num6; i <= num7; ++i)
            {
                ++kp;
                xp[kp] = x[i];
                yp[kp] = y[i];
                if (kp > num5)
                {
                    int num8 = (int)MessageBox.Show("Индекс массива LineСлияние");
                    return;
                }
            }
            int i1 = 1;
            nd[i1] = 1;
            for (int i2 = 1; i2 <= kLin; ++i2)
            {
                int num9 = 0;
                for (int i3 = 2; i3 <= kLin; ++i3)
                {
                    int num10 = 0;
                    for (int i4 = 1; i4 <= i1; ++i4)
                    {
                        if (nd[i4] == i3)
                        {
                            ++num10;
                            break;
                        }
                    }
                    if (num10 <= 0)
                    {
                        int i5 = k1[i3];
                        int i6 = k2[i3];
                        double num11 = xp[kp] - x[i5];
                        double num12 = yp[kp] - y[i5];
                        if (Math.Sqrt(num11 * num11 + num12 * num12) < tol)
                        {
                            ++i1;
                            nd[i1] = i3;
                            for (int i7 = i5 + 1; i7 <= i6; ++i7)
                            {
                                ++kp;
                                xp[kp] = x[i7];
                                yp[kp] = y[i7];
                                if (kp > num5)
                                {
                                    int num13 = (int)MessageBox.Show("Индекс массива LineСлияние");
                                    return;
                                }
                            }
                            double num14 = xp[kp] - xp[1];
                            double num15 = yp[kp] - yp[1];
                            if (Math.Sqrt(num14 * num14 + num15 * num15) < tol)
                            {
                                ++num9;
                                break;
                            }
                        }
                        else
                        {
                            double num16 = xp[kp] - x[i6];
                            double num17 = yp[kp] - y[i6];
                            if (Math.Sqrt(num16 * num16 + num17 * num17) < tol)
                            {
                                ++i1;
                                nd[i1] = i3;
                                int i8 = i6;
                                for (int i9 = i5; i9 < i6; ++i9)
                                {
                                    --i8;
                                    ++kp;
                                    xp[kp] = x[i8];
                                    yp[kp] = y[i8];
                                    if (kp > num5)
                                    {
                                        int num18 = (int)MessageBox.Show("Индекс массива LineСлияние");
                                        return;
                                    }
                                }
                                double num19 = xp[kp] - xp[1];
                                double num20 = yp[kp] - yp[1];
                                if (Math.Sqrt(num19 * num19 + num20 * num20) < tol)
                                {
                                    ++num9;
                                    break;
                                }
                            }
                        }
                    }
                }
                if (num9 > 0)
                    break;
            }
        }

        public static void FirstPerpendicular(
          int iParam,
          double arDat,
          double arParc,
          int kPar,
          ref double[] xPar,
          ref double[] yPar,
          ref int kSel,
          ref double[] xSel,
          ref double[] ySel,
          double selRad,
          double xSelRad,
          double ySelRad,
          out double xMove,
          out double yMove,
          out double xPoint,
          out double yPoint,
          out double azHor,
          out double azVer,
          ref double[] xr,
          ref double[] yr,
          ref double[] dr)
        {
            xMove = 0.0;
            yMove = 0.0;
            xPoint = 0.0;
            yPoint = 0.0;
            azHor = 0.0;
            azVer = 0.0;
            double num1 = 3.1415926;
            Cursor.Current = Cursors.WaitCursor;
            int kArray = 999999;
            doubleArray(xPar, ref kArray);
            doubleArray(yPar, ref kArray);
            doubleArray(xSel, ref kArray);
            doubleArray(ySel, ref kArray);
            doubleArray(xr, ref kArray);
            doubleArray(yr, ref kArray);
            doubleArray(dr, ref kArray);
            if (kPar > kArray)
            {
                int num2 = (int)MessageBox.Show("Индекс массива FirstPerpendicular");
            }
            else
            {
                int num3 = 0;
                double num4;
                double num5 = num4 = 0.0;
                double dist = num4;
                double ym = num4;
                double xm = num4;
                double num6;
                double num7 = num6 = 0.0;
                double num8 = num6;
                double num9 = num6;
                double num10;
                double num11 = num10 = 0.0;
                int num12;
                int num13 = num12 = 0;
                int num14 = num12;
                int ip1 = num12;
                double num15;
                double num16 = num15 = 0.0;
                double num17;
                double num18 = num17 = 0.0;
                double num19;
                double num20 = num19 = 0.0;
                double num21 = 9999999.9;
                double num22 = 9999999.9;
                double num23 = -9999999.9;
                double num24 = -9999999.9;
                for (int i = 0; i <= kPar; ++i)
                {
                    if (xPar[i] < num21)
                        num21 = xPar[i];
                    if (xPar[i] > num23)
                        num23 = xPar[i];
                    if (yPar[i] < num22)
                        num22 = yPar[i];
                    if (yPar[i] > num24)
                        num24 = yPar[i];
                }
                double num25 = num23 - num21;
                double num26 = num24 - num22;
                double num27 = Math.Sqrt(num25 * num25 + num26 * num26);
                if (selRad <= 0.0)
                {
                    xm = 0.5 * (xSel[0] + xSel[kSel]);
                    ym = 0.5 * (ySel[0] + ySel[kSel]);
                    double x1 = xSel[kSel] - xSel[0];
                    double num28 = Math.Atan2(ySel[kSel] - ySel[0], x1);
                    if (num28 < 0.0)
                        num28 += 2.0 * num1;
                    double num29 = num28 + 0.5 * num1;
                    if (num29 >= 2.0 * num1)
                        num29 -= 2.0 * num1;
                    double num30 = xm - 0.02 * Math.Cos(num29);
                    double num31 = ym - 0.02 * Math.Sin(num29);
                    if (in_out(kPar, ref xPar, ref yPar, num30, num31) == 0)
                    {
                        num29 -= num1;
                        if (num29 < 0.0)
                            num29 += 2.0 * num1;
                        num30 = xm - 0.02 * Math.Cos(num29);
                        num31 = ym - 0.02 * Math.Sin(num29);
                        num14 = in_out(kPar, ref xPar, ref yPar, num30, num31);
                    }
                    double x1_1 = xm - num27 * Math.Cos(num29);
                    double y1_1 = ym - num27 * Math.Sin(num29);
                    double x2 = xm + num27 * Math.Cos(num29);
                    double y2 = ym + num27 * Math.Sin(num29);
                    int i1 = 0;
                    for (int i2 = 1; i2 <= kPar; ++i2)
                    {
                        int ip2 = 1;
                        TwoLine(x1_1, y1_1, xPar[i2 - 1], yPar[i2 - 1], x2, y2, xPar[i2], yPar[i2], out num9, out num8, ref ip2);
                        if (num9 != 0.0 || num8 != 0.0)
                        {
                            ++i1;
                            xr[i1] = num9;
                            yr[i1] = num8;
                            double num32 = num9 - x1_1;
                            double num33 = num8 - y1_1;
                            dr[i1] = Math.Sqrt(num32 * num32 + num33 * num33);
                        }
                    }
                    if (i1 < 2)
                        return;
                    if (i1 > 1)
                    {
                        for (int i3 = 1; i3 < i1; ++i3)
                        {
                            for (int i4 = i3 + 1; i4 <= i1; ++i4)
                            {
                                if (dr[i3] > dr[i4])
                                {
                                    num9 = xr[i3];
                                    num8 = yr[i3];
                                    double num34 = dr[i3];
                                    xr[i3] = xr[i4];
                                    yr[i3] = yr[i4];
                                    dr[i3] = dr[i4];
                                    xr[i4] = num9;
                                    yr[i4] = num8;
                                    dr[i4] = num34;
                                }
                            }
                        }
                        int num35 = i1 / 2;
                        if (i1 - 2 * num35 > 0)
                        {
                            num9 = xr[i1];
                            num8 = yr[i1];
                            i1 = 2;
                            xr[i1] = num9;
                            yr[i1] = num8;
                        }
                        int i5 = 0;
                        for (int i6 = 2; i6 <= i1; ++i6)
                        {
                            DistPnt(num30, num31, xr[i6 - 1], yr[i6 - 1], xr[i6], yr[i6], out dist, out ip1, out num9, out num8);
                            if (ip1 > 0)
                            {
                                i5 = i6;
                                break;
                            }
                        }
                        if (i5 == 0)
                            return;
                        xMove = 0.5 * (xr[i5 - 1] + xr[i5]);
                        yMove = 0.5 * (yr[i5 - 1] + yr[i5]);
                        double x3 = xMove - xm;
                        num29 = Math.Atan2(yMove - ym, x3);
                        if (num29 < 0.0)
                            num29 += 2.0 * num1;
                        double num36 = num29 + 0.5 * num1;
                        if (num36 >= 2.0 * num1)
                            num36 -= 2.0 * num1;
                        double x1_2 = xMove + num27 * Math.Cos(num36);
                        double y1_2 = yMove + num27 * Math.Sin(num36);
                        num3 = 0;
                        double num37 = 9999999.9;
                        for (int i7 = 1; i7 <= kPar; ++i7)
                        {
                            int ip3 = 1;
                            TwoLine(x1_2, y1_2, xPar[i7 - 1], yPar[i7 - 1], xMove, yMove, xPar[i7], yPar[i7], out num9, out num8, ref ip3);
                            if (num9 != 0.0 || num8 != 0.0)
                            {
                                double num38 = xMove - num9;
                                double num39 = yMove - num8;
                                double num40 = Math.Sqrt(num38 * num38 + num39 * num39);
                                if (num40 < num37)
                                {
                                    num37 = num40;
                                    int i8 = 1;
                                    xr[i8] = num9;
                                    yr[i8] = num8;
                                }
                            }
                        }
                        double x4 = xMove - xr[1];
                        num28 = Math.Atan2(yMove - yr[1], x4);
                        if (num28 < 0.0)
                            num28 += 2.0 * num1;
                        xPoint = xr[1] + 0.1 * Math.Cos(num28);
                        yPoint = yr[1] + 0.1 * Math.Sin(num28);
                        num14 = in_out(kPar, ref xPar, ref yPar, xPoint, yPoint);
                    }
                    azHor = num28;
                    azVer = num29;
                }
                if (selRad <= 0.0)
                    return;
                double num41 = 0.5 * (xSel[0] + xSel[kSel]);
                num8 = 0.5 * (ySel[0] + ySel[kSel]);
                double x5 = xSel[kSel] - xSel[0];
                double num42 = Math.Atan2(ySel[kSel] - ySel[0], x5);
                if (num42 < 0.0)
                    num42 += 2.0 * num1;
                double num43 = num42 + 0.5 * num1;
                if (num43 >= 2.0 * num1)
                    num43 -= 2.0 * num1;
                double x1_3 = num41 - num27 * Math.Cos(num43);
                double y1 = num8 - num27 * Math.Sin(num43);
                double x2_1 = num41 + num27 * Math.Cos(num43);
                double y2_1 = num8 + num27 * Math.Sin(num43);
                int num44 = 0;
                for (int i = 1; i <= kSel; ++i)
                {
                    int ip4 = 1;
                    TwoLine(x1_3, y1, xSel[i - 1], ySel[i - 1], x2_1, y2_1, xSel[i], ySel[i], out xm, out ym, ref ip4);
                    if (xm != 0.0 || ym != 0.0)
                    {
                        num3 = num44 + 1;
                        break;
                    }
                }
                xMove = xm - 0.01 * Math.Cos(num43);
                yMove = ym - 0.01 * Math.Sin(num43);
                if (in_out(kPar, ref xPar, ref yPar, xMove, yMove) == 0)
                {
                    double num45 = num43 - num1;
                    if (num45 < 0.0)
                        num45 += 2.0 * num1;
                    xMove = xm - 0.01 * Math.Cos(num45);
                    yMove = ym - 0.01 * Math.Sin(num45);
                    num14 = in_out(kPar, ref xPar, ref yPar, xMove, yMove);
                }
                double x6 = num41 - xm;
                double y = num8 - ym;
                double num46 = Math.Sqrt(x6 * x6 + y * y);
                double num47 = Math.Atan2(y, x6);
                if (num47 < 0.0)
                    num47 += 2.0 * num1;
                double num48 = xm + 0.9 * num46 * Math.Cos(num47);
                num8 = ym + 0.9 * num46 * Math.Sin(num47);
                int num49 = in_out(kPar, ref xPar, ref yPar, num48, num8);
                if (num49 == 0)
                {
                    num42 = num47 - 0.5 * num1;
                    if (num42 < 0.0)
                        num42 += 2.0 * num1;
                    double x2_2 = xMove + num27 * Math.Cos(num42);
                    double y2_2 = yMove + num27 * Math.Sin(num42);
                    num3 = 0;
                    double num50 = 9999999.9;
                    for (int i9 = 1; i9 <= kPar; ++i9)
                    {
                        int ip5 = 1;
                        TwoLine(xMove, yMove, xPar[i9 - 1], yPar[i9 - 1], x2_2, y2_2, xPar[i9], yPar[i9], out xm, out ym, ref ip5);
                        if (xm != 0.0 || ym != 0.0)
                        {
                            double num51 = xm - xMove;
                            double num52 = ym - yMove;
                            double num53 = Math.Sqrt(num51 * num51 + num52 * num52);
                            if (num53 < num50)
                            {
                                num50 = num53;
                                int i10 = 1;
                                xr[i10] = xm;
                                yr[i10] = ym;
                            }
                        }
                    }
                }
                if (num49 > 0)
                {
                    num42 = num47 + 0.5 * num1;
                    if (num42 >= 2.0 * num1)
                        num42 -= 2.0 * num1;
                    double x2_3 = num48 + num27 * Math.Cos(num42);
                    double y2_3 = num8 + num27 * Math.Sin(num42);
                    int i11 = 0;
                    for (int i12 = 1; i12 <= kSel; ++i12)
                    {
                        int ip6 = 1;
                        TwoLine(num48, num8, xSel[i12 - 1], ySel[i12 - 1], x2_3, y2_3, xSel[i12], ySel[i12], out xm, out ym, ref ip6);
                        if (xm != 0.0 || ym != 0.0)
                        {
                            ++i11;
                            xr[i11] = xm;
                            yr[i11] = ym;
                        }
                    }
                }
                xPoint = xr[1] - 0.15 * Math.Cos(num42);
                yPoint = yr[1] - 0.15 * Math.Sin(num42);
                azHor = num42;
                azVer = num47;
            }
        }

        public static void PerpendicularParcel(
          double xMove,
          double yMove,
          double azVer,
          int k,
          ref double[] x,
          ref double[] y,
          int kin,
          ref int[] kn1,
          ref int[] kn2,
          ref double[] xin,
          ref double[] yin,
          double selRad,
          double xSelRad,
          double ySelRad,
          out int kLin,
          ref double[] outRad,
          ref int[] kp1,
          ref int[] kp2,
          ref double[] xp,
          ref double[] yp,
          ref double[] xr,
          ref double[] yr,
          ref double[] sr,
          ref double[] xa,
          ref double[] ya,
          ref int[] nr,
          double tol)
        {
            kLin = 0;
            double num1;
            double num2 = num1 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            int kArray = 999999;
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            doubleArray(xin, ref kArray);
            doubleArray(yin, ref kArray);
            doubleArray(xp, ref kArray);
            doubleArray(yp, ref kArray);
            doubleArray(xr, ref kArray);
            doubleArray(yr, ref kArray);
            doubleArray(sr, ref kArray);
            doubleArray(xa, ref kArray);
            doubleArray(ya, ref kArray);
            doubleArray(outRad, ref kArray);
            intArray(kn1, ref kArray);
            intArray(kn2, ref kArray);
            intArray(kp1, ref kArray);
            intArray(kp2, ref kArray);
            intArray(nr, ref kArray);
            if (k > kArray)
            {
                int num5 = (int)MessageBox.Show("Индекс массива PerpendicularParcel");
            }
            else
            {
                double num6 = 9999999.9;
                double num7 = 9999999.9;
                double num8 = -9999999.9;
                double num9 = -9999999.9;
                for (int i = 0; i <= k; ++i)
                {
                    if (x[i] < num6)
                        num6 = x[i];
                    if (x[i] > num8)
                        num8 = x[i];
                    if (y[i] < num7)
                        num7 = y[i];
                    if (y[i] > num9)
                        num9 = y[i];
                }
                double num10 = num8 - num6;
                double num11 = num9 - num7;
                double num12 = Math.Sqrt(num10 * num10 + num11 * num11);
                ParcelIntersect(xMove - num12 * Math.Cos(azVer), yMove - num12 * Math.Sin(azVer), xMove + num12 * Math.Cos(azVer), yMove + num12 * Math.Sin(azVer), k, ref x, ref y, kin, ref kn1, ref kn2, ref xin, ref yin, out kLin, ref kp1, ref kp2, ref xp, ref yp, ref xr, ref yr, ref sr, ref xa, ref ya, ref nr, tol);
            }
        }

        public static void PerpendicularMove(
          ref double xMove,
          ref double yMove,
          ref double azVer,
          double areaInput,
          double areaSel,
          double arCalc,
          int kPar,
          ref double[] xPar,
          ref double[] yPar,
          ref int kSel,
          ref double[] xSel,
          ref double[] ySel,
          double selRad,
          double xSelRad,
          double ySelRad,
          out int iCond,
          ref double[] xr,
          ref double[] yr,
          ref double[] dr,
          int numVar,
          double[] difArea,
          ref int iPlusMin,
          ref double fCoeff)
        {
            double num1 = 0.0;
            iCond = 0;
            double num2 = 3.1415926;
            double num3;
            double num4 = num3 = 0.0;
            double num5;
            double num6 = num5 = 0.0;
            double num7 = num5;
            double num8 = num5;
            double num9;
            double num10 = num9 = 0.0;
            int num11;
            int num12 = num11 = 0;
            int num13 = num11;
            int ip1 = num11;
            double num14;
            double num15 = num14 = 0.0;
            double num16 = num14;
            double num17 = num14;
            double num18;
            double num19 = num18 = 0.0;
            double num20;
            double num21 = num20 = 0.0;
            int kArray = 999999;
            doubleArray(xPar, ref kArray);
            doubleArray(yPar, ref kArray);
            doubleArray(xSel, ref kArray);
            doubleArray(ySel, ref kArray);
            doubleArray(xr, ref kArray);
            doubleArray(yr, ref kArray);
            doubleArray(dr, ref kArray);
            doubleArray(difArea, ref kArray);
            if (kPar > kArray)
            {
                int num22 = (int)MessageBox.Show("Индекс массива PerpendicularMove");
            }
            else
            {
                double num23 = xSel[kSel] - xSel[0];
                double num24 = ySel[kSel] - ySel[0];
                double dist = Math.Sqrt(num23 * num23 + num24 * num24);
                if (dist < 0.1)
                {
                    iCond = -99;
                }
                else
                {
                    for (int i = 1; i <= kSel; ++i)
                    {
                        double num25 = xSel[i] - xSel[i - 1];
                        double num26 = ySel[i] - ySel[i - 1];
                        dist = Math.Sqrt(num25 * num25 + num26 * num26);
                        num1 += dist;
                    }
                    double num27 = 9999999.9;
                    double num28 = 9999999.9;
                    double num29 = -9999999.9;
                    double num30 = -9999999.9;
                    for (int i = 0; i <= kPar; ++i)
                    {
                        if (xPar[i] < num27)
                            num27 = xPar[i];
                        if (xPar[i] > num29)
                            num29 = xPar[i];
                        if (yPar[i] < num28)
                            num28 = yPar[i];
                        if (yPar[i] > num30)
                            num30 = yPar[i];
                    }
                    double num31 = num29 - num27;
                    double num32 = num30 - num28;
                    double num33 = Math.Sqrt(num31 * num31 + num32 * num32);
                    double num34 = 0.5 * (xSel[0] + xSel[kSel]);
                    double num35 = 0.5 * (ySel[0] + ySel[kSel]);
                    double x1 = xSel[kSel] - xSel[0];
                    double num36 = Math.Atan2(ySel[kSel] - ySel[0], x1);
                    if (num36 < 0.0)
                        num36 += 2.0 * num2;
                    double x2 = xMove - xSelRad;
                    double num37 = Math.Atan2(yMove - ySelRad, x2);
                    if (num37 < 0.0)
                        num37 += 2.0 * num2;
                    double num38 = xMove - 0.3 * Math.Cos(num37);
                    double num39 = yMove - 0.3 * Math.Sin(num37);
                    if (in_out(kPar, ref xPar, ref yPar, num38, num39) == 0)
                    {
                        num37 -= num2;
                        if (num37 < 0.0)
                            num37 += 2.0 * num2;
                        num38 = xMove - 0.3 * Math.Cos(num37);
                        num39 = yMove - 0.3 * Math.Sin(num37);
                        num13 = in_out(kPar, ref xPar, ref yPar, num38, num39);
                    }
                    double x1_1 = xMove - num33 * Math.Cos(num37);
                    double y1 = yMove - num33 * Math.Sin(num37);
                    double x2_1 = xMove + num33 * Math.Cos(num37);
                    double y2 = yMove + num33 * Math.Sin(num37);
                    int i1 = 0;
                    for (int i2 = 1; i2 <= kPar; ++i2)
                    {
                        int ip2 = 1;
                        TwoLine(x1_1, y1, xPar[i2 - 1], yPar[i2 - 1], x2_1, y2, xPar[i2], yPar[i2], out num8, out num7, ref ip2);
                        if (num8 != 0.0 || num7 != 0.0)
                        {
                            ++i1;
                            xr[i1] = num8;
                            yr[i1] = num7;
                            double num40 = num8 - x1_1;
                            double num41 = num7 - y1;
                            dr[i1] = Math.Sqrt(num40 * num40 + num41 * num41);
                        }
                    }
                    if (i1 < 2)
                    {
                        iCond = -99;
                    }
                    else
                    {
                        for (int i3 = 1; i3 < i1; ++i3)
                        {
                            for (int i4 = i3 + 1; i4 <= i1; ++i4)
                            {
                                if (dr[i3] > dr[i4])
                                {
                                    num8 = xr[i3];
                                    num7 = yr[i3];
                                    double num42 = dr[i3];
                                    xr[i3] = xr[i4];
                                    yr[i3] = yr[i4];
                                    dr[i3] = dr[i4];
                                    xr[i4] = num8;
                                    yr[i4] = num7;
                                    dr[i4] = num42;
                                }
                            }
                        }
                        int num43 = i1 / 2;
                        if (i1 - 2 * num43 > 0)
                        {
                            num8 = xr[i1];
                            num7 = yr[i1];
                            i1 = 2;
                            xr[i1] = num8;
                            yr[i1] = num7;
                        }
                        int i5 = 0;
                        for (int i6 = 2; i6 <= i1; ++i6)
                        {
                            DistPnt(num38, num39, xr[i6 - 1], yr[i6 - 1], xr[i6], yr[i6], out dist, out ip1, out num8, out num7);
                            if (ip1 > 0)
                            {
                                i5 = i6;
                                break;
                            }
                        }
                        if (i5 == 0)
                        {
                            iCond = -99;
                        }
                        else
                        {
                            double num44 = xr[i5 - 1];
                            double num45 = yr[i5 - 1];
                            double num46 = xr[i5];
                            double num47 = yr[i5];
                            double num48 = xMove - num44;
                            double num49 = yMove - num45;
                            double num50 = Math.Sqrt(num48 * num48 + num49 * num49);
                            double num51 = xMove - num46;
                            double num52 = yMove - num47;
                            double num53 = Math.Sqrt(num51 * num51 + num52 * num52);
                            if (num50 < num53)
                            {
                                num34 = num44;
                                num35 = num45;
                                num17 = num46;
                                num16 = num47;
                                num46 = num34;
                                num47 = num35;
                            }
                            double num54 = Math.Abs(areaInput - areaSel);
                            double num55 = fCoeff;
                            double num56 = num1 / (double)kSel;
                            int num57 = iPlusMin;
                            if (numVar > 1)
                            {
                                if (difArea[numVar - 1] < 0.0 && difArea[numVar] < 0.0 && Math.Abs(difArea[numVar]) > Math.Abs(difArea[numVar - 1]))
                                {
                                    if (iPlusMin == 1)
                                        num57 = 2;
                                    if (iPlusMin == 2)
                                        num57 = 1;
                                }
                                if (difArea[numVar - 1] > 0.0 && difArea[numVar] > 0.0 && difArea[numVar] > difArea[numVar - 1])
                                {
                                    if (iPlusMin == 1)
                                        num57 = 2;
                                    if (iPlusMin == 2)
                                        num57 = 1;
                                }
                                if (difArea[numVar - 1] > 0.0 && difArea[numVar] < 0.0)
                                {
                                    difArea[numVar] = difArea[numVar - 1] + 0.001;
                                    fCoeff = num54 / areaInput;
                                    if (iPlusMin == 1)
                                        num57 = 2;
                                    if (iPlusMin == 2)
                                        num57 = 1;
                                }
                                if (difArea[numVar - 1] < 0.0 && difArea[numVar] > 0.0)
                                {
                                    difArea[numVar] = difArea[numVar - 1] + 0.001;
                                    fCoeff = num54 / areaInput;
                                    if (iPlusMin == 1)
                                        num57 = 2;
                                    if (iPlusMin == 2)
                                        num57 = 1;
                                }
                            }
                            iPlusMin = num57;
                            if (numVar > 1)
                                num56 = num54 / arCalc * num1;
                            if (num57 == 1)
                            {
                                num34 = num46 - num55 * num56 * Math.Cos(num36);
                                num35 = num47 - num55 * num56 * Math.Sin(num36);
                            }
                            if (num57 == 2)
                            {
                                num34 = num46 + num55 * num56 * Math.Cos(num36);
                                num35 = num47 + num55 * num56 * Math.Sin(num36);
                            }
                            double x3 = num34 - xSelRad;
                            double y = num35 - ySelRad;
                            azVer = Math.Atan2(y, x3);
                            if (azVer < 0.0)
                                azVer += 2.0 * num2;
                            xMove = xSelRad + selRad * Math.Cos(azVer);
                            yMove = ySelRad + selRad * Math.Sin(azVer);
                        }
                    }
                }
            }
        }

        public static void PolyInside(
          int kSel,
          ref double[] xSel,
          ref double[] ySel,
          ref int kPoly,
          ref string[] namePol,
          ref double[] xLab,
          ref double[] yLab,
          ref double[] arCalc,
          ref double[] arLeg,
          ref int[] kPol1,
          ref int[] kPol2,
          ref double[] xPol,
          ref double[] yPol,
          out int kPolInt,
          ref string[] nameCanc,
          ref double[] xInt,
          ref double[] yInt,
          ref double[] arIntCalc,
          ref double[] arIntLeg,
          ref int[] kInt1,
          ref int[] kInt2,
          ref double[] xPolInt,
          ref double[] yPolInt,
          ref int[] nd,
          ref int[] kpp)
        {
            double sArea = 0.0;
            double xc = 0.0;
            double yc = 0.0;
            int num1;
            int num2 = num1 = 0;
            kPolInt = 0;
            int i1 = 0;
            num2 = 0;
            int kArray1 = 999999;
            doubleArray(xSel, ref kArray1);
            doubleArray(ySel, ref kArray1);
            if (kSel > kArray1)
            {
                int num3 = (int)MessageBox.Show("Индекс массива PolyInside");
            }
            else
            {
                int kArray2 = 999999;
                stringArray(namePol, ref kArray2);
                doubleArray(xLab, ref kArray2);
                doubleArray(yLab, ref kArray2);
                doubleArray(arCalc, ref kArray2);
                doubleArray(arLeg, ref kArray2);
                intArray(kPol1, ref kArray2);
                intArray(kPol2, ref kArray2);
                stringArray(nameCanc, ref kArray2);
                doubleArray(xInt, ref kArray2);
                doubleArray(yInt, ref kArray2);
                doubleArray(arIntCalc, ref kArray2);
                doubleArray(arIntLeg, ref kArray2);
                intArray(kInt1, ref kArray2);
                intArray(kInt2, ref kArray2);
                intArray(nd, ref kArray2);
                intArray(kpp, ref kArray2);
                if (kPoly > kArray2)
                {
                    int num4 = (int)MessageBox.Show("Индекс массива PolyInside");
                }
                else
                {
                    int num5 = kPol2[kPoly];
                    kArray2 = 999999;
                    doubleArray(xPol, ref kArray2);
                    doubleArray(yPol, ref kArray2);
                    doubleArray(xPolInt, ref kArray2);
                    doubleArray(yPolInt, ref kArray2);
                    if (num5 > kArray2)
                    {
                        int num6 = (int)MessageBox.Show("Индекс массива PolyInside");
                    }
                    else
                    {
                        int k = 0;
                        for (int i2 = 0; i2 <= kSel; ++i2)
                        {
                            ++k;
                            xInt[k] = xSel[i2];
                            yInt[k] = ySel[i2];
                        }
                        PolyLabel1(k, ref xInt, ref yInt, ref xPolInt, ref yPolInt, ref arIntCalc, out xc, out yc);
                        PolyArea1(k, xInt, yInt, out sArea);
                        int i3 = 0;
                        for (int i4 = 1; i4 <= kPoly; ++i4)
                        {
                            int num7 = kPol1[i4];
                            int num8 = kPol2[i4];
                            if (in_out(kSel, ref xSel, ref ySel, xLab[i4], yLab[i4]) > 0)
                            {
                                ++i1;
                                nd[i1] = i4;
                                int num9 = 0;
                                for (int i5 = num7; i5 <= num8; ++i5)
                                {
                                    ++i3;
                                    ++num9;
                                    xPolInt[i3] = xPol[i5];
                                    yPolInt[i3] = yPol[i5];
                                }
                                ++kPolInt;
                                kpp[kPolInt] = num9;
                                nameCanc[kPolInt] = namePol[i4];
                                xInt[kPolInt] = xLab[i4];
                                yInt[kPolInt] = yLab[i4];
                                arIntCalc[kPolInt] = arCalc[i4];
                                arIntLeg[kPolInt] = arLeg[i4];
                            }
                        }
                        if (kPolInt > 0)
                        {
                            kInt1[1] = 1;
                            kInt2[1] = kpp[1];
                            if (kPolInt > 1)
                            {
                                for (int i6 = 2; i6 <= kPolInt; ++i6)
                                {
                                    kInt1[i6] = kInt2[i6 - 1] + 1;
                                    kInt2[i6] = kInt2[i6 - 1] + kpp[i6];
                                }
                            }
                        }
                        if (i1 <= 0)
                            return;
                        int i7 = 0;
                        int i8 = 0;
                        for (int i9 = 1; i9 <= kPoly; ++i9)
                        {
                            int num10 = 0;
                            for (int i10 = 1; i10 <= i1; ++i10)
                            {
                                if (nd[i10] == i9)
                                {
                                    ++num10;
                                    break;
                                }
                            }
                            if (num10 <= 0)
                            {
                                int num11 = kPol1[i9];
                                int num12 = kPol2[i9];
                                int num13 = 0;
                                for (int i11 = num11; i11 <= num12; ++i11)
                                {
                                    ++i7;
                                    ++num13;
                                    xPol[i7] = xPol[i11];
                                    yPol[i7] = yPol[i11];
                                }
                                ++i8;
                                xLab[i8] = xLab[i9];
                                yLab[i8] = yLab[i9];
                                arCalc[i8] = arCalc[i9];
                                arLeg[i8] = arLeg[i9];
                                kpp[i8] = num13;
                            }
                        }
                        kPoly = i8;
                        if (i8 > 0)
                        {
                            kPol1[1] = 1;
                            kPol2[1] = kpp[1];
                            if (i8 > 1)
                            {
                                for (int i12 = 2; i12 <= i8; ++i12)
                                {
                                    kPol1[i12] = kPol2[i12 - 1] + 1;
                                    kPol2[i12] = kPol2[i12 - 1] + kpp[i12];
                                }
                            }
                        }
                        double num14 = 0.0;
                        if (kPolInt > 0)
                        {
                            for (int i13 = 1; i13 <= kPolInt; ++i13)
                                num14 += arIntLeg[i13];
                        }
                        int i14 = kPol2[kPoly];
                        int num15 = 0;
                        for (int i15 = 0; i15 <= kSel; ++i15)
                        {
                            ++num15;
                            ++i14;
                            xPol[i14] = xSel[i15];
                            yPol[i14] = ySel[i15];
                        }
                        ++kPoly;
                        kPol1[kPoly] = kPol2[kPoly - 1] + 1;
                        kPol2[kPoly] = kPol2[kPoly - 1] + num15;
                        xLab[kPoly] = xc;
                        yLab[kPoly] = yc;
                        arCalc[kPoly] = sArea;
                        arLeg[kPoly] = num14;
                    }
                }
            }
        }

        public static void ParallelBorder(
          double sMove,
          int kSel,
          ref double[] xSel,
          ref double[] ySel,
          double selRad,
          double xSelRad,
          double ySelRad,
          ref int kLine,
          ref double[] rLine,
          ref int[] kLine1,
          ref int[] kLine2,
          ref double[] xLine,
          ref double[] yLine,
          out int kLinInt,
          ref double[] rLinInt,
          ref int[] kLinInt1,
          ref int[] kLinInt2,
          ref double[] xLinInt,
          ref double[] yLinInt,
          out int kBord,
          ref double[] xBord,
          ref double[] yBord,
          ref int[] nd,
          ref int[] kpp,
          ref double[] xd,
          ref double[] yd)
        {
            double[] x1_1 = new double[5];
            double[] y1_1 = new double[5];
            int k2 = 0;
            double[] x2_1 = new double[5];
            double[] y2_1 = new double[5];
            int num1;
            int num2 = num1 = 0;
            kLinInt = 0;
            kBord = 0;
            int num3;
            int num4 = num3 = 0;
            double num5 = 3.1415926;
            double yrd2;
            double xrd2 = yrd2 = 0.0;
            double num6;
            double num7 = num6 = 0.0;
            double num8;
            double num9 = num8 = 0.0;
            double ym = num8;
            double xm = num8;
            double num10;
            double rd2 = num10 = 0.0;
            double num11;
            double num12 = num11 = 0.0;
            double num13;
            double num14 = num13 = 0.0;
            if (sMove < 0.1)
                sMove = 0.1;
            if (selRad == 1.0)
                selRad = 0.0;
            int kArray1 = 999999;
            doubleArray(xSel, ref kArray1);
            doubleArray(ySel, ref kArray1);
            if (kSel > kArray1)
            {
                int num15 = (int)MessageBox.Show("Индекс массива ParallelBorder");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(rLine, ref kArray2);
                intArray(kLine1, ref kArray2);
                intArray(kLine2, ref kArray2);
                doubleArray(rLinInt, ref kArray2);
                intArray(kLinInt1, ref kArray2);
                intArray(kLinInt2, ref kArray2);
                intArray(nd, ref kArray2);
                intArray(kpp, ref kArray2);
                if (kLine > kArray2)
                {
                    int num16 = (int)MessageBox.Show("Индекс массива ParallelBorder");
                }
                else
                {
                    int num17 = kLine2[kLine];
                    kArray2 = 999999;
                    doubleArray(xLine, ref kArray2);
                    doubleArray(yLine, ref kArray2);
                    doubleArray(xLinInt, ref kArray2);
                    doubleArray(yLinInt, ref kArray2);
                    doubleArray(xBord, ref kArray2);
                    doubleArray(yBord, ref kArray2);
                    doubleArray(xd, ref kArray2);
                    doubleArray(yd, ref kArray2);
                    if (num17 > kArray2)
                    {
                        int num18 = (int)MessageBox.Show("Индекс массива ParallelBorder");
                    }
                    else
                    {
                        double num19 = 9999999.9;
                        double num20 = 9999999.9;
                        double num21 = -9999999.9;
                        double num22 = -9999999.9;
                        for (int i = 0; i < kSel; ++i)
                        {
                            if (xSel[i] < num19)
                                num19 = xSel[i];
                            if (xSel[i] > num21)
                                num21 = xSel[i];
                            if (ySel[i] < num20)
                                num20 = ySel[i];
                            if (ySel[i] > num22)
                                num22 = ySel[i];
                        }
                        double num23 = num21 - num19;
                        double num24 = num22 - num20;
                        double num25 = Math.Sqrt(num23 * num23 + num24 * num24);
                        if (selRad <= 0.0)
                        {
                            for (int i1 = 1; i1 < kSel; ++i1)
                            {
                                double x1 = xSel[i1] - xSel[i1 - 1];
                                double num26 = Math.Atan2(ySel[i1] - ySel[i1 - 1], x1);
                                if (num26 < 0.0)
                                    num26 += 2.0 * num5;
                                double num27 = num26 + 0.5 * num5;
                                if (num27 >= 2.0 * num5)
                                    num27 -= 2.0 * num5;
                                double num28 = 0.5 * (xSel[i1] + xSel[i1 - 1]);
                                double num29 = 0.5 * (ySel[i1] + ySel[i1 - 1]);
                                double x1_2 = num28 + num25 * Math.Cos(num27);
                                double y1_2 = num29 + num25 * Math.Sin(num27);
                                double x2_2 = num28 - num25 * Math.Cos(num27);
                                double y2_2 = num29 - num25 * Math.Sin(num27);
                                double num30 = 9999999.9;
                                int num31 = 0;
                                for (int i2 = 1; i2 <= kSel; ++i2)
                                {
                                    if (i1 != i2)
                                    {
                                        double x3 = xSel[i2 - 1];
                                        double y3 = ySel[i2 - 1];
                                        double x4 = xSel[i2];
                                        double y4 = ySel[i2];
                                        int ip = 1;
                                        TwoLine(x1_2, y1_2, x3, y3, x2_2, y2_2, x4, y4, out xm, out ym, ref ip);
                                        if (xm != 0.0 || ym != 0.0)
                                        {
                                            double num32 = xm - num28;
                                            double num33 = ym - num29;
                                            double num34 = Math.Sqrt(num32 * num32 + num33 * num33);
                                            if (num34 >= 0.0001 && num30 > num34)
                                            {
                                                num30 = num34;
                                                num31 = i2;
                                                num19 = xm;
                                                num20 = ym;
                                            }
                                        }
                                    }
                                }
                                if (num30 >= 2.0 * sMove && num31 != 0)
                                {
                                    double x2 = xSel[i1 + 1] - xSel[i1];
                                    double num35 = Math.Atan2(ySel[i1 + 1] - ySel[i1], x2);
                                    if (num35 < 0.0)
                                        num35 += 2.0 * num5;
                                    double num36 = num35 + 0.5 * num5;
                                    if (num36 >= 2.0 * num5)
                                        num36 -= 2.0 * num5;
                                    double num37 = 0.5 * (xSel[i1] + xSel[i1 + 1]);
                                    double num38 = 0.5 * (ySel[i1] + ySel[i1 + 1]);
                                    double x1_3 = num37 + num25 * Math.Cos(num36);
                                    double y1_3 = num38 + num25 * Math.Sin(num36);
                                    double x2_3 = num37 - num25 * Math.Cos(num36);
                                    double y2_3 = num38 - num25 * Math.Sin(num36);
                                    double num39 = 9999999.9;
                                    int num40 = 0;
                                    for (int i3 = 1; i3 <= kSel; ++i3)
                                    {
                                        if (i1 + 1 != i3)
                                        {
                                            double x3 = xSel[i3 - 1];
                                            double y3 = ySel[i3 - 1];
                                            double x4 = xSel[i3];
                                            double y4 = ySel[i3];
                                            int ip = 1;
                                            TwoLine(x1_3, y1_3, x3, y3, x2_3, y2_3, x4, y4, out xm, out ym, ref ip);
                                            if (xm != 0.0 || ym != 0.0)
                                            {
                                                double num41 = xm - num37;
                                                double num42 = ym - num38;
                                                double num43 = Math.Sqrt(num41 * num41 + num42 * num42);
                                                if (num43 >= 0.0001 && num39 > num43)
                                                {
                                                    num39 = num43;
                                                    num40 = i3;
                                                    num21 = xm;
                                                    num22 = ym;
                                                }
                                            }
                                        }
                                    }
                                    if (num39 >= 2.0 * sMove && num40 != 0)
                                    {
                                        double x3 = num21 - num37;
                                        double num44 = Math.Atan2(num22 - num38, x3);
                                        if (num44 < 0.0)
                                            num44 += 2.0 * num5;
                                        num21 = num37 + num30 * Math.Cos(num44);
                                        num22 = num38 + num30 * Math.Sin(num44);
                                        double num45 = 0.5 * (num19 + num21);
                                        double num46 = 0.5 * (num20 + num22);
                                        double x4 = num45 - xSel[i1];
                                        double num47 = Math.Atan2(num46 - ySel[i1], x4);
                                        if (num47 < 0.0)
                                            num47 += 2.0 * num5;
                                        xm = xSel[i1] + sMove * Math.Cos(num47);
                                        ym = ySel[i1] + sMove * Math.Sin(num47);
                                        if (in_out(kSel, ref xSel, ref ySel, xm, ym) == 0)
                                        {
                                            xm = xSel[i1] - sMove * Math.Cos(num47);
                                            ym = ySel[i1] - sMove * Math.Sin(num47);
                                            num4 = in_out(kSel, ref xSel, ref ySel, xm, ym);
                                        }
                                        ++kBord;
                                        xBord[kBord] = xm;
                                        yBord[kBord] = ym;
                                    }
                                }
                            }
                            double x = xSel[1] - xSel[0];
                            double num48 = Math.Atan2(ySel[1] - ySel[0], x);
                            if (num48 < 0.0)
                                num48 += 2.0 * num5;
                            double num49 = num48 + 0.5 * num5;
                            if (num49 >= 2.0 * num5)
                                num49 -= 2.0 * num5;
                            xrd2 = 0.5 * (xSel[1] + xSel[0]);
                            yrd2 = 0.5 * (ySel[1] + ySel[0]);
                            double num50 = xrd2 + sMove * Math.Cos(num49);
                            double num51 = yrd2 + sMove * Math.Sin(num49);
                            if (in_out(kSel, ref xSel, ref ySel, num50, num51) == 0)
                            {
                                num50 = xrd2 - sMove * Math.Cos(num49);
                                num51 = yrd2 - sMove * Math.Sin(num49);
                                num4 = in_out(kSel, ref xSel, ref ySel, num50, num51);
                            }
                            num4 = in_out(kSel, ref xSel, ref ySel, num50, num51);
                            x1_1[0] = xSel[0];
                            y1_1[0] = ySel[0];
                            x1_1[1] = xSel[1];
                            y1_1[1] = ySel[1];
                            int k1 = 1;
                            ParallelLine(num50, num51, sMove, k1, ref x1_1, ref y1_1, out k2, ref x2_1, ref y2_1);
                            double num52 = 0.0;
                            for (int i = 1; i <= 1000; ++i)
                            {
                                num52 += sMove;
                                xBord[0] = x2_1[0] + num52 * Math.Cos(num48);
                                yBord[0] = y2_1[0] + num52 * Math.Sin(num48);
                                if (in_out(kSel, ref xSel, ref ySel, xBord[0], yBord[0]) > 0)
                                    break;
                            }
                            ++kBord;
                            xBord[kBord] = xBord[0];
                            yBord[kBord] = yBord[0];
                        }
                        if (selRad > 0.0)
                        {
                            double rd1 = selRad - sMove;
                            ParallelArcCircle(kSel, ref xSel, ref ySel, ref rd1, ref xSelRad, ref ySelRad, out kBord, ref xBord, ref yBord, out rd2, out xrd2, out yrd2, ref xd, ref yd);
                        }
                        int i4 = 0;
                        int i5 = 0;
                        for (int i6 = 1; i6 <= kLine; ++i6)
                        {
                            int i7 = kLine1[i6];
                            int i8 = kLine2[i6];
                            int num53 = 0;
                            for (int i9 = i7; i9 <= i8; ++i9)
                            {
                                xrd2 = xLine[i9];
                                double yt = yLine[i9];
                                num53 = in_out(kBord, ref xBord, ref yBord, xrd2, yt);
                                if (num53 > 0)
                                    break;
                            }
                            if (num53 == 0 && i8 - i7 == 1)
                            {
                                xrd2 = 0.5 * (xLine[i7] + xLine[i8]);
                                double yt = 0.5 * (yLine[i7] + yLine[i8]);
                                num53 = in_out(kBord, ref xBord, ref yBord, xrd2, yt);
                            }
                            if (num53 > 0)
                            {
                                ++i4;
                                nd[i4] = i6;
                                int num54 = 0;
                                for (int i10 = i7; i10 <= i8; ++i10)
                                {
                                    ++i5;
                                    ++num54;
                                    xLinInt[i5] = xLine[i10];
                                    yLinInt[i5] = yLine[i10];
                                }
                                ++kLinInt;
                                rLinInt[kLinInt] = rLine[i6];
                                kpp[kLinInt] = num54;
                            }
                        }
                        if (i4 == 0)
                            return;
                        kLinInt1[1] = 1;
                        kLinInt2[1] = kpp[1];
                        if (kLinInt > 0)
                        {
                            for (int i11 = 2; i11 <= kLinInt; ++i11)
                            {
                                kLinInt1[i11] = kLinInt2[i11 - 1] + 1;
                                kLinInt2[i11] = kLinInt2[i11 - 1] + kpp[i11];
                            }
                        }
                        int i12 = 0;
                        int i13 = 0;
                        for (int i14 = 1; i14 <= kLine; ++i14)
                        {
                            int num55 = 0;
                            for (int i15 = 1; i15 <= i4; ++i15)
                            {
                                if (nd[i15] == i14)
                                {
                                    ++num55;
                                    break;
                                }
                            }
                            if (num55 <= 0)
                            {
                                int num56 = kLine1[i14];
                                int num57 = kLine2[i14];
                                int num58 = 0;
                                for (int i16 = num56; i16 <= num57; ++i16)
                                {
                                    ++i12;
                                    ++num58;
                                    xLine[i12] = xLine[i16];
                                    yLine[i12] = yLine[i16];
                                }
                                ++i13;
                                rLine[i13] = rLine[i14];
                                kpp[i13] = num58;
                            }
                        }
                        kLine = i13;
                        kLine1[1] = 1;
                        kLine2[1] = kpp[1];
                        if (i13 <= 1)
                            return;
                        for (int i17 = 2; i17 <= i13; ++i17)
                        {
                            kLine1[i17] = kLine2[i17 - 1] + 1;
                            kLine2[i17] = kLine2[i17 - 1] + kpp[i17];
                        }
                    }
                }
            }
        }

        public static void FirstParallel(
          int iParam,
          double arDat,
          double arParc,
          int kPar,
          ref double[] xPar,
          ref double[] yPar,
          ref int kSel,
          ref double[] xSel,
          ref double[] ySel,
          double selRad,
          double xSelRad,
          double ySelRad,
          out double xMove,
          out double yMove,
          out double xPoint,
          out double yPoint,
          out double azHor,
          out double azVer,
          ref double[] xr,
          ref double[] yr,
          ref double[] dr)
        {
            xMove = 0.0;
            yMove = 0.0;
            xPoint = 0.0;
            yPoint = 0.0;
            azHor = 0.0;
            azVer = 0.0;
            double num1 = 3.1415926;
            Cursor.Current = Cursors.WaitCursor;
            int kArray = 999999;
            doubleArray(xPar, ref kArray);
            doubleArray(yPar, ref kArray);
            doubleArray(xSel, ref kArray);
            doubleArray(ySel, ref kArray);
            doubleArray(xr, ref kArray);
            doubleArray(yr, ref kArray);
            doubleArray(dr, ref kArray);
            if (kPar > kArray)
            {
                int num2 = (int)MessageBox.Show("Индекс массива FirstParallel");
            }
            else
            {
                double num3;
                double dist = num3 = 0.0;
                double num4;
                double num5 = num4 = 0.0;
                double num6 = num4;
                double num7 = num4;
                double num8;
                double num9 = num8 = 0.0;
                int num10;
                int num11 = num10 = 0;
                double num12;
                double num13 = num12 = 0.0;
                double num14;
                double num15 = num14 = 0.0;
                double num16 = 9999999.9;
                double num17 = 9999999.9;
                double num18 = -9999999.9;
                double num19 = -9999999.9;
                for (int i = 0; i <= kPar; ++i)
                {
                    if (xPar[i] < num16)
                        num16 = xPar[i];
                    if (xPar[i] > num18)
                        num18 = xPar[i];
                    if (yPar[i] < num17)
                        num17 = yPar[i];
                    if (yPar[i] > num19)
                        num19 = yPar[i];
                }
                double num20 = num18 - num16;
                double num21 = num19 - num17;
                double num22 = Math.Sqrt(num20 * num20 + num21 * num21);
                int ip1;
                if (selRad <= 0.0)
                {
                    double num23 = 0.5 * (xSel[0] + xSel[kSel]);
                    double num24 = 0.5 * (ySel[0] + ySel[kSel]);
                    double x1 = xSel[kSel] - xSel[0];
                    double num25 = Math.Atan2(ySel[kSel] - ySel[0], x1);
                    if (num25 < 0.0)
                        num25 += 2.0 * num1;
                    double num26 = num25 + 0.5 * num1;
                    if (num26 >= 2.0 * num1)
                        num26 -= 2.0 * num1;
                    double x1_1 = num23 - num22 * Math.Cos(num26);
                    double y1_1 = num24 - num22 * Math.Sin(num26);
                    double x2_1 = num23 + num22 * Math.Cos(num26);
                    double y2_1 = num24 + num22 * Math.Sin(num26);
                    xMove = num23 + 0.3 * Math.Cos(num26);
                    yMove = num24 + 0.3 * Math.Sin(num26);
                    xPoint = num23 + 0.1 * Math.Cos(num26);
                    yPoint = num24 + 0.1 * Math.Sin(num26);
                    if (in_out(kPar, ref xPar, ref yPar, xMove, yMove) == 0)
                    {
                        num26 -= num1;
                        if (num26 < 0.0)
                            num26 += 2.0 * num1;
                        xMove = num23 + 0.3 * Math.Cos(num26);
                        yMove = num24 + 0.3 * Math.Sin(num26);
                        xPoint = num23 + 0.1 * Math.Cos(num26);
                        yPoint = num24 + 0.1 * Math.Sin(num26);
                        num11 = in_out(kPar, ref xPar, ref yPar, xMove, yMove);
                    }
                    int i1 = 0;
                    for (int i2 = 1; i2 <= kPar; ++i2)
                    {
                        int ip2 = 1;
                        TwoLine(x1_1, y1_1, xPar[i2 - 1], yPar[i2 - 1], x2_1, y2_1, xPar[i2], yPar[i2], out num7, out num6, ref ip2);
                        if (num7 != 0.0 || num6 != 0.0)
                        {
                            ++i1;
                            xr[i1] = num7;
                            yr[i1] = num6;
                            double num27 = num7 - x1_1;
                            double num28 = num6 - y1_1;
                            dr[i1] = Math.Sqrt(num27 * num27 + num28 * num28);
                        }
                    }
                    if (i1 < 2)
                        return;
                    if (i1 > 1)
                    {
                        ip1 = i1 / 2;
                        if (i1 - 2 * ip1 > 0)
                            --i1;
                        for (int i3 = 1; i3 < i1; ++i3)
                        {
                            for (int i4 = i3 + 1; i4 <= i1; ++i4)
                            {
                                if (dr[i3] > dr[i4])
                                {
                                    num7 = xr[i3];
                                    num6 = yr[i3];
                                    num3 = dr[i3];
                                    xr[i3] = xr[i4];
                                    yr[i3] = yr[i4];
                                    dr[i3] = dr[i4];
                                    xr[i4] = num7;
                                    yr[i4] = num6;
                                    dr[i4] = num3;
                                }
                            }
                        }
                        if (iParam == 1 || iParam == 3)
                            num3 = arDat / arParc;
                        for (int i5 = 2; i5 <= i1; ++i5)
                        {
                            DistPnt(xMove, yMove, xr[i5 - 1], yr[i5 - 1], xr[i5], yr[i5], out dist, out ip1, out num7, out num6);
                            if (ip1 > 0)
                            {
                                if (iParam == 2)
                                {
                                    xMove = num23 + arDat * Math.Cos(num26);
                                    yMove = num24 + arDat * Math.Sin(num26);
                                    xPoint = num23 + 0.1 * Math.Cos(num26);
                                    yPoint = num24 + 0.1 * Math.Sin(num26);
                                    ip1 = in_out(kPar, ref xPar, ref yPar, xMove, yMove);
                                    if (ip1 == 0)
                                    {
                                        double num29 = num26 - num1;
                                        if (num29 < 0.0)
                                            num29 += 2.0 * num1;
                                        xMove = num23 + arDat * Math.Cos(num29);
                                        yMove = num24 + arDat * Math.Sin(num29);
                                        xPoint = num23 + 0.1 * Math.Cos(num29);
                                        yPoint = num24 + 0.1 * Math.Sin(num29);
                                        break;
                                    }
                                    break;
                                }
                                double num30 = xr[i5] - xr[i5 - 1];
                                double num31 = yr[i5] - yr[i5 - 1];
                                dist = Math.Sqrt(num30 * num30 + num31 * num31);
                                xMove = num23 + num3 * dist * Math.Cos(num26);
                                yMove = num24 + num3 * dist * Math.Sin(num26);
                                xPoint = num23 + 0.1 * Math.Cos(num26);
                                yPoint = num24 + 0.1 * Math.Sin(num26);
                                ip1 = in_out(kPar, ref xPar, ref yPar, xMove, yMove);
                                if (ip1 == 0)
                                {
                                    double num32 = num26 - num1;
                                    if (num32 < 0.0)
                                        num32 += 2.0 * num1;
                                    xMove = num23 + num3 * dist * Math.Cos(num32);
                                    yMove = num24 + num3 * dist * Math.Sin(num32);
                                    xPoint = num23 + 0.1 * Math.Cos(num32);
                                    yPoint = num24 + 0.1 * Math.Sin(num32);
                                    break;
                                }
                                break;
                            }
                        }
                    }
                    double x1_2 = xMove - num22 * Math.Cos(num25);
                    double y1_2 = yMove - num22 * Math.Sin(num25);
                    double x2_2 = xMove + num22 * Math.Cos(num25);
                    double y2_2 = yMove + num22 * Math.Sin(num25);
                    int i6 = 0;
                    for (int i7 = 1; i7 <= kPar; ++i7)
                    {
                        ip1 = 1;
                        TwoLine(x1_2, y1_2, xPar[i7 - 1], yPar[i7 - 1], x2_2, y2_2, xPar[i7], yPar[i7], out num7, out num6, ref ip1);
                        if (num7 != 0.0 || num6 != 0.0)
                        {
                            ++i6;
                            xr[i6] = num7;
                            yr[i6] = num6;
                            double num33 = num7 - x1_2;
                            double num34 = num6 - y1_2;
                            dr[i6] = Math.Sqrt(num33 * num33 + num34 * num34);
                        }
                    }
                    if (i6 < 2)
                        return;
                    if (i6 > 1)
                    {
                        ip1 = i6 / 2;
                        if (i6 - 2 * ip1 > 0)
                            --i6;
                        for (int i8 = 1; i8 < i6; ++i8)
                        {
                            for (int i9 = i8 + 1; i9 <= i6; ++i9)
                            {
                                if (dr[i8] > dr[i9])
                                {
                                    num7 = xr[i8];
                                    num6 = yr[i8];
                                    double num35 = dr[i8];
                                    xr[i8] = xr[i9];
                                    yr[i8] = yr[i9];
                                    dr[i8] = dr[i9];
                                    xr[i9] = num7;
                                    yr[i9] = num6;
                                    dr[i9] = num35;
                                }
                            }
                        }
                        for (int i10 = 2; i10 <= i6; ++i10)
                        {
                            DistPnt(xMove, yMove, xr[i10 - 1], yr[i10 - 1], xr[i10], yr[i10], out dist, out ip1, out num7, out num6);
                            if (ip1 > 0)
                            {
                                kSel = 1;
                                xSel[0] = xr[i10 - 1];
                                ySel[0] = yr[i10 - 1];
                                xSel[1] = xr[i10];
                                ySel[1] = yr[i10];
                                break;
                            }
                        }
                    }
                    azHor = num25;
                    double x2 = xMove - xPoint;
                    double y = yMove - yPoint;
                    azVer = Math.Atan2(y, x2);
                    if (azVer < 0.0)
                        azVer += 2.0 * num1;
                    xMove -= 0.01 * Math.Cos(azVer);
                    yMove -= 0.01 * Math.Sin(azVer);
                }
                if (selRad <= 0.0)
                    return;
                xPoint = xSel[kSel / 2];
                yPoint = ySel[kSel / 2];
                ip1 = in_out(kPar, ref xPar, ref yPar, xPoint, yPoint);
                double x3 = xPoint - xSelRad;
                double num36 = Math.Atan2(yPoint - ySelRad, x3);
                if (num36 < 0.0)
                    num36 += 2.0 * num1;
                if (iParam == 2)
                {
                    double num37 = selRad - arDat;
                    xMove = xSelRad + num37 * Math.Cos(num36);
                    yMove = ySelRad + num37 * Math.Sin(num36);
                    ip1 = in_out(kPar, ref xPar, ref yPar, xMove, yMove);
                    if (ip1 == 0)
                    {
                        num36 -= num1;
                        if (num36 < 0.0)
                            num36 += 2.0 * num1;
                        xMove = xSelRad + num37 * Math.Cos(num36);
                        yMove = ySelRad + num37 * Math.Sin(num36);
                        ip1 = in_out(kPar, ref xPar, ref yPar, xMove, yMove);
                    }
                    if (ip1 == 0)
                    {
                        double num38 = selRad + arDat;
                        xMove = xSelRad + num38 * Math.Cos(num36);
                        yMove = ySelRad + num38 * Math.Sin(num36);
                        ip1 = in_out(kPar, ref xPar, ref yPar, xMove, yMove);
                        if (ip1 == 0)
                        {
                            num36 -= num1;
                            if (num36 < 0.0)
                                num36 += 2.0 * num1;
                            xMove = xSelRad + num38 * Math.Cos(num36);
                            yMove = ySelRad + num38 * Math.Sin(num36);
                            ip1 = in_out(kPar, ref xPar, ref yPar, xMove, yMove);
                        }
                    }
                }
                if (iParam == 1 || iParam == 3)
                {
                    double num39 = arDat / arParc;
                    double num40 = 0.0;
                    do
                    {
                        num40 += 0.1;
                        double xt = xPoint - num40 * Math.Cos(num36);
                        double yt = yPoint - num40 * Math.Sin(num36);
                        ip1 = in_out(kPar, ref xPar, ref yPar, xt, yt);
                    }
                    while (ip1 > 0);
                    if (num40 < 0.25)
                    {
                        num40 = 0.0;
                        do
                        {
                            num40 += 0.1;
                            double xt = xPoint + num40 * Math.Cos(num36);
                            double yt = yPoint + num40 * Math.Sin(num36);
                            ip1 = in_out(kPar, ref xPar, ref yPar, xt, yt);
                        }
                        while (ip1 > 0);
                    }
                    double num41 = num40 / 2.0;
                    double num42 = selRad - num39 * num41;
                    xMove = xSelRad + num42 * Math.Cos(num36);
                    yMove = ySelRad + num42 * Math.Sin(num36);
                    ip1 = in_out(kPar, ref xPar, ref yPar, xMove, yMove);
                    if (ip1 == 0)
                    {
                        num36 -= num1;
                        if (num36 < 0.0)
                            num36 += 2.0 * num1;
                        xMove = xSelRad + num42 * Math.Cos(num36);
                        yMove = ySelRad + num42 * Math.Sin(num36);
                        ip1 = in_out(kPar, ref xPar, ref yPar, xMove, yMove);
                    }
                    if (ip1 == 0)
                    {
                        double num43 = selRad + num39 * num41;
                        xMove = xSelRad + num43 * Math.Cos(num36);
                        yMove = ySelRad + num43 * Math.Sin(num36);
                        ip1 = in_out(kPar, ref xPar, ref yPar, xMove, yMove);
                        if (ip1 == 0)
                        {
                            num36 -= num1;
                            if (num36 < 0.0)
                                num36 += 2.0 * num1;
                            xMove = xSelRad + num43 * Math.Cos(num36);
                            yMove = ySelRad + num43 * Math.Sin(num36);
                            ip1 = in_out(kPar, ref xPar, ref yPar, xMove, yMove);
                        }
                    }
                }
                double x4 = xMove - xPoint;
                double num44 = Math.Atan2(yMove - yPoint, x4);
                if (num44 < 0.0)
                    num44 += 2.0 * num1;
                xPoint += 0.3 * Math.Cos(num44);
                yPoint += 0.3 * Math.Sin(num44);
                azHor = num36;
                azVer = num36;
            }
        }

        public static void ParallelParcel(
          double xMove,
          double yMove,
          double azHor,
          int k,
          ref double[] x,
          ref double[] y,
          int kin,
          ref int[] kn1,
          ref int[] kn2,
          ref double[] xin,
          ref double[] yin,
          double selRad,
          double xSelRad,
          double ySelRad,
          out int kLin,
          ref double[] outRad,
          ref int[] kp1,
          ref int[] kp2,
          ref double[] xp,
          ref double[] yp,
          ref double[] xr,
          ref double[] yr,
          ref double[] sr,
          ref double[] xa,
          ref double[] ya)
        {
            int[] numArray1 = new int[100];
            double[] numArray2 = new double[100];
            double[] numArray3 = new double[100];
            int num1;
            int kWork = num1 = 0;
            int num2;
            int num3 = num2 = 0;
            kLin = 0;
            int num4;
            int num5 = num4 = 0;
            double num6;
            double ym1 = num6 = 0.0;
            double xm1 = num6;
            double ym2 = num6;
            double xm2 = num6;
            double num7;
            double num8 = num7 = 0.0;
            double num9;
            double num10 = num9 = 0.0;
            double num11;
            double num12 = num11 = 0.0;
            int kArray = 999999;
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            doubleArray(xin, ref kArray);
            doubleArray(yin, ref kArray);
            doubleArray(xp, ref kArray);
            doubleArray(yp, ref kArray);
            doubleArray(xr, ref kArray);
            doubleArray(yr, ref kArray);
            doubleArray(sr, ref kArray);
            doubleArray(xa, ref kArray);
            doubleArray(ya, ref kArray);
            doubleArray(outRad, ref kArray);
            intArray(kn1, ref kArray);
            intArray(kn2, ref kArray);
            intArray(kp1, ref kArray);
            intArray(kp2, ref kArray);
            if (k > kArray)
            {
                int num13 = (int)MessageBox.Show("Индекс массива ParallelParcel");
            }
            else
            {
                double num14 = 9999999.9;
                double num15 = 9999999.9;
                double num16 = -9999999.9;
                double num17 = -9999999.9;
                for (int i = 0; i <= k; ++i)
                {
                    if (x[i] < num14)
                        num14 = x[i];
                    if (x[i] > num16)
                        num16 = x[i];
                    if (y[i] < num15)
                        num15 = y[i];
                    if (y[i] > num17)
                        num17 = y[i];
                }
                double num18 = num16 - num14;
                double num19 = num17 - num15;
                double num20 = Math.Sqrt(num18 * num18 + num19 * num19);
                if (selRad == 0.0)
                {
                    double x1 = xMove - num20 * Math.Cos(azHor);
                    double y1 = yMove - num20 * Math.Sin(azHor);
                    double x2 = xMove + num20 * Math.Cos(azHor);
                    double y2 = yMove + num20 * Math.Sin(azHor);
                    int i1 = 0;
                    for (int i2 = 1; i2 <= k; ++i2)
                    {
                        double x3 = x[i2 - 1];
                        double y3 = y[i2 - 1];
                        double x4 = x[i2];
                        double y4 = y[i2];
                        int ip = 1;
                        TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm1, out ym1, ref ip);
                        if (xm1 != 0.0 || ym1 != 0.0)
                        {
                            ++i1;
                            xr[i1] = xm1;
                            yr[i1] = ym1;
                            double num21 = xm1 - x1;
                            double num22 = ym1 - y1;
                            sr[i1] = Math.Sqrt(num21 * num21 + num22 * num22);
                        }
                    }
                    if (kin > 0)
                    {
                        for (int i3 = 1; i3 <= kin; ++i3)
                        {
                            int num23 = kn1[i3];
                            int num24 = kn2[i3];
                            for (int i4 = num23 + 1; i4 <= num24; ++i4)
                            {
                                double x3 = xin[i4 - 1];
                                double y3 = yin[i4 - 1];
                                double x4 = xin[i4];
                                double y4 = yin[i4];
                                int ip = 1;
                                TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm1, out ym1, ref ip);
                                if (xm1 != 0.0 || ym1 != 0.0)
                                {
                                    ++i1;
                                    xr[i1] = xm1;
                                    yr[i1] = ym1;
                                    double num25 = xm1 - x1;
                                    double num26 = ym1 - y1;
                                    sr[i1] = Math.Sqrt(num25 * num25 + num26 * num26);
                                }
                            }
                        }
                    }
                    if (i1 > 1)
                    {
                        int num27 = i1 / 2;
                        num5 = i1 - num27 * 2;
                        for (int i5 = 1; i5 < i1; ++i5)
                        {
                            for (int i6 = i5 + 1; i6 <= i1; ++i6)
                            {
                                if (sr[i5] > sr[i6])
                                {
                                    double num28 = sr[i5];
                                    double num29 = xr[i5];
                                    double num30 = yr[i5];
                                    sr[i5] = sr[i6];
                                    xr[i5] = xr[i6];
                                    yr[i5] = yr[i6];
                                    sr[i6] = num28;
                                    xr[i6] = num29;
                                    yr[i6] = num30;
                                }
                            }
                        }
                        int i7 = 0;
                        for (int i8 = 2; i8 <= i1; ++i8)
                        {
                            double num31 = xr[i8 - 1] - xr[i8];
                            double num32 = yr[i8 - 1] - yr[i8];
                            if (Math.Sqrt(num31 * num31 + num32 * num32) >= 0.1)
                            {
                                xm2 = 0.5 * (xr[i8 - 1] + xr[i8]);
                                ym2 = 0.5 * (yr[i8 - 1] + yr[i8]);
                                if (in_out(k, ref x, ref y, xm2, ym2) != 0)
                                {
                                    int num33 = 0;
                                    if (kin > 0)
                                    {
                                        for (int i9 = 1; i9 <= kin; ++i9)
                                        {
                                            int num34 = kn1[i9];
                                            int num35 = kn2[i9];
                                            kWork = -1;
                                            for (int i10 = num34; i10 <= num35; ++i10)
                                            {
                                                ++kWork;
                                                xa[kWork] = xin[i10];
                                                ya[kWork] = yin[i10];
                                            }
                                            if (in_out(kWork, ref xa, ref ya, xm2, ym2) > 0)
                                            {
                                                ++num33;
                                                break;
                                            }
                                        }
                                    }
                                    if (num33 <= 0)
                                    {
                                        ++kLin;
                                        outRad[kLin] = 0.0;
                                        int i11 = i7 + 1;
                                        xp[i11] = xr[i8 - 1];
                                        yp[i11] = yr[i8 - 1];
                                        i7 = i11 + 1;
                                        xp[i7] = xr[i8];
                                        yp[i7] = yr[i8];
                                    }
                                }
                            }
                        }
                    }
                    kp1[1] = 1;
                    kp2[1] = 2;
                    if (kLin > 1)
                    {
                        for (int i12 = 2; i12 <= kLin; ++i12)
                        {
                            kp1[i12] = kp2[i12 - 1] + 1;
                            kp2[i12] = kp2[i12 - 1] + 2;
                        }
                    }
                }
                if (selRad <= 0.0)
                    return;
                double num36 = xMove - xSelRad;
                double num37 = yMove - ySelRad;
                double Rad = Math.Sqrt(num36 * num36 + num37 * num37);
                Circle_Rad(Rad, xSelRad, ySelRad, out kWork, ref xa, ref ya, ref xr, ref yr);
                int i13 = 0;
                for (int i14 = 1; i14 <= kWork; ++i14)
                {
                    double x1 = xa[i14 - 1];
                    double y1 = ya[i14 - 1];
                    double x2 = xa[i14];
                    double y2 = ya[i14];
                    for (int i15 = 1; i15 <= k; ++i15)
                    {
                        double x3 = x[i15 - 1];
                        double y3 = y[i15 - 1];
                        double x4 = x[i15];
                        double y4 = y[i15];
                        int ip = 1;
                        TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm2, out ym2, ref ip);
                        if (xm2 != 0.0 || ym2 != 0.0)
                        {
                            ++i13;
                            numArray1[i13] = i14;
                            numArray2[i13] = xm2;
                            numArray3[i13] = ym2;
                        }
                    }
                    if (kin > 0)
                    {
                        for (int i16 = 1; i16 <= kin; ++i16)
                        {
                            int num38 = kn1[i16];
                            int num39 = kn2[i16];
                            for (int i17 = num38 + 1; i17 <= num39; ++i17)
                            {
                                double x3 = xin[i17 - 1];
                                double y3 = yin[i17 - 1];
                                double x4 = xin[i17];
                                double y4 = yin[i17];
                                int ip = 1;
                                TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm2, out ym2, ref ip);
                                if (xm2 != 0.0 || ym2 != 0.0)
                                {
                                    ++i13;
                                    numArray1[i13] = i14;
                                    numArray2[i13] = xm2;
                                    numArray3[i13] = ym2;
                                }
                            }
                        }
                    }
                }
                if (i13 == 0)
                {
                    int i18 = 0;
                    int num40 = 0;
                    int num41 = kWork / 2;
                    for (int i19 = 0; i19 <= num41; ++i19)
                    {
                        ++i18;
                        ++num40;
                        xp[i18] = xa[i19];
                        yp[i18] = ya[i19];
                    }
                    if (num40 > 1)
                    {
                        ++kLin;
                        numArray1[kLin] = num40;
                        outRad[kLin] = Rad;
                    }
                    int num42 = 0;
                    for (int i20 = num41; i20 <= kWork; ++i20)
                    {
                        ++i18;
                        ++num42;
                        xp[i18] = xa[i20];
                        yp[i18] = ya[i20];
                    }
                    if (num42 > 1)
                    {
                        ++kLin;
                        numArray1[kLin] = num42;
                        outRad[kLin] = Rad;
                    }
                    kp1[1] = 1;
                    kp2[1] = numArray1[1];
                    for (int i21 = 2; i21 <= kLin; ++i21)
                    {
                        kp1[i21] = kp2[i21 - 1] + 1;
                        kp2[i21] = kp2[i21 - 1] + numArray1[i21];
                    }
                }
                else
                {
                    int i22 = in_out(k, ref x, ref y, xa[kWork], ya[kWork]);
                    int i23 = 0;
                    if (i22 > 0)
                    {
                        int i24 = kWork + 1;
                        do
                        {
                            --i24;
                        }
                        while (i24 >= 0 && in_out(k, ref x, ref y, xa[i24], ya[i24]) > 0);
                        int num43 = i24 + 1;
                        int num44 = 0;
                        for (int i25 = num43; i25 <= kWork && in_out(k, ref x, ref y, xa[i25], ya[i25]) != 0; ++i25)
                        {
                            int num45 = 0;
                            if (kin > 0)
                            {
                                for (int i26 = 1; i26 <= kin; ++i26)
                                {
                                    int num46 = kn1[i26];
                                    int num47 = kn2[i26];
                                    int k1 = -1;
                                    for (int i27 = num46; i27 <= num47; ++i27)
                                    {
                                        ++k1;
                                        xr[k1] = xin[i27];
                                        yr[k1] = yin[i27];
                                    }
                                    num45 = in_out(k1, ref xr, ref yr, xa[i25], ya[i25]);
                                    if (num45 > 0)
                                        break;
                                }
                            }
                            if (num45 == 0)
                            {
                                ++num44;
                                ++i23;
                                xp[i23] = xa[i25];
                                yp[i23] = ya[i25];
                            }
                            else if (num45 > 0 && num44 > 1)
                            {
                                ++kLin;
                                numArray1[kLin] = num44;
                                outRad[kLin] = Rad;
                                num44 = 0;
                            }
                        }
                        if (num44 >= kWork)
                        {
                            ++kLin;
                            numArray1[kLin] = num44;
                            outRad[kLin] = Rad;
                        }
                        if (i24 > 0)
                        {
                            for (int i28 = 1; i28 <= i24; ++i28)
                            {
                                int num48 = in_out(k, ref x, ref y, xa[i28], ya[i28]);
                                if (num48 == 0 && num44 > 1)
                                {
                                    ++kLin;
                                    numArray1[kLin] = num44;
                                    outRad[kLin] = Rad;
                                    num44 = 0;
                                }
                                if (num48 > 0)
                                {
                                    int num49 = 0;
                                    if (kin > 0)
                                    {
                                        for (int i29 = 1; i29 <= kin; ++i29)
                                        {
                                            int num50 = kn1[i29];
                                            int num51 = kn2[i29];
                                            int k2 = -1;
                                            for (int i30 = num50; i30 <= num51; ++i30)
                                            {
                                                ++k2;
                                                xr[k2] = xin[i30];
                                                yr[k2] = yin[i30];
                                            }
                                            num49 = in_out(k2, ref xr, ref yr, xa[i28], ya[i28]);
                                            if (num49 > 0)
                                                break;
                                        }
                                    }
                                    if (num49 == 0)
                                    {
                                        ++num44;
                                        ++i23;
                                        xp[i23] = xa[i28];
                                        yp[i23] = ya[i28];
                                    }
                                    else if (num49 > 0 && num44 > 1)
                                    {
                                        ++kLin;
                                        numArray1[kLin] = num44;
                                        outRad[kLin] = Rad;
                                        num44 = 0;
                                    }
                                }
                            }
                        }
                    }
                    if (i22 == 0)
                    {
                        int num52 = 0;
                        for (int i31 = 0; i31 <= kWork; ++i31)
                        {
                            if (in_out(k, ref x, ref y, xa[i31], ya[i31]) == 0)
                            {
                                if (num52 > 1)
                                {
                                    ++kLin;
                                    numArray1[kLin] = num52;
                                    outRad[kLin] = Rad;
                                    num52 = 0;
                                }
                            }
                            else
                            {
                                int num53 = 0;
                                if (kin > 0)
                                {
                                    for (int i32 = 1; i32 <= kin; ++i32)
                                    {
                                        int num54 = kn1[i32];
                                        int num55 = kn2[i32];
                                        int k3 = -1;
                                        for (int i33 = num54; i33 <= num55; ++i33)
                                        {
                                            ++k3;
                                            xr[k3] = xin[i33];
                                            yr[k3] = yin[i33];
                                        }
                                        num53 = in_out(k3, ref xr, ref yr, xa[i31], ya[i31]);
                                        if (num53 > 0)
                                            break;
                                    }
                                }
                                if (num53 == 0)
                                {
                                    ++num52;
                                    ++i23;
                                    xp[i23] = xa[i31];
                                    yp[i23] = ya[i31];
                                }
                                else if (num53 > 0 && num52 > 1)
                                {
                                    ++kLin;
                                    numArray1[kLin] = num52;
                                    outRad[kLin] = Rad;
                                    num52 = 0;
                                }
                            }
                        }
                    }
                    if (kLin <= 0)
                        return;
                    kp1[1] = 1;
                    kp2[1] = numArray1[1];
                    if (kLin > 1)
                    {
                        for (int i34 = 2; i34 <= kLin; ++i34)
                        {
                            kp1[i34] = kp2[i34 - 1] + 1;
                            kp2[i34] = kp2[i34 - 1] + numArray1[i34];
                        }
                    }
                    if (i13 <= 0)
                        return;
                    for (int i35 = 1; i35 <= kLin; ++i35)
                    {
                        int i36 = kp1[i35];
                        int i37 = kp2[i35];
                        double num56 = 9999999.9;
                        for (int i38 = 1; i38 <= i13; ++i38)
                        {
                            double num57 = numArray2[i38] - xp[i36];
                            double num58 = numArray3[i38] - yp[i36];
                            double num59 = Math.Sqrt(num57 * num57 + num58 * num58);
                            if (num59 < num56)
                            {
                                num56 = num59;
                                i22 = i38;
                            }
                        }
                        xp[i36] = numArray2[i22];
                        yp[i36] = numArray3[i22];
                        double num60 = 9999999.9;
                        for (int i39 = 1; i39 <= i13; ++i39)
                        {
                            double num61 = numArray2[i39] - xp[i37];
                            double num62 = numArray3[i39] - yp[i37];
                            double num63 = Math.Sqrt(num61 * num61 + num62 * num62);
                            if (num63 < num60)
                            {
                                num60 = num63;
                                i22 = i39;
                            }
                        }
                        xp[i37] = numArray2[i22];
                        yp[i37] = numArray3[i22];
                    }
                }
            }
        }

        public static void FindPolyCancel(
          int kPoly1,
          ref string[] sName1,
          ref double[] xLab1,
          ref double[] yLab1,
          ref double[] arCalc1,
          ref double[] arLeg1,
          ref int[] kPol1,
          ref int[] kPol2,
          ref double[] xPol1,
          ref double[] yPol1,
          int kPoly2,
          ref string[] sName2,
          ref double[] xLab2,
          ref double[] yLab2,
          ref double[] arCalc2,
          ref double[] arLeg2,
          ref int[] kPop1,
          ref int[] kPop2,
          ref double[] xPol2,
          ref double[] yPol2,
          out int kPol,
          ref string[] sName,
          ref double[] xLab,
          ref double[] yLab,
          ref double[] aCalc,
          ref double[] aLeg,
          ref double[] xa,
          ref double[] ya)
        {
            kPol = 0;
            int num1;
            int num2 = num1 = 0;
            int kArray1 = 999999;
            stringArray(sName1, ref kArray1);
            doubleArray(xLab1, ref kArray1);
            doubleArray(yLab1, ref kArray1);
            doubleArray(arCalc1, ref kArray1);
            doubleArray(arLeg1, ref kArray1);
            intArray(kPol1, ref kArray1);
            intArray(kPol2, ref kArray1);
            stringArray(sName2, ref kArray1);
            doubleArray(xLab2, ref kArray1);
            doubleArray(yLab2, ref kArray1);
            doubleArray(arCalc2, ref kArray1);
            doubleArray(arLeg2, ref kArray1);
            intArray(kPop1, ref kArray1);
            intArray(kPop2, ref kArray1);
            stringArray(sName, ref kArray1);
            doubleArray(xLab, ref kArray1);
            doubleArray(yLab, ref kArray1);
            doubleArray(aCalc, ref kArray1);
            doubleArray(aLeg, ref kArray1);
            if (kPoly1 > kArray1)
            {
                int num3 = (int)MessageBox.Show("Индекс массива FindPolyCancel");
            }
            else
            {
                int num4 = kPol2[kPoly1];
                int kArray2 = 999999;
                doubleArray(xPol1, ref kArray2);
                doubleArray(yPol1, ref kArray2);
                doubleArray(xPol2, ref kArray2);
                doubleArray(yPol2, ref kArray2);
                doubleArray(xa, ref kArray2);
                doubleArray(ya, ref kArray2);
                if (num4 > kArray2)
                {
                    int num5 = (int)MessageBox.Show("Индекс массива FindPolyCancel");
                }
                else
                {
                    for (int i1 = 1; i1 <= kPoly1; ++i1)
                    {
                        int num6 = kPol1[i1];
                        int num7 = kPol2[i1];
                        int k = -1;
                        for (int i2 = num6; i2 <= num7; ++i2)
                        {
                            ++k;
                            xa[k] = xPol1[i2];
                            ya[k] = yPol1[i2];
                        }
                        int num8 = 0;
                        for (int i3 = 1; i3 <= kPoly2; ++i3)
                        {
                            if (in_out(k, ref xa, ref ya, xLab2[i3], yLab2[i3]) > 0 && Math.Abs(arCalc1[i1] - arCalc2[i3]) < 0.02)
                            {
                                ++num8;
                                break;
                            }
                        }
                        if (num8 <= 0)
                        {
                            ++kPol;
                            sName[kPol] = sName1[i1];
                            xLab[kPol] = xLab1[i1];
                            yLab[kPol] = yLab1[i1];
                            aCalc[kPol] = arCalc1[i1];
                            aLeg[kPol] = arLeg1[i1];
                        }
                    }
                }
            }
        }

        public static void NewInPrev(
          double arDat,
          int k,
          double[] x,
          double[] y,
          int kNew,
          string[] nameNew,
          double[] xLabNew,
          double[] yLabNew,
          double[] aCalcNew,
          double[] aLegNew,
          out int kPol,
          string[] namePol,
          double[] xLab,
          double[] yLab,
          double[] arCalc,
          double[] arLeg)
        {
            kPol = 0;
            int kArray1 = 999999;
            stringArray(nameNew, ref kArray1);
            doubleArray(xLabNew, ref kArray1);
            doubleArray(yLabNew, ref kArray1);
            doubleArray(aCalcNew, ref kArray1);
            doubleArray(aLegNew, ref kArray1);
            stringArray(namePol, ref kArray1);
            doubleArray(xLab, ref kArray1);
            doubleArray(yLab, ref kArray1);
            doubleArray(arCalc, ref kArray1);
            doubleArray(arLeg, ref kArray1);
            if (kNew > kArray1)
            {
                int num1 = (int)MessageBox.Show("Индекс массива NewInPrev");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                if (k > kArray2)
                {
                    int num2 = (int)MessageBox.Show("Индекс массива NewInPrev");
                }
                else
                {
                    for (int i = 1; i <= kNew; ++i)
                    {
                        if (in_out(k, ref x, ref y, xLabNew[i], yLabNew[i]) > 0 && arDat > aCalcNew[i])
                        {
                            ++kPol;
                            namePol[kPol] = nameNew[i];
                            xLab[kPol] = xLabNew[i];
                            yLab[kPol] = yLabNew[i];
                            arCalc[kPol] = aCalcNew[i];
                            arLeg[kPol] = aLegNew[i];
                        }
                    }
                }
            }
        }

        public static void LineInside(
          int kSel,
          ref double[] xSel,
          ref double[] ySel,
          ref double radSel,
          ref double xRadSel,
          ref double yRadSel,
          ref int kLine,
          ref double[] rRad,
          ref int[] kLine1,
          ref int[] kLine2,
          ref double[] xLine,
          ref double[] yLine,
          out int kLinInt,
          ref double[] rRadInt,
          ref int[] kLinInt1,
          ref int[] kLinInt2,
          ref double[] xLinInt,
          ref double[] yLinInt,
          ref double[] xa,
          ref double[] ya,
          ref int[] nd,
          ref int[] kpp,
          ref double[] xd,
          ref double[] yd)
        {
            int num1;
            int num2 = num1 = 0;
            kLinInt = 0;
            int num3;
            int num4 = num3 = 0;
            int k2 = num3;
            int i1 = num3;
            double num5 = 3.1415926;
            double yrd2;
            double xrd2 = yrd2 = 0.0;
            double num6;
            double num7 = num6 = 0.0;
            double num8;
            double num9 = num8 = 0.0;
            double Dist = 0.1;
            double rd2 = 0.0;
            int kArray1 = 999999;
            doubleArray(rRad, ref kArray1);
            doubleArray(rRadInt, ref kArray1);
            intArray(kLine1, ref kArray1);
            intArray(kLine2, ref kArray1);
            intArray(kLinInt1, ref kArray1);
            intArray(kLinInt2, ref kArray1);
            intArray(nd, ref kArray1);
            intArray(kpp, ref kArray1);
            if (kLine > kArray1)
            {
                int num10 = (int)MessageBox.Show("Индекс массива LineInside");
            }
            else
            {
                int kArray2 = 999999;
                int num11 = kLine2[kLine];
                doubleArray(xLine, ref kArray2);
                doubleArray(yLine, ref kArray2);
                doubleArray(xLinInt, ref kArray2);
                doubleArray(yLinInt, ref kArray2);
                doubleArray(xa, ref kArray2);
                doubleArray(ya, ref kArray2);
                doubleArray(xd, ref kArray2);
                doubleArray(yd, ref kArray2);
                if (num11 > kArray2)
                {
                    int num12 = (int)MessageBox.Show("Индекс массива LineInside");
                }
                else
                {
                    kArray2 = 999999;
                    doubleArray(xSel, ref kArray2);
                    doubleArray(ySel, ref kArray2);
                    if (kSel > kArray2)
                    {
                        int num13 = (int)MessageBox.Show("Индекс массива LineInside");
                    }
                    else
                    {
                        num2 = 0;
                        if (radSel == 0.0)
                        {
                            for (int i2 = 1; i2 <= kSel; ++i2)
                            {
                                double num14 = xSel[i2] - xSel[i2 - 1];
                                double num15 = ySel[i2] - ySel[i2 - 1];
                                double num16 = Math.Sqrt(num14 * num14 + num15 * num15);
                                if (num16 > rd2)
                                {
                                    rd2 = num16;
                                    i1 = i2;
                                }
                            }
                            double x = xSel[i1] - xSel[i1 - 1];
                            double num17 = Math.Atan2(ySel[i1] - ySel[i1 - 1], x);
                            if (num17 < 0.0)
                                num17 += 2.0 * num5;
                            double num18 = num17 + 0.5 * num5;
                            if (num18 >= 2.0 * num5)
                                num18 -= 2.0 * num5;
                            xrd2 = 0.5 * (xSel[i1] + xSel[i1 - 1]);
                            yrd2 = 0.5 * (ySel[i1] + ySel[i1 - 1]);
                            double num19 = xrd2 + Dist * Math.Cos(num18);
                            double num20 = yrd2 + Dist * Math.Sin(num18);
                            if (in_out(kSel, ref xSel, ref ySel, num19, num20) == 0)
                            {
                                num19 = xrd2 - Dist * Math.Cos(num18);
                                num20 = yrd2 - Dist * Math.Sin(num18);
                            }
                            ParallelLine(num19, num20, Dist, kSel, ref xSel, ref ySel, out k2, ref xa, ref ya);
                        }
                        if (radSel > 0.0)
                        {
                            double rd1 = radSel - Dist;
                            ParallelArcCircle(kSel, ref xSel, ref ySel, ref rd1, ref xRadSel, ref yRadSel, out k2, ref xa, ref ya, out rd2, out xrd2, out yrd2, ref xd, ref yd);
                        }
                        int i3 = 0;
                        int i4 = 0;
                        for (int i5 = 1; i5 <= kLine; ++i5)
                        {
                            int i6 = kLine1[i5];
                            int i7 = kLine2[i5];
                            int num21 = 0;
                            for (int i8 = i6; i8 <= i7; ++i8)
                            {
                                double xt = xLine[i8];
                                double yt = yLine[i8];
                                num21 = in_out(k2, ref xa, ref ya, xt, yt);
                                if (num21 > 0)
                                    break;
                            }
                            if (num21 == 0 && i7 - i6 == 1)
                            {
                                double xt = 0.5 * (xLine[i6] + xLine[i7]);
                                double yt = 0.5 * (yLine[i6] + yLine[i7]);
                                num21 = in_out(k2, ref xa, ref ya, xt, yt);
                            }
                            if (num21 > 0)
                            {
                                ++i3;
                                nd[i3] = i5;
                                int num22 = 0;
                                for (int i9 = i6; i9 <= i7; ++i9)
                                {
                                    ++i4;
                                    ++num22;
                                    xLinInt[i4] = xLine[i9];
                                    yLinInt[i4] = yLine[i9];
                                }
                                ++kLinInt;
                                kpp[kLinInt] = num22;
                                rRadInt[kLinInt] = rRad[i5];
                            }
                        }
                        if (i3 == 0)
                            return;
                        kLinInt1[1] = 1;
                        kLinInt2[1] = kpp[1];
                        if (kLinInt > 0)
                        {
                            for (int i10 = 2; i10 <= kLinInt; ++i10)
                            {
                                kLinInt1[i10] = kLinInt2[i10 - 1] + 1;
                                kLinInt2[i10] = kLinInt2[i10 - 1] + kpp[i10];
                            }
                        }
                        int i11 = 0;
                        int i12 = 0;
                        for (int i13 = 1; i13 <= kLine; ++i13)
                        {
                            int num23 = 0;
                            for (int i14 = 1; i14 <= i3; ++i14)
                            {
                                if (nd[i14] == i13)
                                {
                                    ++num23;
                                    break;
                                }
                            }
                            if (num23 <= 0)
                            {
                                int num24 = kLine1[i13];
                                int num25 = kLine2[i13];
                                int num26 = 0;
                                for (int i15 = num24; i15 <= num25; ++i15)
                                {
                                    ++i11;
                                    ++num26;
                                    xLine[i11] = xLine[i15];
                                    yLine[i11] = yLine[i15];
                                }
                                ++i12;
                                kpp[i12] = num26;
                                rRad[i12] = rRad[i13];
                            }
                        }
                        kLine = i12;
                        kLine1[1] = 1;
                        kLine2[1] = kpp[1];
                        if (i12 <= 1)
                            return;
                        for (int i16 = 2; i16 <= i12; ++i16)
                        {
                            kLine1[i16] = kLine2[i16 - 1] + 1;
                            kLine2[i16] = kLine2[i16 - 1] + kpp[i16];
                        }
                    }
                }
            }
        }

        public static void PolyTopology(
          int kLin,
          ref int[] k1,
          ref int[] k2,
          ref double[] x,
          ref double[] y,
          int knd,
          ref double[] xnd,
          ref double[] ynd,
          out int kPoly,
          ref string[] namePol,
          ref double[] xPol,
          ref double[] yPol,
          ref double[] zPol,
          ref double[] aLegal,
          ref int[] nSymbPol,
          ref int[] kp1,
          ref int[] kp2,
          ref int[] kp,
          ref double[] xp,
          ref double[] yp,
          double tol,
          ref double[] xa,
          ref double[] ya,
          ref double[] xb,
          ref double[] yb,
          ref double[] xm,
          ref double[] ym,
          ref double[] zm,
          ref int[] ina,
          ref int[] inb,
          ref int[] kd1,
          ref int[] kd2,
          ref int[] kNum,
          ref int[] kLoc,
          ref int[] nBord,
          StatusBarPanel panel1)
        {
            int[] ni = new int[100];
            double[] dirAngle = new double[100];
            int i1 = 0;
            kPoly = 0;
            double num1 = 3.1415926;
            int num2;
            int num3 = num2 = 0;
            int i2 = num2;
            int num4 = num2;
            int num5 = num2;
            double num6;
            double yc = num6 = 0.0;
            double xc = num6;
            double sArea = num6;
            int num7;
            int kp3 = num7 = 0;
            panel1.Text = "Wait...Polygonal Topology";
            Cursor.Current = Cursors.WaitCursor;
            if (tol < 0.003)
                tol = 0.003;
            int kArray = 999999;
            intArray(k1, ref kArray);
            intArray(k2, ref kArray);
            intArray(kp1, ref kArray);
            intArray(kp2, ref kArray);
            intArray(kp, ref kArray);
            intArray(ina, ref kArray);
            intArray(inb, ref kArray);
            intArray(kd1, ref kArray);
            intArray(kd2, ref kArray);
            intArray(kNum, ref kArray);
            intArray(kLoc, ref kArray);
            intArray(nBord, ref kArray);
            intArray(nSymbPol, ref kArray);
            stringArray(namePol, ref kArray);
            if (kLin > kArray)
            {
                int num8 = (int)MessageBox.Show("Индекс массива LinesToPoly");
            }
            else
            {
                int num9 = k2[kLin];
                kArray = 999999;
                doubleArray(x, ref kArray);
                doubleArray(y, ref kArray);
                doubleArray(xnd, ref kArray);
                doubleArray(ynd, ref kArray);
                doubleArray(xPol, ref kArray);
                doubleArray(yPol, ref kArray);
                doubleArray(zPol, ref kArray);
                doubleArray(aLegal, ref kArray);
                doubleArray(xp, ref kArray);
                doubleArray(yp, ref kArray);
                doubleArray(xa, ref kArray);
                doubleArray(ya, ref kArray);
                doubleArray(zm, ref kArray);
                doubleArray(xm, ref kArray);
                doubleArray(ym, ref kArray);
                doubleArray(xb, ref kArray);
                doubleArray(yb, ref kArray);
                if (num9 > kArray)
                {
                    int num10 = (int)MessageBox.Show("Индекс массива LinesToPoly");
                }
                else
                {
                    int i3 = 0;
                    int i4 = 0;
                    num5 = 0;
                    for (int i5 = 1; i5 <= kLin; ++i5)
                    {
                        int i6 = k1[i5];
                        int i7 = k2[i5];
                        if (kNum[i5] > 0)
                        {
                            int i8 = i3 + 1;
                            xa[i8] = x[i6];
                            ya[i8] = y[i6];
                            i3 = i8 + 1;
                            xa[i3] = x[i7];
                            ya[i3] = y[i7];
                        }
                        else
                        {
                            int i9 = i4 + 1;
                            xm[i9] = x[i6];
                            ym[i9] = y[i6];
                            i4 = i9 + 1;
                            xm[i4] = x[i7];
                            ym[i4] = y[i7];
                        }
                    }
                    if (i3 == 0 || i4 == 0)
                    {
                        for (int i10 = 1; i10 <= kLin; ++i10)
                            kNum[i10] = 0;
                    }
                    if (i3 > 0 && i4 > 0)
                    {
                        kp3 = 0;
                        for (int i11 = 1; i11 <= i3; ++i11)
                        {
                            for (int i12 = 1; i12 <= i4; ++i12)
                            {
                                double num11 = xa[i11] - xm[i12];
                                double num12 = ya[i11] - ym[i12];
                                if (Math.Sqrt(num11 * num11 + num12 * num12) < tol)
                                    ++kp3;
                            }
                        }
                        if (kp3 < 2)
                        {
                            for (int i13 = 1; i13 <= kLin; ++i13)
                                kNum[i13] = 0;
                        }
                    }
                    if (i3 > 0 && i4 == 0)
                    {
                        LineСлияние(tol, kLin, ref k1, ref k2, ref x, ref y, out kp3, ref xp, ref yp, ref ina);
                        PolyLabel1(kp3, ref xp, ref yp, ref xm, ref ym, ref zm, out xc, out yc);
                        PolyArea1(kp3, xp, yp, out sArea);
                        ++kPoly;
                        namePol[kPoly] = string.Format("{0}", (object)kPoly);
                        xPol[kPoly] = xc;
                        yPol[kPoly] = yc;
                        zPol[kPoly] = sArea;
                        aLegal[kPoly] = sArea;
                        nSymbPol[kPoly] = 0;
                        kp[kPoly] = kp3;
                        kp1[1] = 1;
                        kp2[1] = kp3;
                    }
                    else
                    {
                        for (int i14 = 1; i14 <= kLin; ++i14)
                        {
                            if (kNum[i14] > 0)
                            {
                                ++i2;
                                nBord[i2] = i14;
                            }
                        }
                        for (int i15 = 1; i15 <= kLin; ++i15)
                        {
                            int num13 = k1[i15];
                            int num14 = k2[i15];
                            int k = 0;
                            for (int i16 = num13; i16 <= num14; ++i16)
                            {
                                ++k;
                                xa[k] = x[i16];
                                ya[k] = y[i16];
                            }
                            double num15 = xa[1] - xa[k];
                            double num16 = ya[1] - ya[k];
                            if (Math.Sqrt(num15 * num15 + num16 * num16) <= tol)
                            {
                                int num17 = 0;
                                PolyLabel1(k, ref xa, ref ya, ref xm, ref ym, ref zm, out xc, out yc);
                                PolyArea1(k, xa, ya, out sArea);
                                if (kPoly > 0)
                                {
                                    for (int i17 = 1; i17 <= kPoly; ++i17)
                                    {
                                        double num18 = xPol[i17] - xc;
                                        double num19 = yPol[i17] - yc;
                                        double num20 = Math.Sqrt(num18 * num18 + num19 * num19);
                                        double num21 = Math.Abs(zPol[i17] - sArea);
                                        if (num20 < 0.2 && num21 < 0.2)
                                        {
                                            ++num17;
                                            break;
                                        }
                                    }
                                }
                                if (num17 == 0)
                                {
                                    ++kPoly;
                                    namePol[kPoly] = string.Format("{0}", (object)kPoly);
                                    xPol[kPoly] = xc;
                                    yPol[kPoly] = yc;
                                    zPol[kPoly] = sArea;
                                    aLegal[kPoly] = sArea;
                                    nSymbPol[kPoly] = 0;
                                    kp[kPoly] = k;
                                    for (int i18 = 1; i18 <= k; ++i18)
                                    {
                                        ++i1;
                                        xp[i1] = xa[i18];
                                        yp[i1] = ya[i18];
                                    }
                                    panel1.Text = "Подождите..Полигон =" + string.Format("{0}", (object)kPoly);
                                }
                            }
                        }
                        if (knd > 0)
                        {
                            Form form = new Form();
                            for (int i19 = 1; i19 <= knd; ++i19)
                            {
                                int i20 = 0;
                                int i21 = 0;
                                num3 = 0;
                                for (int i22 = 1; i22 <= kLin; ++i22)
                                {
                                    int num22 = 0;
                                    if (i2 > 0)
                                    {
                                        for (int i23 = 1; i23 <= i2; ++i23)
                                        {
                                            if (nBord[i23] == i22)
                                            {
                                                ++num22;
                                                break;
                                            }
                                        }
                                    }
                                    if (num22 <= 0)
                                    {
                                        int i24 = k1[i22];
                                        int i25 = k2[i22];
                                        double num23 = xnd[i19] - x[i24];
                                        double num24 = ynd[i19] - y[i24];
                                        if (Math.Sqrt(num23 * num23 + num24 * num24) < tol)
                                        {
                                            for (int i26 = i24; i26 <= i25; ++i26)
                                            {
                                                ++i21;
                                                xb[i21] = x[i26];
                                                yb[i21] = y[i26];
                                            }
                                            ++i20;
                                            ina[i20] = i25 - i24 + 1;
                                            inb[i20] = i22;
                                        }
                                        else
                                        {
                                            double num25 = xnd[i19] - x[i25];
                                            double num26 = ynd[i19] - y[i25];
                                            if (Math.Sqrt(num25 * num25 + num26 * num26) < tol)
                                            {
                                                int i27 = i25 + 1;
                                                for (int i28 = i24; i28 <= i25; ++i28)
                                                {
                                                    --i27;
                                                    ++i21;
                                                    xb[i21] = x[i27];
                                                    yb[i21] = y[i27];
                                                }
                                                ++i20;
                                                ina[i20] = i25 - i24 + 1;
                                                inb[i20] = i22;
                                            }
                                        }
                                    }
                                }
                                if (i20 != 0)
                                {
                                    kd1[1] = 1;
                                    kd2[1] = ina[1];
                                    for (int i29 = 2; i29 <= i20; ++i29)
                                    {
                                        kd1[i29] = kd2[i29 - 1] + 1;
                                        kd2[i29] = kd2[i29 - 1] + ina[i29];
                                    }
                                    for (int i30 = 1; i30 <= i20; ++i30)
                                    {
                                        for (int ik = 1; ik <= 2; ++ik)
                                        {
                                            int num27 = 0;
                                            int k = 0;
                                            int num28 = kd1[i30];
                                            int num29 = kd2[i30];
                                            int num30 = inb[i30];
                                            for (int i31 = num28; i31 <= num29; ++i31)
                                            {
                                                ++k;
                                                xa[k] = xb[i31];
                                                ya[k] = yb[i31];
                                            }
                                            int i32 = num27 + 1;
                                            kLoc[i32] = num30;
                                            for (int i33 = 1; i33 <= kLin; ++i33)
                                            {
                                                double x1 = xa[k - 1] - xa[k];
                                                double dirLine = Math.Atan2(ya[k - 1] - ya[k], x1);
                                                if (dirLine < 0.0)
                                                    dirLine += 2.0 * num1;
                                                int kDir = -1;
                                                for (int i34 = 1; i34 <= kLin; ++i34)
                                                {
                                                    if (i34 != num30)
                                                    {
                                                        int num31 = 0;
                                                        for (int i35 = 1; i35 <= i32; ++i35)
                                                        {
                                                            if (kLoc[i35] == i34)
                                                            {
                                                                ++num31;
                                                                break;
                                                            }
                                                        }
                                                        if (num31 <= 0)
                                                        {
                                                            int i36 = k1[i34];
                                                            int i37 = k2[i34];
                                                            double num32 = xa[k] - x[i36];
                                                            double num33 = ya[k] - y[i36];
                                                            if (Math.Sqrt(num32 * num32 + num33 * num33) < tol)
                                                            {
                                                                ++kDir;
                                                                double x2 = x[i36 + 1] - x[i36];
                                                                double y1 = y[i36 + 1] - y[i36];
                                                                dirAngle[kDir] = Math.Atan2(y1, x2);
                                                                if (dirAngle[kDir] < 0.0)
                                                                    dirAngle[kDir] = dirAngle[kDir] + 2.0 * num1;
                                                                ni[kDir] = i34;
                                                            }
                                                            else
                                                            {
                                                                double num34 = xa[k] - x[i37];
                                                                double num35 = ya[k] - y[i37];
                                                                if (Math.Sqrt(num34 * num34 + num35 * num35) < tol)
                                                                {
                                                                    ++kDir;
                                                                    double x3 = x[i37 - 1] - x[i37];
                                                                    double y2 = y[i37 - 1] - y[i37];
                                                                    dirAngle[kDir] = Math.Atan2(y2, x3);
                                                                    if (dirAngle[kDir] < 0.0)
                                                                        dirAngle[kDir] = dirAngle[kDir] + 2.0 * num1;
                                                                    ni[kDir] = i34;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                if (kDir >= 0)
                                                {
                                                    int numLine = 0;
                                                    if (kDir > 0)
                                                        NearLine(kDir, dirAngle, ni, dirLine, out numLine, ik);
                                                    if (kDir == 0)
                                                        numLine = ni[0];
                                                    int i38 = k1[numLine];
                                                    int i39 = k2[numLine];
                                                    int num36 = 0;
                                                    double num37 = xa[k] - x[i38];
                                                    double num38 = ya[k] - y[i38];
                                                    if (Math.Sqrt(num37 * num37 + num38 * num38) < tol)
                                                    {
                                                        ++num36;
                                                        num30 = numLine;
                                                        for (int i40 = i38 + 1; i40 <= i39; ++i40)
                                                        {
                                                            ++k;
                                                            xa[k] = x[i40];
                                                            ya[k] = y[i40];
                                                        }
                                                        ++i32;
                                                        kLoc[i32] = numLine;
                                                    }
                                                    if (num36 == 0)
                                                    {
                                                        double num39 = xa[k] - x[i39];
                                                        double num40 = ya[k] - y[i39];
                                                        if (Math.Sqrt(num39 * num39 + num40 * num40) < tol)
                                                        {
                                                            num30 = numLine;
                                                            int i41 = i39;
                                                            for (int i42 = i38; i42 < i39; ++i42)
                                                            {
                                                                --i41;
                                                                ++k;
                                                                xa[k] = x[i41];
                                                                ya[k] = y[i41];
                                                            }
                                                            ++i32;
                                                            kLoc[i32] = numLine;
                                                        }
                                                    }
                                                    double num41 = xa[1] - xa[k];
                                                    double num42 = ya[1] - ya[k];
                                                    if (Math.Sqrt(num41 * num41 + num42 * num42) <= tol)
                                                    {
                                                        int num43 = 0;
                                                        PolyLabel1(k, ref xa, ref ya, ref xm, ref ym, ref zm, out xc, out yc);
                                                        PolyArea1(k, xa, ya, out sArea);
                                                        if (kPoly > 0)
                                                        {
                                                            for (int i43 = 1; i43 <= kPoly; ++i43)
                                                            {
                                                                double num44 = xPol[i43] - xc;
                                                                double num45 = yPol[i43] - yc;
                                                                double num46 = Math.Sqrt(num44 * num44 + num45 * num45);
                                                                double num47 = Math.Abs(zPol[i43] - sArea);
                                                                if (num46 < 0.2 && num47 < 0.2)
                                                                {
                                                                    ++num43;
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        if (num43 == 0)
                                                        {
                                                            ++kPoly;
                                                            namePol[kPoly] = string.Format("{0}", (object)kPoly);
                                                            xPol[kPoly] = xc;
                                                            yPol[kPoly] = yc;
                                                            zPol[kPoly] = sArea;
                                                            aLegal[kPoly] = sArea;
                                                            nSymbPol[kPoly] = 0;
                                                            kp[kPoly] = k;
                                                            for (int i44 = 1; i44 <= k; ++i44)
                                                            {
                                                                ++i1;
                                                                xp[i1] = xa[i44];
                                                                yp[i1] = ya[i44];
                                                            }
                                                            panel1.Text = "Подождите..Полигон =" + string.Format("{0}", (object)kPoly);
                                                        }
                                                        if (i32 > 0)
                                                        {
                                                            for (int i45 = 1; i45 <= kLin; ++i45)
                                                            {
                                                                for (int i46 = 1; i46 <= i32; ++i46)
                                                                {
                                                                    if (kLoc[i46] == i45)
                                                                    {
                                                                        kNum[i45] = kNum[i45] + 1;
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            break;
                                                        }
                                                        break;
                                                    }
                                                }
                                                else
                                                    break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        int i47 = 0;
                        for (int i48 = 1; i48 <= kLin; ++i48)
                        {
                            if (kNum[i48] <= 0)
                            {
                                ++i47;
                                nBord[i47] = i48;
                            }
                        }
                        if (i47 == 0)
                        {
                            kp1[1] = 1;
                            kp2[1] = kp[1];
                            if (kPoly <= 1)
                                return;
                            for (int i49 = 2; i49 <= kPoly; ++i49)
                            {
                                kp1[i49] = kp2[i49 - 1] + 1;
                                kp2[i49] = kp2[i49 - 1] + kp[i49];
                            }
                        }
                        else
                        {
                            num4 = 0;
                            int i50 = 0;
                            Form form = new Form();
                            for (int i51 = 1; i51 <= kLin; ++i51)
                            {
                                int i52 = 0;
                                int num48 = 0;
                                if (i47 > 0)
                                {
                                    for (int i53 = 1; i53 <= i47; ++i53)
                                    {
                                        if (nBord[i53] == i51)
                                        {
                                            ++num48;
                                            break;
                                        }
                                    }
                                }
                                if (num48 != 0)
                                {
                                    int num49 = 0;
                                    if (i50 > 0)
                                    {
                                        for (int i54 = 1; i54 <= i50; ++i54)
                                        {
                                            if (kLoc[i54] == i51)
                                            {
                                                ++num49;
                                                break;
                                            }
                                        }
                                    }
                                    if (num49 <= 0)
                                    {
                                        int num50 = k1[i51];
                                        int num51 = k2[i51];
                                        for (int i55 = num50; i55 <= num51; ++i55)
                                        {
                                            ++i52;
                                            xb[i52] = x[i55];
                                            yb[i52] = y[i55];
                                        }
                                        ++i50;
                                        kLoc[i50] = i51;
                                        for (int i56 = 1; i56 <= 2; ++i56)
                                        {
                                            int k = 0;
                                            for (int i57 = 1; i57 <= i52; ++i57)
                                            {
                                                ++k;
                                                xa[k] = xb[i57];
                                                ya[k] = yb[i57];
                                            }
                                            for (int i58 = 1; i58 <= kLin; ++i58)
                                            {
                                                for (int i59 = 1; i59 <= kLin; ++i59)
                                                {
                                                    if (i51 != i59)
                                                    {
                                                        int num52 = 0;
                                                        if (i47 > 0)
                                                        {
                                                            for (int i60 = 1; i60 <= i47; ++i60)
                                                            {
                                                                if (nBord[i60] == i59)
                                                                {
                                                                    ++num52;
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        if (num52 != 0)
                                                        {
                                                            int num53 = 0;
                                                            for (int i61 = 1; i61 <= i50; ++i61)
                                                            {
                                                                if (kLoc[i61] == i59)
                                                                {
                                                                    ++num53;
                                                                    break;
                                                                }
                                                            }
                                                            if (num53 <= 0)
                                                            {
                                                                int i62 = k1[i59];
                                                                int i63 = k2[i59];
                                                                int num54 = 0;
                                                                double num55 = xa[k] - x[i62];
                                                                double num56 = ya[k] - y[i62];
                                                                if (Math.Sqrt(num55 * num55 + num56 * num56) < tol)
                                                                {
                                                                    ++num54;
                                                                    for (int i64 = i62 + 1; i64 <= i63; ++i64)
                                                                    {
                                                                        ++k;
                                                                        xa[k] = x[i64];
                                                                        ya[k] = y[i64];
                                                                    }
                                                                    ++i50;
                                                                    kLoc[i50] = i59;
                                                                }
                                                                if (num54 == 0)
                                                                {
                                                                    double num57 = xa[k] - x[i63];
                                                                    double num58 = ya[k] - y[i63];
                                                                    if (Math.Sqrt(num57 * num57 + num58 * num58) < tol)
                                                                    {
                                                                        int i65 = i63;
                                                                        for (int i66 = i62; i66 < i63; ++i66)
                                                                        {
                                                                            --i65;
                                                                            ++k;
                                                                            xa[k] = x[i65];
                                                                            ya[k] = y[i65];
                                                                        }
                                                                        ++i50;
                                                                        kLoc[i50] = i59;
                                                                    }
                                                                }
                                                                double num59 = xa[1] - xa[k];
                                                                double num60 = ya[1] - ya[k];
                                                                if (Math.Sqrt(num59 * num59 + num60 * num60) <= tol)
                                                                {
                                                                    int num61 = 0;
                                                                    PolyLabel1(k, ref xa, ref ya, ref xm, ref ym, ref zm, out xc, out yc);
                                                                    PolyArea1(k, xa, ya, out sArea);
                                                                    if (kPoly > 0)
                                                                    {
                                                                        for (int i67 = 1; i67 <= kPoly; ++i67)
                                                                        {
                                                                            double num62 = xPol[i67] - xc;
                                                                            double num63 = yPol[i67] - yc;
                                                                            double num64 = Math.Sqrt(num62 * num62 + num63 * num63);
                                                                            double num65 = Math.Abs(zPol[i67] - sArea);
                                                                            if (num64 < 0.2 && num65 < 0.2)
                                                                            {
                                                                                ++num61;
                                                                                break;
                                                                            }
                                                                        }
                                                                    }
                                                                    if (num61 == 0)
                                                                    {
                                                                        ++kPoly;
                                                                        namePol[kPoly] = string.Format("{0}", (object)kPoly);
                                                                        xPol[kPoly] = xc;
                                                                        yPol[kPoly] = yc;
                                                                        zPol[kPoly] = sArea;
                                                                        aLegal[kPoly] = sArea;
                                                                        nSymbPol[kPoly] = 0;
                                                                        kp[kPoly] = k;
                                                                        for (int i68 = 1; i68 <= k; ++i68)
                                                                        {
                                                                            ++i1;
                                                                            xp[i1] = xa[i68];
                                                                            yp[i1] = ya[i68];
                                                                        }
                                                                        panel1.Text = "Подождите..Полигон =" + string.Format("{0}", (object)kPoly);
                                                                        break;
                                                                    }
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            form.Hide();
                            kp1[1] = 1;
                            kp2[1] = kp[1];
                            if (kPoly <= 1)
                                return;
                            for (int i69 = 2; i69 <= kPoly; ++i69)
                            {
                                kp1[i69] = kp2[i69 - 1] + 1;
                                kp2[i69] = kp2[i69 - 1] + kp[i69];
                            }
                        }
                    }
                }
            }
        }

        public static void ExteriorBox(
          int kLin,
          ref int[] k1,
          ref int[] k2,
          ref double[] x,
          ref double[] y,
          ref int[] kNum,
          out int kOut,
          ref double[] xOut,
          ref double[] yOut,
          out double sArea,
          ref int[] kSide)
        {
            sArea = 0.0;
            kOut = 0;
            int num1;
            int num2 = num1 = 0;
            int kArray1 = 999999;
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            intArray(kNum, ref kArray1);
            intArray(kSide, ref kArray1);
            if (kLin > kArray1)
            {
                int num3 = (int)MessageBox.Show("Индекс массива ExteriorBox");
            }
            else
            {
                int num4 = k2[kLin];
                int kArray2 = 999999;
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                doubleArray(xOut, ref kArray2);
                doubleArray(yOut, ref kArray2);
                if (num4 > kArray2)
                {
                    int num5 = (int)MessageBox.Show("Индекс массива ExteriorBox");
                }
                else
                {
                    double num6 = 9999999.9;
                    double num7 = 9999999.9;
                    double num8 = -9999999.9;
                    double num9 = -9999999.9;
                    for (int i1 = 1; i1 <= kLin; ++i1)
                    {
                        kNum[i1] = 0;
                        kSide[i1] = 0;
                        int num10 = k1[i1];
                        int num11 = k2[i1];
                        for (int i2 = num10; i2 <= num11; ++i2)
                        {
                            if (x[i2] < num6)
                                num6 = x[i2];
                            if (x[i2] > num8)
                                num8 = x[i2];
                            if (y[i2] < num7)
                                num7 = y[i2];
                            if (y[i2] > num9)
                                num9 = y[i2];
                        }
                    }
                    xOut[1] = num6;
                    yOut[1] = num7;
                    xOut[2] = num6;
                    yOut[2] = num9;
                    xOut[3] = num8;
                    yOut[3] = num9;
                    xOut[4] = num8;
                    yOut[4] = num7;
                    xOut[5] = num6;
                    yOut[5] = num7;
                    kOut = 5;
                }
            }
        }

        public static void BoundLine(
          int kSide,
          int kLine,
          ref double[] radLine,
          ref int[] k1,
          ref int[] k2,
          ref double[] x,
          ref double[] y,
          out int kBnd,
          ref double[] radBnd,
          ref int[] kb1,
          ref int[] kb2,
          ref double[] xBnd,
          ref double[] yBnd,
          ref int[] kb,
          double tol)
        {
            double num1;
            double num2 = num1 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            int num5;
            int num6 = num5 = 0;
            int num7;
            int i1 = num7 = 0;
            kBnd = 0;
            if (tol < 0.003)
                tol = 0.003;
            int kArray1 = 999999;
            doubleArray(radLine, ref kArray1);
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            if (kLine > kArray1)
            {
                int num8 = (int)MessageBox.Show("Индекс массива BoundLine");
            }
            else
            {
                int num9 = k2[kLine];
                int kArray2 = 999999;
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                doubleArray(xBnd, ref kArray2);
                doubleArray(yBnd, ref kArray2);
                if (num9 > kArray2)
                {
                    int num10 = (int)MessageBox.Show("Индекс массива BoundLine");
                }
                else
                {
                    kArray2 = 999999;
                    doubleArray(radBnd, ref kArray2);
                    intArray(kb, ref kArray2);
                    intArray(kb1, ref kArray2);
                    intArray(kb2, ref kArray2);
                    for (int i2 = 1; i2 <= kLine; ++i2)
                    {
                        int i3 = k1[i2];
                        int i4 = k2[i2];
                        double num11 = 0.5 * (x[i3] + x[i4]);
                        double num12 = 0.5 * (y[i3] + y[i4]);
                        int num13 = i4 - i3 + 1;
                        int num14 = 0;
                        for (int i5 = 1; i5 <= kLine; ++i5)
                        {
                            if (i2 != i5)
                            {
                                int i6 = k1[i5];
                                int i7 = k2[i5];
                                double num15 = 0.5 * (x[i6] + x[i7]);
                                double num16 = 0.5 * (y[i6] + y[i7]);
                                int num17 = i7 - i6 + 1;
                                if (num13 == num17 && radLine[i2] == radLine[i5])
                                {
                                    double num18 = num15 - num11;
                                    double num19 = num16 - num12;
                                    if (Math.Sqrt(num18 * num18 + num19 * num19) < tol)
                                    {
                                        ++num14;
                                        break;
                                    }
                                }
                            }
                        }
                        if (i2 <= kSide && num14 == 0)
                        {
                            int num20 = 0;
                            for (int i8 = i3; i8 <= i4; ++i8)
                            {
                                ++num20;
                                ++i1;
                                xBnd[i1] = x[i8];
                                yBnd[i1] = y[i8];
                            }
                            ++kBnd;
                            if (kBnd > kArray2)
                            {
                                int num21 = (int)MessageBox.Show("Индекс массива BoundLine");
                                kBnd = 0;
                                return;
                            }
                            radBnd[kBnd] = radLine[i2];
                            kb[kBnd] = num20;
                        }
                    }
                    if (kBnd <= 0)
                        return;
                    kb1[1] = 1;
                    kb2[1] = kb[1];
                    if (kBnd <= 1)
                        return;
                    for (int i9 = 2; i9 <= kBnd; ++i9)
                    {
                        kb1[i9] = kb2[i9 - 1] + 1;
                        kb2[i9] = kb2[i9 - 1] + kb[i9];
                    }
                }
            }
        }

        public static void BoundDelete(
          ref int kLine,
          ref double[] radLine,
          ref int[] k1,
          ref int[] k2,
          ref double[] x,
          ref double[] y,
          int kBnd,
          ref double[] radBnd,
          ref int[] kb1,
          ref int[] kb2,
          ref double[] xBnd,
          ref double[] yBnd,
          ref int[] kb,
          double tol)
        {
            int i1 = 0;
            double num1;
            double num2 = num1 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            int num5;
            int num6 = num5 = 0;
            int num7;
            int i2 = num7 = 0;
            if (tol < 0.003)
                tol = 0.003;
            int kArray1 = 999999;
            doubleArray(radLine, ref kArray1);
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            if (kLine > kArray1)
            {
                int num8 = (int)MessageBox.Show("Индекс массива BoundDelete");
            }
            else
            {
                int num9 = k2[kLine];
                int kArray2 = 999999;
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                if (num9 > kArray2)
                {
                    int num10 = (int)MessageBox.Show("Индекс массива BoundDelete");
                }
                else
                {
                    int kArray3 = 999999;
                    doubleArray(radBnd, ref kArray3);
                    intArray(kb, ref kArray3);
                    intArray(kb1, ref kArray3);
                    intArray(kb2, ref kArray3);
                    if (kBnd > kArray3)
                    {
                        int num11 = (int)MessageBox.Show("Индекс массива BoundDelete");
                    }
                    else
                    {
                        int num12 = kb2[kBnd];
                        kArray3 = 999999;
                        doubleArray(xBnd, ref kArray3);
                        doubleArray(yBnd, ref kArray3);
                        if (num12 > kArray3)
                        {
                            int num13 = (int)MessageBox.Show("Индекс массива BoundDelete");
                        }
                        else
                        {
                            num6 = 0;
                            for (int i3 = 1; i3 <= kLine; ++i3)
                            {
                                int i4 = k1[i3];
                                int i5 = k2[i3];
                                double num14 = 0.5 * (x[i4] + x[i5]);
                                double num15 = 0.5 * (y[i4] + y[i5]);
                                int num16 = i5 - i4 + 1;
                                int num17 = 0;
                                for (int i6 = 1; i6 <= kBnd; ++i6)
                                {
                                    int i7 = kb1[i6];
                                    int i8 = kb2[i6];
                                    double num18 = 0.5 * (xBnd[i7] + xBnd[i8]);
                                    double num19 = 0.5 * (yBnd[i7] + yBnd[i8]);
                                    int num20 = i8 - i7 + 1;
                                    if (num16 == num20 && radLine[i3] == radBnd[i6])
                                    {
                                        double num21 = num18 - num14;
                                        double num22 = num19 - num15;
                                        if (Math.Sqrt(num21 * num21 + num22 * num22) < tol)
                                        {
                                            ++num17;
                                            break;
                                        }
                                    }
                                }
                                if (num17 <= 0)
                                {
                                    int num23 = 0;
                                    for (int i9 = i4; i9 <= i5; ++i9)
                                    {
                                        ++num23;
                                        ++i2;
                                        x[i2] = x[i9];
                                        y[i2] = y[i9];
                                    }
                                    ++i1;
                                    radLine[i1] = radLine[i3];
                                    kb[i1] = num23;
                                }
                            }
                            if (i1 <= 0)
                                return;
                            k1[1] = 1;
                            k2[1] = kb[1];
                            if (i1 > 1)
                            {
                                for (int i10 = 2; i10 <= i1; ++i10)
                                {
                                    k1[i10] = k2[i10 - 1] + 1;
                                    k2[i10] = k2[i10 - 1] + kb[i10];
                                }
                            }
                            kLine = i1;
                        }
                    }
                }
            }
        }

        public static void SelectLine(
          double xx,
          double yy,
          int kPar,
          ref double[] xPar,
          ref double[] yPar,
          int kLine,
          ref int[] k1,
          ref int[] k2,
          ref double[] Rad,
          ref double[] x,
          ref double[] y,
          out double rd,
          out double xrd,
          out double yrd,
          out int kp,
          ref double[] xp,
          ref double[] yp,
          double tol,
          ref double[] xr,
          ref double[] yr,
          ref double[] dr)
        {
            int[] numArray = new int[100];
            double num1 = 3.1415926;
            kp = 0;
            int num2;
            int num3 = num2 = 0;
            int num4 = num2;
            int num5 = num2;
            double num6;
            double dist = num6 = 0.0;
            double num7 = num6;
            double num8 = num6;
            double num9;
            rd = num9 = 0.0;
            double num10;
            double num11 = num10 = 0.0;
            int i1;
            int ip1 = i1 = 0;
            double num12;
            double num13 = num12 = 0.0;
            double num14;
            double num15 = num14 = 0.0;
            xrd = yrd = 0.0;
            if (tol < 0.003)
                tol = 0.003;
            Cursor.Current = Cursors.WaitCursor;
            int kArray = 999999;
            doubleArray(xPar, ref kArray);
            doubleArray(yPar, ref kArray);
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            doubleArray(xp, ref kArray);
            doubleArray(yp, ref kArray);
            doubleArray(xr, ref kArray);
            doubleArray(yr, ref kArray);
            doubleArray(dr, ref kArray);
            if (kPar > kArray)
            {
                int num16 = (int)MessageBox.Show("Индекс массива SelectLine");
            }
            else
            {
                kArray = 999999;
                intArray(k1, ref kArray);
                intArray(k2, ref kArray);
                doubleArray(Rad, ref kArray);
                if (kLine > kArray)
                {
                    int num17 = (int)MessageBox.Show("Индекс массива SelectLine");
                }
                else
                {
                    double num18 = 9999999.9;
                    double num19 = 9999999.9;
                    for (int i2 = 1; i2 <= kLine; ++i2)
                    {
                        int num20 = k1[i2];
                        int num21 = k2[i2];
                        if (Rad[i2] <= 0.0)
                        {
                            for (int i3 = num20 + 1; i3 <= num21; ++i3)
                            {
                                DistPnt(xx, yy, x[i3 - 1], y[i3 - 1], x[i3], y[i3], out dist, out ip1, out num8, out num7);
                                if (ip1 > 0 && num18 > dist)
                                {
                                    num18 = dist;
                                    num5 = i2;
                                }
                            }
                        }
                        if (Rad[i2] > 0.0)
                        {
                            for (int i4 = num20; i4 <= num21; ++i4)
                            {
                                double num22 = x[i4] - xx;
                                double num23 = y[i4] - yy;
                                dist = Math.Sqrt(num22 * num22 + num23 * num23);
                                if (num19 > dist)
                                {
                                    num19 = dist;
                                    num4 = i2;
                                }
                            }
                        }
                    }
                    if (num18 < num19)
                        i1 = num5;
                    if (num19 < num18)
                        i1 = num4;
                    if (i1 <= 0)
                        return;
                    int i5 = i1;
                    int num24 = k1[i1];
                    int num25 = k2[i1];
                    rd = Rad[i1];
                    int i6 = -1;
                    for (int i7 = num24; i7 <= num25; ++i7)
                    {
                        ++i6;
                        xp[i6] = x[i7];
                        yp[i6] = y[i7];
                    }
                    kp = i6;
                    double num26 = 9999999.9;
                    double num27 = 9999999.9;
                    double num28 = -9999999.9;
                    double num29 = -9999999.9;
                    for (int i8 = 0; i8 <= kPar; ++i8)
                    {
                        if (xPar[i8] < num26)
                            num26 = xPar[i8];
                        if (xPar[i8] > num28)
                            num28 = xPar[i8];
                        if (yPar[i8] < num27)
                            num27 = yPar[i8];
                        if (yPar[i8] > num29)
                            num29 = yPar[i8];
                    }
                    double num30 = num28 - num26;
                    double num31 = num29 - num27;
                    double num32 = Math.Sqrt(num30 * num30 + num31 * num31);
                    if (rd == 0.0)
                    {
                        xx = 0.5 * (xp[0] + xp[kp]);
                        yy = 0.5 * (yp[0] + yp[kp]);
                        double x1 = xp[kp] - xp[0];
                        double num33 = Math.Atan2(yp[kp] - yp[0], x1);
                        if (num33 < 0.0)
                            num33 += 2.0 * num1;
                        double num34 = num33 + 0.5 * num1;
                        if (num34 >= 2.0 * num1)
                            num34 -= 2.0 * num1;
                        num8 = xx + 0.01 * Math.Cos(num34);
                        num7 = yy + 0.01 * Math.Sin(num34);
                        int ip2 = in_out(kPar, ref xPar, ref yPar, num8, num7);
                        if (ip2 == 0)
                        {
                            double num35 = num34 - num1;
                            if (num35 < 0.0)
                                num35 += 2.0 * num1;
                            num8 = xx + 0.01 * Math.Cos(num35);
                            num7 = yy + 0.01 * Math.Sin(num35);
                            ip2 = in_out(kPar, ref xPar, ref yPar, num8, num7);
                        }
                        double x1_1 = num8 - num32 * Math.Cos(num33);
                        double y1 = num7 - num32 * Math.Sin(num33);
                        double x2 = num8 + num32 * Math.Cos(num33);
                        double y2 = num7 + num32 * Math.Sin(num33);
                        int i9 = 0;
                        for (int i10 = 1; i10 <= kPar; ++i10)
                        {
                            ip2 = 1;
                            TwoLine(x1_1, y1, xPar[i10 - 1], yPar[i10 - 1], x2, y2, xPar[i10], yPar[i10], out xx, out yy, ref ip2);
                            if (xx != 0.0 || yy != 0.0)
                            {
                                ++i9;
                                xr[i9] = xx;
                                yr[i9] = yy;
                                double num36 = xx - x1_1;
                                double num37 = yy - y1;
                                dr[i9] = Math.Sqrt(num36 * num36 + num37 * num37);
                            }
                        }
                        if (i9 < 2)
                        {
                            kp = 1;
                            xp[0] = x1_1;
                            yp[0] = y1;
                            xp[1] = x2;
                            yp[1] = y2;
                        }
                        if (i9 > 1)
                        {
                            ip2 = i9 / 2;
                            if (i9 - 2 * ip2 > 0)
                                --i9;
                            for (int i11 = 1; i11 < i9; ++i11)
                            {
                                for (int i12 = i11 + 1; i12 <= i9; ++i12)
                                {
                                    if (dr[i11] > dr[i12])
                                    {
                                        xx = xr[i11];
                                        yy = yr[i11];
                                        dist = dr[i11];
                                        xr[i11] = xr[i12];
                                        yr[i11] = yr[i12];
                                        dr[i11] = dr[i12];
                                        xr[i12] = xx;
                                        yr[i12] = yy;
                                        dr[i12] = dist;
                                    }
                                }
                            }
                            for (int i13 = 2; i13 <= i9; ++i13)
                            {
                                DistPnt(num8, num7, xr[i13 - 1], yr[i13 - 1], xr[i13], yr[i13], out dist, out ip2, out xx, out yy);
                                if (ip2 > 0)
                                {
                                    kp = 1;
                                    xp[0] = xr[i13 - 1];
                                    yp[0] = yr[i13 - 1];
                                    xp[1] = xr[i13];
                                    yp[1] = yr[i13];
                                    break;
                                }
                            }
                        }
                        int i14 = 0;
                        for (int i15 = 1; i15 <= kLine; ++i15)
                        {
                            if (Rad[i15] <= 0.0)
                            {
                                int i16 = k1[i15];
                                int i17 = k2[i15];
                                num8 = 0.5 * (x[i16] + x[i17]);
                                num7 = 0.5 * (y[i16] + y[i17]);
                                DistPnt(num8, num7, xp[0], yp[0], xp[1], yp[1], out dist, out ip2, out xx, out yy);
                                if (ip2 > 0 && dist < 0.15)
                                {
                                    ++i14;
                                    numArray[i14] = i15;
                                }
                            }
                        }
                        if (i14 == 1)
                        {
                            int i18 = numArray[1];
                            int i19 = k1[i18];
                            int i20 = k2[i18];
                            kp = 1;
                            xp[0] = x[i19];
                            yp[0] = y[i19];
                            xp[1] = x[i20];
                            yp[1] = y[i20];
                        }
                        if (i14 > 1)
                        {
                            int num38 = k1[i5];
                            int num39 = k2[i5];
                            int i21 = -1;
                            for (int i22 = num38; i22 <= num39; ++i22)
                            {
                                ++i21;
                                xp[i21] = x[i22];
                                yp[i21] = y[i22];
                            }
                            kp = i21;
                            for (int i23 = 1; i23 <= i14; ++i23)
                            {
                                if (numArray[i23] == i5)
                                {
                                    numArray[i23] = -i5;
                                    break;
                                }
                            }
                            for (int i24 = 1; i24 <= i14; ++i24)
                            {
                                int num40 = 0;
                                for (int i25 = 1; i25 <= i14; ++i25)
                                {
                                    if (numArray[i25] >= 0)
                                    {
                                        int i26 = numArray[i25];
                                        int i27 = k1[i26];
                                        int i28 = k2[i26];
                                        double num41 = xp[0] - x[i27];
                                        double num42 = yp[0] - y[i27];
                                        if (Math.Sqrt(num41 * num41 + num42 * num42) < tol)
                                        {
                                            int i29 = -1;
                                            int i30 = kp + 1;
                                            for (int i31 = 0; i31 <= kp; ++i31)
                                            {
                                                --i30;
                                                ++i29;
                                                xr[i29] = xp[i30];
                                                yr[i29] = yp[i30];
                                            }
                                            for (int i32 = i27 + 1; i32 <= i28; ++i32)
                                            {
                                                ++i29;
                                                xr[i29] = x[i32];
                                                yr[i29] = y[i32];
                                            }
                                            kp = i29;
                                            for (int i33 = 0; i33 <= kp; ++i33)
                                            {
                                                xp[i33] = xr[i33];
                                                yp[i33] = yr[i33];
                                            }
                                            ++num40;
                                            numArray[i25] = -i25;
                                        }
                                        else
                                        {
                                            double num43 = xp[0] - x[i28];
                                            double num44 = yp[0] - y[i28];
                                            if (Math.Sqrt(num43 * num43 + num44 * num44) < tol)
                                            {
                                                int i34 = -1;
                                                for (int i35 = i27; i35 <= i28; ++i35)
                                                {
                                                    ++i34;
                                                    xr[i34] = x[i35];
                                                    yr[i34] = y[i35];
                                                }
                                                for (int i36 = 1; i36 <= kp; ++i36)
                                                {
                                                    ++i34;
                                                    xr[i34] = xp[i36];
                                                    yr[i34] = yp[i36];
                                                }
                                                kp = i34;
                                                for (int i37 = 0; i37 <= kp; ++i37)
                                                {
                                                    xp[i37] = xr[i37];
                                                    yp[i37] = yr[i37];
                                                }
                                                ++num40;
                                                numArray[i25] = -i25;
                                            }
                                            else
                                            {
                                                double num45 = xp[kp] - x[i27];
                                                double num46 = yp[kp] - y[i27];
                                                if (Math.Sqrt(num45 * num45 + num46 * num46) < tol)
                                                {
                                                    for (int i38 = i27 + 1; i38 <= i28; ++i38)
                                                    {
                                                        ++kp;
                                                        xp[kp] = x[i38];
                                                        yp[kp] = y[i38];
                                                    }
                                                    ++num40;
                                                    numArray[i25] = -i25;
                                                }
                                                else
                                                {
                                                    double num47 = xp[kp] - x[i28];
                                                    double num48 = yp[kp] - y[i28];
                                                    if (Math.Sqrt(num47 * num47 + num48 * num48) < tol)
                                                    {
                                                        int i39 = i28;
                                                        for (int i40 = i27; i40 <= i28; ++i40)
                                                        {
                                                            --i39;
                                                            ++kp;
                                                            xp[kp] = x[i39];
                                                            yp[kp] = y[i39];
                                                        }
                                                        ++num40;
                                                        numArray[i25] = -i25;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                if (num40 == 0)
                                    break;
                            }
                        }
                    }
                    if (rd <= 0.0)
                        return;
                    GetCentre(kp, ref xp, ref yp, rd, out num8, out num7);
                    xrd = num8;
                    yrd = num7;
                    int i41 = 1;
                    numArray[i41] = i5;
                    for (int i42 = 1; i42 <= kLine; ++i42)
                    {
                        int num49 = 0;
                        for (int i43 = 1; i43 <= kLine; ++i43)
                        {
                            int num50 = 0;
                            for (int i44 = 1; i44 <= i41; ++i44)
                            {
                                if (numArray[i44] == i43)
                                {
                                    ++num50;
                                    break;
                                }
                            }
                            if (num50 <= 0 && Math.Abs(Rad[i43] - rd) <= 0.015)
                            {
                                int i45 = k1[i43];
                                int i46 = k2[i43];
                                int k = -1;
                                for (int i47 = i45; i47 <= i46; ++i47)
                                {
                                    ++k;
                                    xr[k] = x[i47];
                                    yr[k] = y[i47];
                                }
                                GetCentre(k, ref xr, ref yr, Rad[i43], out num8, out num7);
                                double num51 = xrd - num8;
                                double num52 = yrd - num7;
                                if (Math.Sqrt(num51 * num51 + num52 * num52) <= 0.1)
                                {
                                    double num53 = xp[0] - x[i45];
                                    double num54 = yp[0] - y[i45];
                                    if (Math.Sqrt(num53 * num53 + num54 * num54) < tol)
                                    {
                                        int i48 = -1;
                                        int i49 = kp + 1;
                                        for (int i50 = 0; i50 <= kp; ++i50)
                                        {
                                            --i49;
                                            ++i48;
                                            xr[i48] = xp[i49];
                                            yr[i48] = yp[i49];
                                        }
                                        for (int i51 = i45 + 1; i51 <= i46; ++i51)
                                        {
                                            ++i48;
                                            xr[i48] = x[i51];
                                            yr[i48] = y[i51];
                                        }
                                        kp = i48;
                                        for (int i52 = 0; i52 <= kp; ++i52)
                                        {
                                            xp[i52] = xr[i52];
                                            yp[i52] = yr[i52];
                                        }
                                        ++num49;
                                        ++i41;
                                        numArray[i41] = i43;
                                    }
                                    else
                                    {
                                        double num55 = xp[0] - x[i46];
                                        double num56 = yp[0] - y[i46];
                                        if (Math.Sqrt(num55 * num55 + num56 * num56) < tol)
                                        {
                                            int i53 = -1;
                                            for (int i54 = i45; i54 <= i46; ++i54)
                                            {
                                                ++i53;
                                                xr[i53] = x[i54];
                                                yr[i53] = y[i54];
                                            }
                                            for (int i55 = 1; i55 <= kp; ++i55)
                                            {
                                                ++i53;
                                                xr[i53] = xp[i55];
                                                yr[i53] = yp[i55];
                                            }
                                            kp = i53;
                                            for (int i56 = 0; i56 <= kp; ++i56)
                                            {
                                                xp[i56] = xr[i56];
                                                yp[i56] = yr[i56];
                                            }
                                            ++num49;
                                            ++i41;
                                            numArray[i41] = i43;
                                        }
                                        else
                                        {
                                            double num57 = xp[kp] - x[i45];
                                            double num58 = yp[kp] - y[i45];
                                            if (Math.Sqrt(num57 * num57 + num58 * num58) < tol)
                                            {
                                                for (int i57 = i45 + 1; i57 <= i46; ++i57)
                                                {
                                                    ++kp;
                                                    xp[kp] = x[i57];
                                                    yp[kp] = y[i57];
                                                }
                                                ++num49;
                                                ++i41;
                                                numArray[i41] = i43;
                                            }
                                            else
                                            {
                                                double num59 = xp[kp] - x[i46];
                                                double num60 = yp[kp] - y[i46];
                                                if (Math.Sqrt(num59 * num59 + num60 * num60) < tol)
                                                {
                                                    int i58 = i46;
                                                    for (int i59 = i45; i59 <= i46; ++i59)
                                                    {
                                                        --i58;
                                                        ++kp;
                                                        xp[kp] = x[i58];
                                                        yp[kp] = y[i58];
                                                    }
                                                    ++num49;
                                                    ++i41;
                                                    numArray[i41] = i43;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (num49 == 0)
                            break;
                    }
                }
            }
        }

        public static void ParcNewName(
          int maxNum,
          int kSource,
          string[] nameSource,
          double[] xSource,
          double[] ySource,
          double[] aCalcSour,
          double[] aLegsour,
          int[] ksr1,
          int[] ksr2,
          double[] xSor,
          double[] ySor,
          int kPol,
          string[] namePol,
          double[] xLab,
          double[] yLab,
          double[] arCalc,
          double[] arLeg,
          out int kNew,
          string[] nameNew,
          double[] xLabNew,
          double[] yLabNew,
          double[] aCalcNew,
          double[] aLegNew,
          double[] x,
          double[] y)
        {
            int num1 = maxNum;
            int num2 = 0;
            kNew = 0;
            int kArray1 = 999999;
            stringArray(nameSource, ref kArray1);
            stringArray(namePol, ref kArray1);
            stringArray(nameNew, ref kArray1);
            intArray(ksr1, ref kArray1);
            intArray(ksr2, ref kArray1);
            doubleArray(xSource, ref kArray1);
            doubleArray(ySource, ref kArray1);
            doubleArray(aCalcSour, ref kArray1);
            doubleArray(aLegsour, ref kArray1);
            doubleArray(xLab, ref kArray1);
            doubleArray(yLab, ref kArray1);
            doubleArray(arCalc, ref kArray1);
            doubleArray(arLeg, ref kArray1);
            doubleArray(xLabNew, ref kArray1);
            doubleArray(yLabNew, ref kArray1);
            doubleArray(aCalcNew, ref kArray1);
            doubleArray(aLegNew, ref kArray1);
            if (kSource > kArray1)
            {
                int num3 = (int)MessageBox.Show("Индекс массива ParcNewName");
            }
            else
            {
                int kArray2 = 999999;
                int num4 = ksr2[kSource];
                doubleArray(xSor, ref kArray2);
                doubleArray(ySor, ref kArray2);
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                if (num4 > kArray2)
                {
                    int num5 = (int)MessageBox.Show("Индекс массива ParcNewName");
                }
                else
                {
                    num2 = 0;
                    for (int i1 = 1; i1 <= kPol; ++i1)
                    {
                        int num6 = 0;
                        for (int i2 = 1; i2 <= kSource; ++i2)
                        {
                            if (Math.Abs(arCalc[i1] - aCalcSour[i2]) <= 0.1)
                            {
                                int num7 = ksr1[i2];
                                int num8 = ksr2[i2];
                                int k = -1;
                                for (int i3 = num7; i3 <= num8; ++i3)
                                {
                                    ++k;
                                    x[k] = xSor[i3];
                                    y[k] = ySor[i3];
                                }
                                num6 = in_out(k, ref x, ref y, xLab[i1], yLab[i1]);
                                if (num6 > 0)
                                {
                                    namePol[i1] = nameSource[i2];
                                    break;
                                }
                            }
                        }
                        if (num6 == 0)
                        {
                            ++kNew;
                            ++num1;
                            nameNew[kNew] = string.Format("{0}", (object)num1);
                            xLabNew[kNew] = xLab[i1];
                            yLabNew[kNew] = yLab[i1];
                            aCalcNew[kNew] = arCalc[i1];
                            aLegNew[kNew] = arLeg[i1];
                            namePol[i1] = string.Format("{0}", (object)num1);
                        }
                    }
                }
            }
        }

        public static void SelectSource(
          int kPol,
          double[] xLab,
          double[] yLab,
          double[] arCalc,
          double[] arLeg,
          double xCent,
          double yCent,
          double aCalc,
          double aLeg,
          out int iSource)
        {
            int i1 = 0;
            iSource = 0;
            int kArray = 999999;
            doubleArray(xLab, ref kArray);
            doubleArray(yLab, ref kArray);
            doubleArray(arCalc, ref kArray);
            doubleArray(arLeg, ref kArray);
            if (kPol > kArray)
            {
                int num1 = (int)MessageBox.Show("Индекс массива SelectSource");
            }
            else
            {
                double num2 = 9999999.9;
                for (int i2 = 1; i2 <= kPol; ++i2)
                {
                    double num3 = xLab[i2] - xCent;
                    double num4 = yLab[i2] - yCent;
                    double num5 = Math.Sqrt(num3 * num3 + num4 * num4);
                    if (num5 < num2)
                    {
                        num2 = num5;
                        i1 = i2;
                    }
                }
                double num6 = Math.Abs(arCalc[i1] - aCalc);
                double num7 = Math.Abs(arLeg[i1] - aLeg);
                if (num6 >= 0.1 || num7 >= 0.1)
                    return;
                iSource = i1;
            }
        }

        public static void ActionCompare(
          int kPoly1,
          ref double[] xLab1,
          ref double[] yLab1,
          ref double[] arCalc1,
          ref double[] arLeg1,
          ref int[] kPol1,
          ref int[] kPol2,
          ref double[] xPol1,
          ref double[] yPol1,
          int kPoly2,
          ref double[] xLab2,
          ref double[] yLab2,
          ref double[] arCalc2,
          ref double[] arLeg2,
          ref int[] kPop1,
          ref int[] kPop2,
          ref double[] xPol2,
          ref double[] yPol2,
          ref double[] xa,
          ref double[] ya)
        {
            int num1;
            int num2 = num1 = 0;
            int kArray1 = 999999;
            doubleArray(xLab1, ref kArray1);
            doubleArray(yLab1, ref kArray1);
            doubleArray(arCalc1, ref kArray1);
            doubleArray(arLeg1, ref kArray1);
            intArray(kPol1, ref kArray1);
            intArray(kPol2, ref kArray1);
            if (kPoly1 > kArray1)
            {
                int num3 = (int)MessageBox.Show("Индекс массива ActionCompare");
            }
            else
            {
                int num4 = kPol2[kPoly1];
                int kArray2 = 999999;
                doubleArray(xPol1, ref kArray2);
                doubleArray(yPol1, ref kArray2);
                if (num4 > kArray2)
                {
                    int num5 = (int)MessageBox.Show("Индекс массива ActionCompare");
                }
                else
                {
                    kArray2 = 999999;
                    doubleArray(xLab2, ref kArray2);
                    doubleArray(yLab2, ref kArray2);
                    doubleArray(arCalc2, ref kArray2);
                    doubleArray(arLeg2, ref kArray2);
                    intArray(kPop1, ref kArray2);
                    intArray(kPop2, ref kArray2);
                    if (kPoly2 > kArray2)
                    {
                        int num6 = (int)MessageBox.Show("Индекс массива ActionCompare");
                    }
                    else
                    {
                        int num7 = kPop2[kPoly1];
                        kArray2 = 999999;
                        doubleArray(xPol2, ref kArray2);
                        doubleArray(yPol2, ref kArray2);
                        if (num7 > kArray2)
                        {
                            int num8 = (int)MessageBox.Show("Индекс массива ActionCompare");
                        }
                        else
                        {
                            for (int i1 = 1; i1 <= kPoly1; ++i1)
                            {
                                int num9 = kPol1[i1];
                                int num10 = kPol2[i1];
                                int k = -1;
                                for (int i2 = num9; i2 <= num10; ++i2)
                                {
                                    ++k;
                                    xa[k] = xPol1[i2];
                                    ya[k] = yPol1[i2];
                                }
                                for (int i3 = 1; i3 <= kPoly2; ++i3)
                                {
                                    if (in_out(k, ref xa, ref ya, xLab2[i3], yLab2[i3]) > 0)
                                        arLeg2[i3] = Math.Abs(arCalc1[i1] - arCalc2[i3]) >= 0.02 ? arCalc2[i3] * arLeg1[i1] / arCalc1[i1] : arLeg1[i1];
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void CommonLine(
          int kLine,
          ref double[] radLine,
          ref int[] k1,
          ref int[] k2,
          ref double[] x,
          ref double[] y,
          out int kCom,
          ref double[] radCom,
          ref int[] kc1,
          ref int[] kc2,
          ref double[] xCom,
          ref double[] yCom,
          ref int[] kc,
          double tol)
        {
            double num1;
            double num2 = num1 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            int num5;
            int num6 = num5 = 0;
            int num7;
            int i1 = num7 = 0;
            kCom = 0;
            if (tol < 0.003)
                tol = 0.003;
            int kArray1 = 999999;
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            intArray(kc1, ref kArray1);
            intArray(kc2, ref kArray1);
            intArray(kc, ref kArray1);
            doubleArray(radLine, ref kArray1);
            doubleArray(radCom, ref kArray1);
            if (kLine > kArray1)
            {
                int num8 = (int)MessageBox.Show("Индекс массива CommonLine");
            }
            else
            {
                int num9 = k2[kLine];
                int kArray2 = 999999;
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                doubleArray(xCom, ref kArray2);
                doubleArray(yCom, ref kArray2);
                if (num9 > kArray2)
                {
                    int num10 = (int)MessageBox.Show("Индекс массива CommonLine");
                }
                else
                {
                    num6 = 0;
                    for (int i2 = 1; i2 < kLine; ++i2)
                    {
                        int i3 = k1[i2];
                        int i4 = k2[i2];
                        double num11 = 0.5 * (x[i3] + x[i4]);
                        double num12 = 0.5 * (y[i3] + y[i4]);
                        int num13 = i4 - i3 + 1;
                        for (int i5 = i2 + 1; i5 <= kLine; ++i5)
                        {
                            int i6 = k1[i5];
                            int i7 = k2[i5];
                            double num14 = 0.5 * (x[i6] + x[i7]);
                            double num15 = 0.5 * (y[i6] + y[i7]);
                            int num16 = i7 - i6 + 1;
                            if (num13 == num16 && radLine[i2] == radLine[i5])
                            {
                                double num17 = num14 - num11;
                                double num18 = num15 - num12;
                                if (Math.Sqrt(num17 * num17 + num18 * num18) < tol)
                                {
                                    int num19 = 0;
                                    for (int i8 = i3; i8 <= i4; ++i8)
                                    {
                                        ++num19;
                                        ++i1;
                                        xCom[i1] = x[i8];
                                        yCom[i1] = y[i8];
                                    }
                                    ++kCom;
                                    radCom[kCom] = radLine[i2];
                                    kc[kCom] = num19;
                                    break;
                                }
                            }
                        }
                    }
                    if (kCom <= 0)
                        return;
                    kc1[1] = 1;
                    kc2[1] = kc[1];
                    if (kCom <= 1)
                        return;
                    for (int i9 = 2; i9 <= kCom; ++i9)
                    {
                        kc1[i9] = kc2[i9 - 1] + 1;
                        kc2[i9] = kc2[i9 - 1] + kc[i9];
                    }
                }
            }
        }

        public static void CommonDelete(
          ref int kLine,
          ref double[] radLine,
          ref int[] k1,
          ref int[] k2,
          ref double[] x,
          ref double[] y,
          int kCom,
          ref double[] radCom,
          ref int[] kc1,
          ref int[] kc2,
          ref double[] xCom,
          ref double[] yCom,
          ref int[] kc,
          double tol)
        {
            int i1 = 0;
            double num1;
            double num2 = num1 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            int num5;
            int num6 = num5 = 0;
            int num7;
            int i2 = num7 = 0;
            if (tol < 0.003)
                tol = 0.003;
            int kArray1 = 999999;
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            intArray(kc1, ref kArray1);
            intArray(kc2, ref kArray1);
            intArray(kc, ref kArray1);
            doubleArray(radLine, ref kArray1);
            doubleArray(radCom, ref kArray1);
            if (kLine > kArray1)
            {
                int num8 = (int)MessageBox.Show("Индекс массива CommonDelete");
            }
            else
            {
                int num9 = k2[kLine];
                int kArray2 = 999999;
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                doubleArray(xCom, ref kArray2);
                doubleArray(yCom, ref kArray2);
                if (num9 > kArray2)
                {
                    int num10 = (int)MessageBox.Show("Индекс массива CommonDelete");
                }
                else
                {
                    num6 = 0;
                    for (int i3 = 1; i3 <= kLine; ++i3)
                    {
                        int i4 = k1[i3];
                        int i5 = k2[i3];
                        double num11 = 0.5 * (x[i4] + x[i5]);
                        double num12 = 0.5 * (y[i4] + y[i5]);
                        int num13 = i5 - i4 + 1;
                        int num14 = 0;
                        for (int i6 = 1; i6 <= kCom; ++i6)
                        {
                            int i7 = kc1[i6];
                            int i8 = kc2[i6];
                            double num15 = 0.5 * (xCom[i7] + xCom[i8]);
                            double num16 = 0.5 * (yCom[i7] + yCom[i8]);
                            int num17 = i8 - i7 + 1;
                            if (num13 == num17 && radLine[i3] == radCom[i6])
                            {
                                double num18 = num15 - num11;
                                double num19 = num16 - num12;
                                if (Math.Sqrt(num18 * num18 + num19 * num19) < tol)
                                {
                                    ++num14;
                                    break;
                                }
                            }
                        }
                        if (num14 <= 0)
                        {
                            int num20 = 0;
                            for (int i9 = i4; i9 <= i5; ++i9)
                            {
                                ++num20;
                                ++i2;
                                x[i2] = x[i9];
                                y[i2] = y[i9];
                            }
                            ++i1;
                            radLine[i1] = radLine[i3];
                            kc[i1] = num20;
                        }
                    }
                    if (i1 <= 0)
                        return;
                    k1[1] = 1;
                    k2[1] = kc[1];
                    if (i1 > 1)
                    {
                        for (int i10 = 2; i10 <= i1; ++i10)
                        {
                            k1[i10] = k2[i10 - 1] + 1;
                            k2[i10] = k2[i10 - 1] + kc[i10];
                        }
                    }
                    kLine = i1;
                }
            }
        }

        public static void ParcelLine(
          int kp,
          ref double[] xp,
          ref double[] yp,
          int kin,
          ref int[] ind1,
          ref int[] ind2,
          ref double[] xin,
          ref double[] yin,
          int kTop,
          ref double[] rTop,
          ref int[] kt1,
          ref int[] kt2,
          ref double[] xt,
          ref double[] yt,
          out int kLin,
          ref double[] rLin,
          ref int[] k1,
          ref int[] k2,
          ref double[] xLin,
          ref double[] yLin,
          ref int[] kt,
          double tol)
        {
            kLin = 0;
            int num1;
            int i1 = num1 = 0;
            int num2;
            int num3 = num2 = 0;
            int num4;
            int num5 = num4 = 0;
            int num6;
            int num7 = num6 = 0;
            double num8;
            double num9 = num8 = 0.0;
            if (tol < 0.003)
                tol = 0.003;
            int kArray = 999999;
            doubleArray(xp, ref kArray);
            doubleArray(yp, ref kArray);
            doubleArray(xin, ref kArray);
            doubleArray(yin, ref kArray);
            doubleArray(rTop, ref kArray);
            doubleArray(rLin, ref kArray);
            doubleArray(xt, ref kArray);
            doubleArray(yt, ref kArray);
            doubleArray(xLin, ref kArray);
            doubleArray(yLin, ref kArray);
            if (kp > kArray)
            {
                int num10 = (int)MessageBox.Show("Индекс массива ParcelLine");
            }
            else
            {
                kArray = 999999;
                intArray(ind1, ref kArray);
                intArray(ind2, ref kArray);
                intArray(kt1, ref kArray);
                intArray(kt2, ref kArray);
                intArray(k1, ref kArray);
                intArray(k2, ref kArray);
                intArray(kt, ref kArray);
                if (kTop > kArray)
                {
                    int num11 = (int)MessageBox.Show("Индекс массива ParcelLine");
                }
                else
                {
                    for (int i2 = 1; i2 <= kTop; ++i2)
                    {
                        int i3 = kt1[i2];
                        int i4 = kt2[i2];
                        int num12 = i4 - i3;
                        int num13 = -1;
                        for (int i5 = 0; i5 <= kp; ++i5)
                        {
                            double num14 = xt[i3] - xp[i5];
                            double num15 = yt[i3] - yp[i5];
                            if (Math.Sqrt(num14 * num14 + num15 * num15) < tol)
                            {
                                num13 = i5;
                                break;
                            }
                        }
                        int num16 = -1;
                        for (int i6 = 0; i6 <= kp; ++i6)
                        {
                            double num17 = xt[i4] - xp[i6];
                            double num18 = yt[i4] - yp[i6];
                            if (Math.Sqrt(num17 * num17 + num18 * num18) < tol)
                            {
                                num16 = i6;
                                break;
                            }
                        }
                        if (num13 >= 0 && num16 >= 0)
                        {
                            if (num13 == 0 && num16 == 0)
                                num16 = kp;
                            if (num16 > num13)
                                num6 = num16 - num13;
                            if (num13 > num16)
                                num6 = num13 - num16;
                            if (num12 != num6 && num12 > 1 && num6 > 1)
                            {
                                if (num13 == 0)
                                {
                                    num6 = num16;
                                    num16 = kp;
                                    num13 = num6;
                                }
                                if (num16 == 0)
                                {
                                    num6 = num13;
                                    num16 = kp;
                                    num13 = num6;
                                }
                            }
                            int num19 = num13;
                            int num20 = num16;
                            if (num16 < num13)
                            {
                                num19 = num16;
                                num20 = num13;
                            }
                            if (num20 - num19 > 1)
                            {
                                int num21 = kp - num20;
                                if (num19 == 0)
                                {
                                    double num22 = xt[i4] - xt[i3];
                                    double num23 = yt[i4] - yt[i3];
                                    if (Math.Sqrt(num22 * num22 + num23 * num23) > tol && num21 < 2)
                                    {
                                        int num24 = kp;
                                        int num25 = num20;
                                        num20 = num24;
                                        num19 = num25;
                                    }
                                }
                            }
                            int num26 = 0;
                            for (int i7 = num19; i7 <= num20; ++i7)
                            {
                                ++num26;
                                ++i1;
                                xLin[i1] = xp[i7];
                                yLin[i1] = yp[i7];
                            }
                            ++kLin;
                            rLin[kLin] = rTop[i2];
                            kt[kLin] = num26;
                        }
                    }
                    if (kin > 0)
                    {
                        for (int i8 = 1; i8 <= kTop; ++i8)
                        {
                            int i9 = kt1[i8];
                            int i10 = kt2[i8];
                            for (int i11 = 1; i11 <= kin; ++i11)
                            {
                                int num27 = ind1[i11];
                                int num28 = ind2[i11];
                                int num29 = -1;
                                for (int i12 = num27; i12 <= num28; ++i12)
                                {
                                    double num30 = xt[i9] - xin[i12];
                                    double num31 = yt[i9] - yin[i12];
                                    if (Math.Sqrt(num30 * num30 + num31 * num31) < tol)
                                    {
                                        num29 = i12;
                                        break;
                                    }
                                }
                                int num32 = -1;
                                for (int i13 = num27; i13 <= num28; ++i13)
                                {
                                    double num33 = xt[i10] - xin[i13];
                                    double num34 = yt[i10] - yin[i13];
                                    if (Math.Sqrt(num33 * num33 + num34 * num34) < tol)
                                    {
                                        num32 = i13;
                                        break;
                                    }
                                }
                                if (num29 >= 0 && num32 >= 0)
                                {
                                    int num35 = num29;
                                    int num36 = num32;
                                    if (num32 < num29)
                                    {
                                        num35 = num32;
                                        num36 = num29;
                                    }
                                    if (num36 - num35 > 1 && num35 == num27)
                                    {
                                        int num37 = num28;
                                        int num38 = num36;
                                        num36 = num37;
                                        num35 = num38;
                                    }
                                    int num39 = 0;
                                    for (int i14 = num35; i14 <= num36; ++i14)
                                    {
                                        ++num39;
                                        ++i1;
                                        xLin[i1] = xin[i14];
                                        yLin[i1] = yin[i14];
                                    }
                                    ++kLin;
                                    rLin[kLin] = rTop[i8];
                                    kt[kLin] = num39;
                                }
                            }
                        }
                    }
                    if (kLin <= 0)
                        return;
                    k1[1] = 1;
                    k2[1] = kt[1];
                    if (kLin <= 1)
                        return;
                    for (int i15 = 2; i15 <= kLin; ++i15)
                    {
                        k1[i15] = k2[i15 - 1] + 1;
                        k2[i15] = k2[i15 - 1] + kt[i15];
                    }
                }
            }
        }

        public static void PolyFill(
          PaintEventArgs e,
          int k,
          double[] x,
          double[] y,
          int ki,
          int[] ki1,
          int[] ki2,
          double[] xi,
          double[] yi,
          double shx,
          double shy,
          int kPix,
          int[] ixSqu,
          int[] iySqu,
          int[] nColItem,
          int iWid,
          int iHei,
          int iLong,
          double[] xb,
          double[] yb,
          double[] xd,
          double[] yd,
          SolidBrush[] brColor,
          Pen[] pnColor)
        {
            Graphics graphics = e.Graphics;
            double num1 = 9999999.9;
            double num2 = 9999999.9;
            double num3 = -9999999.9;
            double num4 = -9999999.9;
            for (int i = 0; i <= k; ++i)
            {
                if (x[i] < num1)
                    num1 = x[i];
                if (y[i] < num2)
                    num2 = y[i];
                if (x[i] > num3)
                    num3 = x[i];
                if (y[i] > num4)
                    num4 = y[i];
            }
            int i1 = 1;
            xd[i1] = num1;
            double num5 = num1 - shx;
            do
            {
                num5 += shx;
                if (num5 > num3)
                {
                    if (num5 - num3 < 0.5 * shx)
                    {
                        ++i1;
                        xd[i1] = num3;
                        break;
                    }
                    break;
                }
                ++i1;
                xd[i1] = num5;
            }
            while (num5 < num3);
            if (i1 == 1)
            {
                ++i1;
                xd[i1] = num3;
            }
            int i2 = 1;
            yd[i2] = num2;
            double num6 = num2 - shy;
            do
            {
                num6 += shy;
                if (num6 > num4)
                {
                    if (num6 - num4 < 0.5 * shy)
                    {
                        ++i2;
                        yd[i2] = num4;
                        break;
                    }
                    break;
                }
                ++i2;
                yd[i2] = num6;
            }
            while (num6 < num4);
            if (i2 == 1)
            {
                ++i2;
                yd[i2] = num4;
            }
            int num7 = 0;
            for (int i3 = 2; i3 <= i2; ++i3)
            {
                double num8 = 0.5 * (yd[i3 - 1] + yd[i3]);
                for (int i4 = 2; i4 <= i1; ++i4)
                {
                    double num9 = 0.5 * (xd[i4 - 1] + xd[i4]);
                    if (num7 > 0)
                        num9 += 0.5 * shx;
                    double xt1 = num9 - 0.5 * (double)iWid;
                    double yt1 = num8 - 0.5 * (double)iHei;
                    int num10 = in_out(k, ref x, ref y, xt1, yt1);
                    double xt2 = num9 + 0.5 * (double)iWid;
                    double yt2 = num8 - 0.5 * (double)iHei;
                    int num11 = in_out(k, ref x, ref y, xt2, yt2);
                    double xt3 = num9 + 0.5 * (double)iWid;
                    double yt3 = num8 + 0.5 * (double)iHei;
                    int num12 = in_out(k, ref x, ref y, xt3, yt3);
                    double xt4 = num9 - 0.5 * (double)iWid;
                    double yt4 = num8 + 0.5 * (double)iHei;
                    int num13 = in_out(k, ref x, ref y, xt4, yt4);
                    if (num10 != 0 || num11 != 0 || num12 != 0 || num13 != 0)
                    {
                        int int32_1 = Convert.ToInt32(num9);
                        int int32_2 = Convert.ToInt32(num8);
                        if (iLong == 0)
                        {
                            for (int i5 = 1; i5 <= kPix; ++i5)
                            {
                                int num14 = int32_1 + ixSqu[i5];
                                int num15 = int32_2 + iySqu[i5];
                                int i6 = nColItem[i5];
                                int num16 = iWid / 2;
                                int num17 = iHei / 2;
                                double xt5 = (double)(num14 - num16);
                                double yt5 = (double)(num15 - num17);
                                int num18 = 0;
                                if (ki > 0)
                                {
                                    for (int i7 = 1; i7 <= ki; ++i7)
                                    {
                                        int num19 = ki1[i7];
                                        int num20 = ki2[i7];
                                        int k1 = -1;
                                        for (int i8 = num19; i8 <= num20; ++i8)
                                        {
                                            ++k1;
                                            xb[k1] = xi[i8];
                                            yb[k1] = yi[i8];
                                        }
                                        if (in_out(k1, ref xb, ref yb, xt5, yt5) > 0)
                                        {
                                            ++num18;
                                            break;
                                        }
                                    }
                                }
                                if (num18 <= 0 && in_out(k, ref x, ref y, xt5, yt5) != 0)
                                {
                                    SolidBrush solidBrush = brColor[i6];
                                    graphics.FillRectangle((Brush)solidBrush, num14 - num16, num15 - num17, 1, 1);
                                }
                            }
                        }
                    }
                }
                switch (num7)
                {
                    case 0:
                        num7 = 1;
                        break;
                    case 1:
                        num7 = 0;
                        break;
                }
            }
        }

        public static void DrawPoly(
          PaintEventArgs e,
          string fitemPoly,
          int kPoly,
          string[] namePoly,
          int[] kPol1,
          int[] kPol2,
          double[] xLab,
          double[] yLab,
          double[] arCalc,
          int[] nSymb,
          int[] iHorVer,
          double[] xPol,
          double[] yPol,
          int[] ki1,
          int[] ki2,
          double[] xi,
          double[] yi,
          int kSymbPoly,
          int[] np1Sign,
          int[] np2Sign,
          int[] nItem,
          int[] nBackCol,
          int[] nOneSymb,
          int[] ixSqu,
          int[] iySqu,
          int[] nColItem,
          double scaleToWin,
          double xBegX,
          double yBegY,
          int xBegWin,
          int yBegWin,
          double[] xa,
          double[] ya,
          double[] xb,
          double[] yb,
          double[] xc,
          double[] yc,
          SolidBrush[] brColor,
          Pen[] pnColor)
        {
            Graphics graphics = e.Graphics;
            string sTxt = "";
            double num1 = 0.0;
            for (int i1 = 1; i1 <= kPoly; ++i1)
            {
                int i2 = 0;
                for (int i3 = 1; i3 <= kSymbPoly; ++i3)
                {
                    if (np2Sign[i3] > 0 && np2Sign[i3] == nSymb[i1])
                    {
                        i2 = np1Sign[i3];
                        break;
                    }
                }
                if (i2 == 0)
                {
                    for (int i4 = 1; i4 <= kSymbPoly; ++i4)
                    {
                        if (np1Sign[i4] > 0 && np1Sign[i4] == nSymb[i1])
                        {
                            i2 = np1Sign[i4];
                            break;
                        }
                    }
                }
                int num2 = kPol1[i1];
                int num3 = kPol2[i1];
                int k1 = -1;
                for (int i5 = num2; i5 <= num3; ++i5)
                {
                    ++k1;
                    xa[k1] = xPol[i5];
                    ya[k1] = yPol[i5];
                }
                int i6 = 0;
                int ki = 0;
                int xWin;
                int yWin;
                if (kPoly > 1)
                {
                    for (int i7 = 1; i7 <= kPoly; ++i7)
                    {
                        if (i1 != i7 && arCalc[i7] < arCalc[i1])
                        {
                            int num4 = kPol1[i7];
                            int num5 = kPol2[i7];
                            int num6 = 0;
                            for (int i8 = num4; i8 <= num5; ++i8)
                            {
                                if (in_out(k1, ref xa, ref ya, xPol[i8], yPol[i8]) > 0)
                                {
                                    XYtoWIN(xPol[i8], yPol[i8], scaleToWin, xBegX, yBegY, xBegWin, yBegWin, out xWin, out yWin);
                                    if (xWin != 0 || yWin != 0)
                                    {
                                        ++num6;
                                        ++i6;
                                        xi[i6] = (double)xWin;
                                        yi[i6] = (double)yWin;
                                    }
                                }
                            }
                            if (num6 > 1)
                            {
                                ++ki;
                                if (ki == 1)
                                {
                                    ki1[1] = 1;
                                    ki2[1] = num6;
                                }
                                if (ki > 1)
                                {
                                    ki1[ki] = ki2[ki - 1] + 1;
                                    ki2[ki] = ki2[ki - 1] + num6;
                                }
                            }
                        }
                    }
                }
                int k2 = -1;
                for (int i9 = num2; i9 <= num3; ++i9)
                {
                    XYtoWIN(xPol[i9], yPol[i9], scaleToWin, xBegX, yBegY, xBegWin, yBegWin, out xWin, out yWin);
                    if (xWin != 0 || yWin != 0)
                    {
                        ++k2;
                        xa[k2] = (double)xWin;
                        ya[k2] = (double)yWin;
                    }
                }
                Point[] points = new Point[k2 + 1];
                for (int i10 = 0; i10 <= k2; ++i10)
                {
                    points[i10].X = Convert.ToInt32(xa[i10]);
                    points[i10].Y = Convert.ToInt32(ya[i10]);
                }
                int i11 = nBackCol[i2];
                switch (i11)
                {
                    case 0:
                    case 10:
                        SolidBrush solidBrush1 = new SolidBrush(Color.White);
                        graphics.FillPolygon((Brush)solidBrush1, points);
                        break;
                }
                if (i11 > 0 && i11 < 10)
                {
                    SolidBrush solidBrush2 = brColor[i11];
                    graphics.FillPolygon((Brush)solidBrush2, points);
                }
                int nSelect = nItem[i2];
                if (nSelect != 0)
                {
                    int num7 = nOneSymb[i2];
                    int iLong;
                    int iWid;
                    int iHei;
                    int kPix;
                    SelItemPoly(fitemPoly, nSelect, out iLong, out iWid, out iHei, out kPix, ixSqu, iySqu, nColItem, out sTxt, out int _);
                    if (num7 == 0 || num7 == 1)
                        num1 = 2.0;
                    if (num7 == 2)
                        num1 = 1.5;
                    if (num7 == 3)
                        num1 = 1.0;
                    if (num7 == 4)
                        num1 = 0.5;
                    if (num7 == 5)
                        num1 = 0.0;
                    double shx = (double)iWid + num1 * (double)iWid;
                    double shy = (double)iHei + num1 * (double)iHei;
                    PolyFill(e, k2, xa, ya, ki, ki1, ki2, xi, yi, shx, shy, kPix, ixSqu, iySqu, nColItem, iWid, iHei, iLong, xb, yb, xc, yc, brColor, pnColor);
                }
            }
        }

        public static void ActionMessage(int k, string[] sMess, out string sMessOut)
        {
            char[] seps = new char[2] { ' ', ',' };
            int k1 = 0;
            int kPart = 50;
            string[] strArray = new string[20];
            sMessOut = "";
            int kArray = 999999;
            stringArray(sMess, ref kArray);
            if (k > kArray)
            {
                int num1 = (int)MessageBox.Show("Индекс массива ActionMessage");
            }
            else
            {
                strArray[0] = "   Следующие действия были предприняты с участоками земли :";
                strArray[1] = "Разделение отдельного участка по известной площади(м.кв) между выбранной стороной и линией, параллельной ей";
                strArray[2] = "Разделение отдельного Участка по известному расстоянию(м) между выбранной стороной и линией, параллельной ей";
                strArray[3] = "Разделение отдельного Участка известным Процентом(%) площади Участка между выбранной стороной и линией, параллельной ей";
                strArray[4] = "Разделение отдельного Участка по известной площади(м.кв) слева Перпендикулярно выбранной стороне";
                strArray[5] = "Разделение отдельного Участка путем деления выбранной Линии пополам с Перпендикуляром";
                strArray[6] = "Разделение отдельного Участка известным Процентом(%) площади Участка слева Перпендикулярно выбранной стороне";
                strArray[7] = "Разделение участков с использованием всех линий дизайна";
                strArray[8] = "Разделение Участков с использованием любой (открытой или закрытой) выбранной Линии из Проекта";
                strArray[9] = "Объединение некоторых выбранных соседних участков";
                strArray[10] = "Объединение некоторых выбранных соседних участков";
                strArray[11] = "Объединение всех соседних посылок";
                strArray[12] = "Удаление выбранной внутренней посылки";
                sMessOut = sMessOut + "\n" + strArray[0];
                int num2 = 0;
                for (int i = 1; i <= k; ++i)
                {
                    string[] sPart;
                    ShareString(sMess[i], kPart, seps, out k1, out sPart);
                    switch (k1)
                    {
                        case 0:
                            return;
                        case 2:
                            int int32 = Convert.ToInt32(sPart[1]);
                            if (int32 == 210)
                            {
                                ++num2;
                                sMessOut = sMessOut + "\n" + string.Format("{0}", (object)num2) + "." + strArray[1];
                            }
                            if (int32 == 220)
                            {
                                ++num2;
                                sMessOut = sMessOut + "\n" + string.Format("{0}", (object)num2) + "." + strArray[2];
                            }
                            if (int32 == 230)
                            {
                                ++num2;
                                sMessOut = sMessOut + "\n" + string.Format("{0}", (object)num2) + "." + strArray[3];
                            }
                            if (int32 == 240)
                            {
                                ++num2;
                                sMessOut = sMessOut + "\n" + string.Format("{0}", (object)num2) + "." + strArray[4];
                            }
                            if (int32 == 250)
                            {
                                ++num2;
                                sMessOut = sMessOut + "\n" + string.Format("{0}", (object)num2) + "." + strArray[5];
                            }
                            if (int32 == 260)
                            {
                                ++num2;
                                sMessOut = sMessOut + "\n" + string.Format("{0}", (object)num2) + "." + strArray[6];
                            }
                            if (int32 == 270)
                            {
                                ++num2;
                                sMessOut = sMessOut + "\n" + string.Format("{0}", (object)num2) + "." + strArray[7];
                            }
                            if (int32 == 280)
                            {
                                ++num2;
                                sMessOut = sMessOut + "\n" + string.Format("{0}", (object)num2) + "." + strArray[8];
                            }
                            if (int32 == 290)
                            {
                                ++num2;
                                sMessOut = sMessOut + "\n" + string.Format("{0}", (object)num2) + "." + strArray[9];
                            }
                            if (int32 == 310)
                            {
                                ++num2;
                                sMessOut = sMessOut + "\n" + string.Format("{0}", (object)num2) + "." + strArray[10];
                            }
                            if (int32 == 320)
                            {
                                ++num2;
                                sMessOut = sMessOut + "\n" + string.Format("{0}", (object)num2) + "." + strArray[11];
                            }
                            if (int32 == 410)
                            {
                                ++num2;
                                sMessOut = sMessOut + "\n" + string.Format("{0}", (object)num2) + "." + strArray[12];
                                break;
                            }
                            break;
                    }
                }
            }
        }

        public static void LineOpenСлияние(
          double tol,
          int kLin1,
          ref int[] k1,
          ref int[] k2,
          ref double[] x1,
          ref double[] y1,
          out int kLin2,
          ref int[] kd1,
          ref int[] kd2,
          ref int[] kdd,
          ref double[] x2,
          ref double[] y2,
          ref int[] ni,
          ref double[] xp,
          ref double[] yp)
        {
            kLin2 = 0;
            int num1;
            int num2 = num1 = 0;
            int i1;
            int num3 = i1 = 0;
            double num4;
            double num5 = num4 = 0.0;
            if (tol < 0.003)
                tol = 0.003;
            int kArray1 = 999999;
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            intArray(kd1, ref kArray1);
            intArray(kd2, ref kArray1);
            intArray(kdd, ref kArray1);
            if (kLin1 > kArray1)
            {
                int num6 = (int)MessageBox.Show("Индекс массива LineOpenСлияние");
            }
            else
            {
                int num7 = k2[kLin1];
                int kArray2 = 999999;
                intArray(ni, ref kArray2);
                doubleArray(x1, ref kArray2);
                doubleArray(y1, ref kArray2);
                doubleArray(x2, ref kArray2);
                doubleArray(y2, ref kArray2);
                doubleArray(xp, ref kArray2);
                doubleArray(yp, ref kArray2);
                if (num7 > kArray2)
                {
                    int num8 = (int)MessageBox.Show("Индекс массива LineOpenСлияние");
                }
                else
                {
                    num3 = 0;
                    for (int i2 = 1; i2 <= kLin1; ++i2)
                    {
                        int i3 = k1[i2];
                        int i4 = k2[i2];
                        int i5 = i1 + 1;
                        xp[i5] = x1[i3];
                        yp[i5] = y1[i3];
                        i1 = i5 + 1;
                        xp[i1] = x1[i4];
                        yp[i1] = y1[i4];
                    }
                    if (i1 == 0)
                        return;
                    for (int i6 = 1; i6 < i1; ++i6)
                    {
                        int num9 = 0;
                        for (int i7 = i6 + 1; i7 <= i1; ++i7)
                        {
                            if (xp[i7] != 0.0 || yp[i7] != 0.0)
                            {
                                double num10 = xp[i6] - xp[i7];
                                double num11 = yp[i6] - yp[i7];
                                if (Math.Sqrt(num10 * num10 + num11 * num11) < tol)
                                {
                                    ++num9;
                                    xp[i7] = 0.0;
                                    yp[i7] = 0.0;
                                }
                            }
                        }
                        if (num9 > 0)
                        {
                            xp[i6] = 0.0;
                            yp[i6] = 0.0;
                        }
                    }
                    int i8 = 0;
                    for (int i9 = 1; i9 <= i1; ++i9)
                    {
                        if (xp[i9] != 0.0 || yp[i9] != 0.0)
                        {
                            ++i8;
                            xp[i8] = xp[i9];
                            yp[i8] = yp[i9];
                        }
                    }
                    int num12 = i8;
                    int i10 = 0;
                    int i11 = 0;
                    for (int i12 = 1; i12 < num12; ++i12)
                    {
                        int num13 = 0;
                        if (i10 > 0)
                        {
                            double num14 = x2[i10] - xp[i12];
                            double num15 = y2[i10] - yp[i12];
                            if (Math.Sqrt(num14 * num14 + num15 * num15) < tol)
                                ++num13;
                        }
                        if (num13 <= 0)
                        {
                            int num16 = 0;
                            for (int i13 = 1; i13 <= kLin1; ++i13)
                            {
                                int num17 = 0;
                                for (int i14 = 1; i14 <= kLin1; ++i14)
                                {
                                    int num18 = 0;
                                    if (i11 > 0)
                                    {
                                        for (int i15 = 1; i15 <= i11; ++i15)
                                        {
                                            if (ni[i15] == i14)
                                            {
                                                ++num18;
                                                break;
                                            }
                                        }
                                    }
                                    if (num18 <= 0)
                                    {
                                        int i16 = k1[i14];
                                        int i17 = k2[i14];
                                        int num19 = 0;
                                        int num20 = 0;
                                        if (num16 > 0)
                                        {
                                            double num21 = x1[i16] - x2[i10];
                                            double num22 = y1[i16] - y2[i10];
                                            if (Math.Sqrt(num21 * num21 + num22 * num22) < tol)
                                                ++num19;
                                        }
                                        if (num16 == 0)
                                        {
                                            double num23 = x1[i16] - xp[i12];
                                            double num24 = y1[i16] - yp[i12];
                                            if (Math.Sqrt(num23 * num23 + num24 * num24) < tol)
                                                ++num20;
                                        }
                                        if (num19 > 0)
                                        {
                                            ++num17;
                                            ++i11;
                                            ni[i11] = i14;
                                            for (int i18 = i16 + 1; i18 <= i17; ++i18)
                                            {
                                                ++num16;
                                                ++i10;
                                                x2[i10] = x1[i18];
                                                y2[i10] = y1[i18];
                                            }
                                        }
                                        else if (num20 > 0)
                                        {
                                            ++num17;
                                            ++i11;
                                            ni[i11] = i14;
                                            for (int i19 = i16; i19 <= i17; ++i19)
                                            {
                                                ++num16;
                                                ++i10;
                                                x2[i10] = x1[i19];
                                                y2[i10] = y1[i19];
                                            }
                                        }
                                        else
                                        {
                                            int num25 = 0;
                                            int num26 = 0;
                                            if (num16 > 0)
                                            {
                                                double num27 = x1[i17] - x2[i10];
                                                double num28 = y1[i17] - y2[i10];
                                                if (Math.Sqrt(num27 * num27 + num28 * num28) < tol)
                                                    ++num25;
                                            }
                                            if (num16 == 0)
                                            {
                                                double num29 = x1[i17] - xp[i12];
                                                double num30 = y1[i17] - yp[i12];
                                                if (Math.Sqrt(num29 * num29 + num30 * num30) < tol)
                                                    ++num26;
                                            }
                                            if (num25 > 0)
                                            {
                                                ++num17;
                                                ++i11;
                                                ni[i11] = i14;
                                                int i20 = i17;
                                                for (int i21 = i16; i21 < i17; ++i21)
                                                {
                                                    ++num16;
                                                    ++i10;
                                                    --i20;
                                                    x2[i10] = x1[i20];
                                                    y2[i10] = y1[i20];
                                                }
                                            }
                                            else if (num26 > 0)
                                            {
                                                ++num17;
                                                ++i11;
                                                ni[i11] = i14;
                                                int i22 = i17 + 1;
                                                for (int i23 = i16; i23 <= i17; ++i23)
                                                {
                                                    ++num16;
                                                    ++i10;
                                                    --i22;
                                                    x2[i10] = x1[i22];
                                                    y2[i10] = y1[i22];
                                                }
                                            }
                                        }
                                    }
                                }
                                if (num17 == 0)
                                    break;
                            }
                            if (num16 > 1)
                            {
                                ++kLin2;
                                kdd[kLin2] = num16;
                            }
                        }
                    }
                    if (kLin2 == 0)
                        return;
                    kd1[1] = 1;
                    kd2[1] = kdd[1];
                    if (kLin2 <= 1)
                        return;
                    for (int i24 = 2; i24 <= kLin2; ++i24)
                    {
                        kd1[i24] = kd2[i24 - 1] + 1;
                        kd2[i24] = kd2[i24 - 1] + kdd[i24];
                    }
                }
            }
        }

        public static void DrawNodeAct(
          PaintEventArgs e,
          int kNodeAct,
          string[] nameNodeAct,
          double[] xNodeAct,
          double[] yNodeAct,
          double scaleToWin,
          double xBegX,
          double yBegY,
          int xBegWin,
          int yBegWin)
        {
            Graphics graphics = e.Graphics;
            int xWin = 0;
            int yWin = 0;
            int emSize = 7;
            if (kNodeAct <= 0)
                return;
            int kArray = 999999;
            stringArray(nameNodeAct, ref kArray);
            doubleArray(xNodeAct, ref kArray);
            doubleArray(yNodeAct, ref kArray);
            if (kNodeAct > kArray)
            {
                int num = (int)MessageBox.Show("Индекс массива DrawNodeAct");
            }
            else
            {
                SolidBrush solidBrush = new SolidBrush(Color.Magenta);
                for (int i = 1; i <= kNodeAct; ++i)
                {
                    XYtoWIN(xNodeAct[i], yNodeAct[i], scaleToWin, xBegX, yBegY, xBegWin, yBegWin, out xWin, out yWin);
                    if (xWin != 0 || yWin != 0)
                    {
                        graphics.FillRectangle((Brush)new SolidBrush(Color.Magenta), xWin - 2, yWin - 2, 5, 5);
                        graphics.DrawString(nameNodeAct[i], new Font("Bold", (float)emSize), (Brush)solidBrush, (float)(xWin + emSize / 2), (float)(yWin - emSize + 2));
                    }
                }
            }
        }

        public static void PolyDelete(
          int kPoly,
          ref int[] k1,
          ref int[] k2,
          ref double[] x,
          ref double[] y,
          out int kPol,
          ref string[] namePol,
          ref double[] xPol,
          ref double[] yPol,
          ref double[] zPol,
          ref double[] aLegal,
          ref int[] nSymbPol,
          ref int[] kp1,
          ref int[] kp2,
          ref double[] xp,
          ref double[] yp,
          double tol,
          ref double[] xa,
          ref double[] ya,
          ref double[] xb,
          ref double[] yb,
          ref double[] zb,
          ref int[] kpp)
        {
            double xc = 0.0;
            double yc = 0.0;
            double sArea = 0.0;
            kPol = 0;
            Cursor.Current = Cursors.WaitCursor;
            if (kPoly < 1)
                return;
            if (tol < 0.003)
                tol = 0.003;
            int kArray = 999999;
            stringArray(namePol, ref kArray);
            intArray(nSymbPol, ref kArray);
            intArray(k1, ref kArray);
            intArray(k2, ref kArray);
            intArray(kp1, ref kArray);
            intArray(kp2, ref kArray);
            intArray(kpp, ref kArray);
            doubleArray(xPol, ref kArray);
            doubleArray(yPol, ref kArray);
            doubleArray(zPol, ref kArray);
            doubleArray(aLegal, ref kArray);
            if (kPoly > kArray)
            {
                int num1 = (int)MessageBox.Show("Индекс массива PolyDelete");
            }
            else
            {
                int num2 = k2[kPoly];
                kArray = 999999;
                doubleArray(x, ref kArray);
                doubleArray(y, ref kArray);
                doubleArray(xp, ref kArray);
                doubleArray(yp, ref kArray);
                doubleArray(xb, ref kArray);
                doubleArray(yb, ref kArray);
                doubleArray(zb, ref kArray);
                doubleArray(xa, ref kArray);
                doubleArray(ya, ref kArray);
                if (num2 > kArray)
                {
                    int num3 = (int)MessageBox.Show("Индекс массива PolyDelete");
                }
                else
                {
                    if (kPoly <= 1)
                        return;
                    for (int i1 = 1; i1 < kPoly; ++i1)
                    {
                        for (int i2 = i1 + 1; i2 <= kPoly; ++i2)
                        {
                            if (zPol[i2] > zPol[i1])
                            {
                                string str = namePol[i2];
                                sArea = zPol[i2];
                                double num4 = aLegal[i2];
                                int num5 = nSymbPol[i2];
                                xc = xPol[i2];
                                yc = yPol[i2];
                                namePol[i2] = namePol[i1];
                                zPol[i2] = zPol[i1];
                                aLegal[i2] = aLegal[i1];
                                nSymbPol[i2] = nSymbPol[i1];
                                xPol[i2] = xPol[i1];
                                yPol[i2] = yPol[i1];
                                namePol[i1] = str;
                                zPol[i1] = sArea;
                                aLegal[i1] = num4;
                                nSymbPol[i1] = num5;
                                xPol[i1] = xc;
                                yPol[i1] = yc;
                            }
                        }
                    }
                    for (int i3 = 1; i3 < kPoly; ++i3)
                    {
                        for (int i4 = i3 + 1; i4 <= kPoly; ++i4)
                        {
                            double num6 = xPol[i3] - xPol[i4];
                            double num7 = yPol[i3] - yPol[i4];
                            double num8 = Math.Sqrt(num6 * num6 + num7 * num7);
                            sArea = Math.Abs(zPol[i3] - zPol[i4]);
                            if (num8 <= 0.1 && sArea < 0.1)
                            {
                                xPol[i4] = 0.0;
                                yPol[i4] = 0.0;
                            }
                        }
                    }
                    int i5 = 0;
                    for (int i6 = 1; i6 <= kPoly; ++i6)
                    {
                        if (xPol[i6] != 0.0 || yPol[i6] != 0.0)
                        {
                            ++i5;
                            namePol[i5] = namePol[i6];
                            xPol[i5] = xPol[i6];
                            yPol[i5] = yPol[i6];
                            zPol[i5] = zPol[i6];
                            aLegal[i5] = aLegal[i6];
                            nSymbPol[i5] = nSymbPol[i6];
                        }
                    }
                    kPol = i5;
                    int i7 = 0;
                    for (int i8 = 1; i8 <= kPol; ++i8)
                    {
                        for (int i9 = 1; i9 <= kPoly; ++i9)
                        {
                            int num9 = k1[i9];
                            int num10 = k2[i9];
                            int k = 0;
                            for (int i10 = num9; i10 <= num10; ++i10)
                            {
                                ++k;
                                xa[k] = x[i10];
                                ya[k] = y[i10];
                            }
                            PolyLabel1(k, ref xa, ref ya, ref xb, ref yb, ref zb, out xc, out yc);
                            PolyArea1(k, xa, ya, out sArea);
                            double num11 = xPol[i8] - xc;
                            double num12 = yPol[i8] - yc;
                            double num13 = Math.Sqrt(num11 * num11 + num12 * num12);
                            double num14 = Math.Abs(zPol[i8] - sArea);
                            if (num13 < tol && num14 < 0.2)
                            {
                                kpp[i8] = num10 - num9 + 1;
                                for (int i11 = num9; i11 <= num10; ++i11)
                                {
                                    ++i7;
                                    xp[i7] = x[i11];
                                    yp[i7] = y[i11];
                                }
                                break;
                            }
                        }
                    }
                    kp1[1] = 1;
                    kp2[1] = kpp[1];
                    if (kPol > 1)
                    {
                        for (int i12 = 2; i12 <= kPol; ++i12)
                        {
                            kp1[i12] = kp2[i12 - 1] + 1;
                            kp2[i12] = kp2[i12 - 1] + kpp[i12];
                        }
                    }
                    if (kPol == 2)
                        return;
                    int num15 = kp1[1];
                    int num16 = kp2[1];
                    int i13 = 0;
                    for (int i14 = num15; i14 <= num16; ++i14)
                    {
                        ++i13;
                        xa[i13] = xp[i14];
                        ya[i13] = yp[i14];
                    }
                    int k3 = -1;
                    for (int i15 = 1; i15 <= i13; ++i15)
                    {
                        ++k3;
                        xb[k3] = xa[i15];
                        yb[k3] = ya[i15];
                    }
                    int i16 = 2;
                    while (i16 <= kPol && in_out(k3, ref xb, ref yb, xPol[i16], yPol[i16]) != 0)
                        ++i16;
                    if (kPol <= 1)
                        return;
                    for (int i17 = 1; i17 < kPol; ++i17)
                    {
                        int num17 = kp1[i17];
                        int num18 = kp2[i17];
                        int k4 = -1;
                        for (int i18 = num17; i18 <= num18; ++i18)
                        {
                            ++k4;
                            xa[k4] = xp[i18];
                            ya[k4] = yp[i18];
                        }
                        double num19 = 0.0;
                        for (int i19 = i17 + 1; i19 <= kPol; ++i19)
                        {
                            if (in_out(k4, ref xa, ref ya, xPol[i19], yPol[i19]) != 0)
                            {
                                int num20 = kp1[i19];
                                int num21 = kp2[i19];
                                int num22 = 0;
                                for (int i20 = num17; i20 <= num18; ++i20)
                                {
                                    for (int i21 = num20; i21 <= num21; ++i21)
                                    {
                                        double num23 = xp[i20] - xp[i21];
                                        double num24 = yp[i20] - yp[i21];
                                        if (Math.Sqrt(num23 * num23 + num24 * num24) < tol)
                                        {
                                            ++num22;
                                            break;
                                        }
                                    }
                                    if (num22 > 0)
                                        break;
                                }
                                if (num22 > 0)
                                {
                                    xPol[i17] = 0.0;
                                    yPol[i17] = 0.0;
                                    num19 = 0.0;
                                    break;
                                }
                                num19 += zPol[i19];
                            }
                        }
                        if (Math.Abs(zPol[i17] - num19) < 0.05)
                        {
                            xPol[i17] = 0.0;
                            yPol[i17] = 0.0;
                        }
                    }
                    int i22 = 0;
                    int i23 = 0;
                    for (int i24 = 1; i24 <= kPol; ++i24)
                    {
                        if (xPol[i24] != 0.0 || yPol[i24] != 0.0)
                        {
                            int num25 = kp1[i24];
                            int num26 = kp2[i24];
                            ++i23;
                            kpp[i23] = num26 - num25 + 1;
                            namePol[i23] = namePol[i24];
                            xPol[i23] = xPol[i24];
                            yPol[i23] = yPol[i24];
                            zPol[i23] = zPol[i24];
                            aLegal[i23] = aLegal[i24];
                            nSymbPol[i23] = nSymbPol[i24];
                            for (int i25 = num25; i25 <= num26; ++i25)
                            {
                                ++i22;
                                xa[i22] = xp[i25];
                                ya[i22] = yp[i25];
                            }
                        }
                    }
                    kPol = i23;
                    kp1[1] = 1;
                    kp2[1] = kpp[1];
                    if (kPol > 1)
                    {
                        for (int i26 = 2; i26 <= kPol; ++i26)
                        {
                            kp1[i26] = kp2[i26 - 1] + 1;
                            kp2[i26] = kp2[i26 - 1] + kpp[i26];
                        }
                    }
                    for (int i27 = 1; i27 <= i22; ++i27)
                    {
                        xp[i27] = xa[i27];
                        yp[i27] = ya[i27];
                    }
                }
            }
        }

        public static void PolyInterior(
          int kPoly,
          ref double[] xPol,
          ref double[] yPol,
          ref double[] zPol,
          ref double[] aLegal,
          ref int[] k1,
          ref int[] k2,
          ref double[] x,
          ref double[] y,
          out int kin,
          ref int[] nPol,
          ref int[] kt1,
          ref int[] kt2,
          ref int[] ktt,
          ref int[] nPin,
          ref double[] xin,
          ref double[] yin,
          ref double[] xa,
          ref double[] ya,
          ref double[] xr,
          ref double[] yr,
          ref double[] zr,
          ref double[] xd,
          ref double[] yd,
          ref double[] zd)
        {
            int[] k1_1 = new int[100];
            int[] k2_1 = new int[100];
            int[] numArray = new int[100];
            int num1;
            int i1 = num1 = 0;
            kin = 0;
            Cursor.Current = Cursors.WaitCursor;
            int kArray1 = 999999;
            doubleArray(xPol, ref kArray1);
            doubleArray(yPol, ref kArray1);
            doubleArray(zPol, ref kArray1);
            doubleArray(aLegal, ref kArray1);
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            intArray(nPol, ref kArray1);
            intArray(kt1, ref kArray1);
            intArray(kt2, ref kArray1);
            intArray(ktt, ref kArray1);
            if (kPoly > kArray1)
            {
                int num2 = (int)MessageBox.Show("Индекс массива 1-PolyInterior");
            }
            else
            {
                int num3 = k2[kPoly];
                int kArray2 = 999999;
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                intArray(nPin, ref kArray2);
                doubleArray(xin, ref kArray2);
                doubleArray(yin, ref kArray2);
                doubleArray(xa, ref kArray2);
                doubleArray(ya, ref kArray2);
                doubleArray(xr, ref kArray2);
                doubleArray(yr, ref kArray2);
                doubleArray(zr, ref kArray2);
                doubleArray(xd, ref kArray2);
                doubleArray(yd, ref kArray2);
                doubleArray(zd, ref kArray2);
                if (num3 > kArray2)
                {
                    int num4 = (int)MessageBox.Show("Индекс массива 2-PolyInterior");
                }
                else
                {
                    int i2 = 0;
                    for (int i3 = 1; i3 < kPoly; ++i3)
                    {
                        int k3 = -1;
                        int num5 = k1[i3];
                        int num6 = k2[i3];
                        for (int i4 = num5; i4 <= num6; ++i4)
                        {
                            ++k3;
                            xa[k3] = x[i4];
                            ya[k3] = y[i4];
                        }
                        int i5 = 0;
                        int num7 = i3 + 1;
                        for (int i6 = num7; i6 <= kPoly; ++i6)
                        {
                            int num8 = k1[i6];
                            int num9 = k2[i6];
                            int num10 = 0;
                            for (int i7 = num8; i7 <= num9; ++i7)
                            {
                                num10 = in_out(k3, ref xa, ref ya, x[i7], y[i7]);
                                if (num10 == 0)
                                    break;
                            }
                            if (num10 != 0)
                            {
                                ++i5;
                                k1_1[i5] = i6;
                            }
                        }
                        if (i5 != 0)
                        {
                            int i8 = 0;
                            for (int i9 = num7; i9 < kPoly; ++i9)
                            {
                                int num11 = 0;
                                for (int i10 = 1; i10 <= i5; ++i10)
                                {
                                    if (k1_1[i10] == i9)
                                    {
                                        ++num11;
                                        break;
                                    }
                                }
                                if (num11 != 0)
                                {
                                    int k4 = -1;
                                    int num12 = k1[i9];
                                    int num13 = k2[i9];
                                    for (int i11 = num12; i11 <= num13; ++i11)
                                    {
                                        ++k4;
                                        xa[k4] = x[i11];
                                        ya[k4] = y[i11];
                                    }
                                    for (int i12 = i9 + 1; i12 <= kPoly; ++i12)
                                    {
                                        int num14 = k1[i12];
                                        int num15 = k2[i12];
                                        int num16 = 0;
                                        for (int i13 = num14; i13 <= num15; ++i13)
                                        {
                                            num16 = in_out(k4, ref xa, ref ya, x[i13], y[i13]);
                                            if (num16 == 0)
                                                break;
                                        }
                                        if (num16 != 0)
                                        {
                                            ++i8;
                                            k2_1[i8] = i12;
                                        }
                                    }
                                }
                            }
                            if (i8 == 0)
                            {
                                ++kin;
                                nPol[kin] = i3;
                                ktt[kin] = i5;
                                for (int i14 = 1; i14 <= i5; ++i14)
                                {
                                    ++i2;
                                    nPin[i2] = k1_1[i14];
                                }
                            }
                            else
                            {
                                for (int i15 = 1; i15 <= i5; ++i15)
                                {
                                    for (int i16 = 1; i16 <= i8; ++i16)
                                    {
                                        if (k1_1[i15] == k2_1[i16])
                                            k1_1[i15] = 0;
                                    }
                                }
                                int i17 = 0;
                                for (int i18 = 1; i18 <= i5; ++i18)
                                {
                                    if (k1_1[i18] != 0)
                                    {
                                        ++i17;
                                        k1_1[i17] = k1_1[i18];
                                    }
                                }
                                int num17 = i17;
                                if (num17 != 0)
                                {
                                    ++kin;
                                    nPol[kin] = i3;
                                    ktt[kin] = num17;
                                    for (int i19 = 1; i19 <= num17; ++i19)
                                    {
                                        ++i2;
                                        nPin[i2] = k1_1[i19];
                                    }
                                }
                            }
                        }
                    }
                    if (kin == 0)
                        return;
                    kt1[1] = 1;
                    kt2[1] = ktt[1];
                    if (kin > 1)
                    {
                        for (int i20 = 2; i20 <= kin; ++i20)
                        {
                            kt1[i20] = kt2[i20 - 1] + 1;
                            kt2[i20] = kt2[i20 - 1] + ktt[i20];
                        }
                    }
                    for (int i21 = 1; i21 <= kPoly; ++i21)
                    {
                        int num18 = 0;
                        for (int i22 = 1; i22 <= kin; ++i22)
                        {
                            if (nPol[i22] == i21)
                            {
                                ++num18;
                                i1 = i22;
                                break;
                            }
                        }
                        if (num18 != 0)
                        {
                            int num19 = k1[i21];
                            int num20 = k2[i21];
                            int k = 0;
                            for (int i23 = num19; i23 <= num20; ++i23)
                            {
                                ++k;
                                xa[k] = x[i23];
                                ya[k] = y[i23];
                            }
                            int num21 = kt1[i1];
                            int num22 = kt2[i1];
                            int kin1 = 0;
                            int i24 = 0;
                            double num23 = 0.0;
                            double num24 = 0.0;
                            for (int i25 = num21; i25 <= num22; ++i25)
                            {
                                for (int i26 = 1; i26 <= kPoly; ++i26)
                                {
                                    if (nPin[i25] == i26)
                                    {
                                        num23 += zPol[i26];
                                        num24 += aLegal[i26];
                                        int num25 = k1[i26];
                                        int num26 = k2[i26];
                                        ++kin1;
                                        numArray[kin1] = num26 - num25 + 1;
                                        for (int i27 = num25; i27 <= num26; ++i27)
                                        {
                                            ++i24;
                                            xin[i24] = x[i27];
                                            yin[i24] = y[i27];
                                        }
                                        break;
                                    }
                                }
                            }
                            if (i24 != 0)
                            {
                                k1_1[1] = 1;
                                k2_1[1] = numArray[1];
                                if (kin1 > 1)
                                {
                                    for (int i28 = 2; i28 <= kin1; ++i28)
                                    {
                                        k1_1[i28] = k2_1[i28 - 1] + 1;
                                        k2_1[i28] = k2_1[i28 - 1] + numArray[i28];
                                    }
                                }
                                double xpol;
                                double ypol;
                                PolygonLabel(k, ref xa, ref ya, kin1, ref k1_1, ref k2_1, ref xin, ref yin, out xpol, out ypol, ref xr, ref yr, ref zr, ref xd, ref yd, ref zd);
                                xPol[i21] = xpol;
                                yPol[i21] = ypol;
                                zPol[i21] = zPol[i21] - num23;
                                aLegal[i21] = aLegal[i21] - num24;
                            }
                        }
                    }
                }
            }
        }

        public static void TolerForm4(int k, ref char[] sTemp, double A, out double aNum)
        {
            char[] chArray = new char[20];
            int[] k1 = new int[10];
            int[] k2 = new int[10];
            int[] kac = new int[10];
            int[] kai = new int[10];
            int[] ksm = new int[10];
            int[] ksi = new int[10];
            int[] ind = new int[10];
            double num1 = 0.0;
            double[] aDat = new double[10];
            aNum = 0.0;
            int ka;
            int ks;
            TolerAction(k, ref sTemp, out int _, ref k1, ref k2, out ka, ref kai, ref kac, out ks, ref ksi, ref ksm);
            int knum = 0;
            if (ks > 0)
            {
                for (int i1 = 1; i1 <= ks; ++i1)
                {
                    int num2 = ksm[i1];
                    if (num2 > 47 && num2 < 58)
                    {
                        int num3 = ksi[i1];
                        int i2 = -1;
                        for (int i3 = num3; i3 <= k; ++i3)
                        {
                            switch (sTemp[i3])
                            {
                                case '.':
                                    ++i2;
                                    chArray[i2] = sTemp[i3];
                                    break;
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                    ++i2;
                                    chArray[i2] = sTemp[i3];
                                    break;
                                default:
                                    goto label_9;
                            }
                        }
                    label_9:
                        int km = i2 + 1;
                        chArray[km] = char.MinValue;
                        TolerForm1(km, ref sTemp, out num1);
                        ++knum;
                        ind[knum] = ksi[i1];
                        aDat[knum] = num1;
                    }
                    if (num2 == 65 || num2 == 97)
                    {
                        ++knum;
                        ind[knum] = ksi[i1];
                        aDat[knum] = A;
                    }
                }
            }
            for (int i4 = 1; i4 < knum; ++i4)
            {
                for (int i5 = i4 + 1; i5 <= knum; ++i5)
                {
                    if (ind[i4] > ind[i5])
                    {
                        int num4 = ind[i4];
                        num1 = aDat[i4];
                        ind[i4] = ind[i5];
                        aDat[i4] = aDat[i5];
                        ind[i5] = num4;
                        aDat[i5] = num1;
                    }
                }
            }
            TolerSum(knum, ref ind, ref aDat, ka, ref kai, ref kac, out num1);
            aNum = num1;
        }

        public static void ParcelIntersect(
          double xh,
          double yh,
          double xk,
          double yk,
          int k,
          ref double[] x,
          ref double[] y,
          int kin,
          ref int[] kn1,
          ref int[] kn2,
          ref double[] xin,
          ref double[] yin,
          out int kLin,
          ref int[] kp1,
          ref int[] kp2,
          ref double[] xp,
          ref double[] yp,
          ref double[] xr,
          ref double[] yr,
          ref double[] sr,
          ref double[] xa,
          ref double[] ya,
          ref int[] nr,
          double tol)
        {
            double num1 = 3.1415926;
            kLin = 0;
            int num2;
            int num3 = num2 = 0;
            int ip1;
            int ip2 = ip1 = 0;
            int num4;
            int num5 = num4 = 0;
            double num6;
            double ym = num6 = 0.0;
            double xm = num6;
            double yp1 = num6;
            double xp1 = num6;
            double num7;
            double num8 = num7 = 0.0;
            double num9;
            double num10 = num9 = 0.0;
            double dist1;
            double dist2 = dist1 = 0.0;
            if (tol < 0.003)
                tol = 0.003;
            int kArray = 999999;
            doubleArray(xp, ref kArray);
            doubleArray(yp, ref kArray);
            int num11 = kArray - 3;
            int i1 = 0;
            for (int i2 = 1; i2 <= k; ++i2)
            {
                double x3 = x[i2 - 1];
                double y3 = y[i2 - 1];
                double x4 = x[i2];
                double y4 = y[i2];
                int ip3 = 1;
                TwoLine(xh, yh, x3, y3, xk, yk, x4, y4, out xm, out ym, ref ip3);
                if (xm != 0.0 || ym != 0.0)
                {
                    ++i1;
                    nr[i1] = 1;
                    xr[i1] = xm;
                    yr[i1] = ym;
                    double num12 = xm - xh;
                    double num13 = ym - yh;
                    sr[i1] = Math.Sqrt(num12 * num12 + num13 * num13);
                }
            }
            if (kin > 0)
            {
                for (int i3 = 1; i3 <= kin; ++i3)
                {
                    int num14 = kn1[i3];
                    int num15 = kn2[i3];
                    for (int i4 = num14 + 1; i4 <= num15; ++i4)
                    {
                        double x3 = xin[i4 - 1];
                        double y3 = yin[i4 - 1];
                        double x4 = xin[i4];
                        double y4 = yin[i4];
                        int ip4 = 1;
                        TwoLine(xh, yh, x3, y3, xk, yk, x4, y4, out xm, out ym, ref ip4);
                        if (xm != 0.0 || ym != 0.0)
                        {
                            ++i1;
                            nr[i1] = 1;
                            xr[i1] = xm;
                            yr[i1] = ym;
                            double num16 = xm - xh;
                            double num17 = ym - yh;
                            sr[i1] = Math.Sqrt(num16 * num16 + num17 * num17);
                        }
                    }
                }
            }
            if (i1 < 2)
                return;
            for (int i5 = 1; i5 < i1; ++i5)
            {
                for (int i6 = i5 + 1; i6 <= i1; ++i6)
                {
                    if (sr[i5] > sr[i6])
                    {
                        int num18 = nr[i5];
                        double num19 = sr[i5];
                        double num20 = xr[i5];
                        double num21 = yr[i5];
                        nr[i5] = nr[i6];
                        sr[i5] = sr[i6];
                        xr[i5] = xr[i6];
                        yr[i5] = yr[i6];
                        nr[i6] = num18;
                        sr[i6] = num19;
                        xr[i6] = num20;
                        yr[i6] = num21;
                    }
                }
            }
            int ip5 = i1 / 2;
            if (i1 - 2 * ip5 > 0)
            {
                nr[1] = 1;
                xp1 = xr[i1];
                yp1 = yr[i1];
                i1 = 2;
                nr[i1] = 1;
                xr[i1] = xp1;
                yr[i1] = yp1;
            }
            int i7 = 0;
            for (int i8 = 2; i8 <= i1; ++i8)
            {
                for (int i9 = 1; i9 <= k; ++i9)
                {
                    double x1 = x[i9 - 1] - x[i9];
                    double y1 = y[i9 - 1] - y[i9];
                    double dist3 = Math.Sqrt(x1 * x1 + y1 * y1);
                    double num22 = Math.Atan2(y1, x1);
                    if (num22 < 0.0)
                        num22 += 2.0 * num1;
                    double xx1 = 0.5 * (x[i9] + x[i9 - 1]);
                    double yy1 = 0.5 * (y[i9] + y[i9 - 1]);
                    double xx2 = xx1 + 0.25 * dist3 * Math.Cos(num22);
                    double yy2 = yy1 + 0.25 * dist3 * Math.Sin(num22);
                    double xx3 = xx1 - 0.25 * dist3 * Math.Cos(num22);
                    double yy3 = yy1 - 0.25 * dist3 * Math.Sin(num22);
                    DistPnt(xx1, yy1, xr[i8 - 1], yr[i8 - 1], xr[i8], yr[i8], out dist3, out ip5, out xp1, out yp1);
                    DistPnt(xx2, yy2, xr[i8 - 1], yr[i8 - 1], xr[i8], yr[i8], out dist2, out ip2, out xp1, out yp1);
                    DistPnt(xx3, yy3, xr[i8 - 1], yr[i8 - 1], xr[i8], yr[i8], out dist1, out ip1, out xp1, out yp1);
                    if (ip5 > 0 && dist3 < tol && ip2 > 0 && dist2 < tol && ip1 > 0 && dist1 < tol)
                    {
                        int i10 = i7 + 1;
                        xa[i10] = x[i9 - 1];
                        ya[i10] = y[i9 - 1];
                        i7 = i10 + 1;
                        xa[i7] = x[i9];
                        ya[i7] = y[i9];
                    }
                }
            }
            if (kin > 0)
            {
                for (int i11 = 2; i11 <= i1; ++i11)
                {
                    for (int i12 = 1; i12 <= kin; ++i12)
                    {
                        int num23 = kn1[i12];
                        int num24 = kn2[i12];
                        for (int i13 = num23 + 1; i13 <= num24; ++i13)
                        {
                            double num25 = xin[i13 - 1];
                            double num26 = yin[i13 - 1];
                            double num27 = xin[i13];
                            double num28 = yin[i13];
                            double x2 = num27 - num25;
                            double y2 = num28 - num26;
                            double dist4 = Math.Sqrt(x2 * x2 + y2 * y2);
                            double num29 = Math.Atan2(y2, x2);
                            if (num29 < 0.0)
                                num29 += 2.0 * num1;
                            double xx4 = 0.5 * (num25 + num27);
                            double yy4 = 0.5 * (num26 + num28);
                            double xx5 = xx4 + 0.25 * dist4 * Math.Cos(num29);
                            double yy5 = yy4 + 0.25 * dist4 * Math.Sin(num29);
                            double xx6 = xx4 - 0.25 * dist4 * Math.Cos(num29);
                            double yy6 = yy4 - 0.25 * dist4 * Math.Sin(num29);
                            DistPnt(xx4, yy4, xr[i11 - 1], yr[i11 - 1], xr[i11], yr[i11], out dist4, out ip5, out xp1, out yp1);
                            DistPnt(xx5, yy5, xr[i11 - 1], yr[i11 - 1], xr[i11], yr[i11], out dist2, out ip2, out xp1, out yp1);
                            DistPnt(xx6, yy6, xr[i11 - 1], yr[i11 - 1], xr[i11], yr[i11], out dist1, out ip1, out xp1, out yp1);
                            if (ip5 > 0 && dist4 < tol && ip2 > 0 && dist2 < tol && ip1 > 0 && dist1 < tol)
                            {
                                int i14 = i7 + 1;
                                xa[i14] = xin[i13 - 1];
                                ya[i14] = yin[i13 - 1];
                                i7 = i14 + 1;
                                xa[i7] = xin[i13];
                                ya[i7] = yin[i13];
                            }
                        }
                    }
                }
            }
            if (i7 > 0)
            {
                for (int i15 = 1; i15 <= i7; ++i15)
                {
                    ++i1;
                    nr[i1] = 0;
                    xr[i1] = xa[i15];
                    yr[i1] = ya[i15];
                    double num30 = xr[i1] - xh;
                    double num31 = yr[i1] - yh;
                    sr[i1] = Math.Sqrt(num30 * num30 + num31 * num31);
                }
                for (int i16 = 1; i16 < i1; ++i16)
                {
                    ip5 = i16 + 1;
                    for (int i17 = ip5; i17 <= i1; ++i17)
                    {
                        if (sr[i16] > sr[i17])
                        {
                            int num32 = nr[i16];
                            double num33 = sr[i16];
                            double num34 = xr[i16];
                            double num35 = yr[i16];
                            nr[i16] = nr[i17];
                            sr[i16] = sr[i17];
                            xr[i16] = xr[i17];
                            yr[i16] = yr[i17];
                            nr[i17] = num32;
                            sr[i17] = num33;
                            xr[i17] = num34;
                            yr[i17] = num35;
                        }
                    }
                }
            }
            int i18 = 0;
            for (int i19 = 2; i19 <= i1; ++i19)
            {
                double num36 = xr[i19 - 1] - xr[i19];
                double num37 = yr[i19 - 1] - yr[i19];
                double num38 = Math.Sqrt(num36 * num36 + num37 * num37);
                int num39 = 0;
                double dist5;
                for (int i20 = 1; i20 <= k; ++i20)
                {
                    double num40 = x[i20 - 1] - x[i20];
                    double num41 = y[i20 - 1] - y[i20];
                    dist5 = Math.Sqrt(num40 * num40 + num41 * num41) - num38;
                    if (Math.Abs(dist5) <= 0.01)
                    {
                        DistPnt(0.5 * (x[i20] + x[i20 - 1]), 0.5 * (y[i20] + y[i20 - 1]), xr[i19 - 1], yr[i19 - 1], xr[i19], yr[i19], out dist5, out ip5, out xp1, out yp1);
                        if (ip5 > 0 && dist5 < tol)
                        {
                            ++num39;
                            break;
                        }
                    }
                }
                if (num39 <= 0)
                {
                    if (kin > 0)
                    {
                        for (int i21 = 1; i21 <= kin; ++i21)
                        {
                            int num42 = kn1[i21];
                            int num43 = kn2[i21];
                            for (int i22 = num42 + 1; i22 <= num43; ++i22)
                            {
                                double num44 = xin[i22 - 1];
                                double num45 = yin[i22 - 1];
                                double num46 = xin[i22];
                                double num47 = yin[i22];
                                double num48 = num46 - num44;
                                double num49 = num47 - num45;
                                dist5 = Math.Sqrt(num48 * num48 + num49 * num49) - num38;
                                if (Math.Abs(dist5) <= 0.01)
                                {
                                    DistPnt(0.5 * (num44 + num46), 0.5 * (num45 + num47), xr[i19 - 1], yr[i19 - 1], xr[i19], yr[i19], out dist5, out ip5, out xp1, out yp1);
                                    if (ip5 > 0)
                                    {
                                        ++num39;
                                        break;
                                    }
                                }
                            }
                            if (num39 > 0)
                                break;
                        }
                    }
                    if (num39 <= 0)
                    {
                        double num50 = xr[i19 - 1] - xr[i19];
                        double num51 = yr[i19 - 1] - yr[i19];
                        dist5 = Math.Sqrt(num50 * num50 + num51 * num51);
                        if (dist5 >= tol)
                        {
                            xp1 = 0.5 * (xr[i19 - 1] + xr[i19]);
                            yp1 = 0.5 * (yr[i19 - 1] + yr[i19]);
                            ip5 = in_out(k, ref x, ref y, xp1, yp1);
                            if (ip5 != 0)
                            {
                                int num52 = 0;
                                if (kin > 0)
                                {
                                    for (int i23 = 1; i23 <= kin; ++i23)
                                    {
                                        int num53 = kn1[i23];
                                        int num54 = kn2[i23];
                                        int k1 = -1;
                                        for (int i24 = num53; i24 <= num54; ++i24)
                                        {
                                            ++k1;
                                            xa[k1] = xin[i24];
                                            ya[k1] = yin[i24];
                                        }
                                        ip5 = in_out(k1, ref xa, ref ya, xp1, yp1);
                                        if (ip5 > 0)
                                        {
                                            ++num52;
                                            break;
                                        }
                                    }
                                }
                                if (num52 <= 0)
                                {
                                    ++kLin;
                                    int i25 = i18 + 1;
                                    xp[i25] = xr[i19 - 1];
                                    yp[i25] = yr[i19 - 1];
                                    i18 = i25 + 1;
                                    xp[i18] = xr[i19];
                                    yp[i18] = yr[i19];
                                    if (i18 > num11)
                                    {
                                        int num55 = (int)MessageBox.Show("Индекс массива ParcelIntersect");
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            kp1[1] = 1;
            kp2[1] = 2;
            if (kLin <= 1)
                return;
            for (int i26 = 2; i26 <= kLin; ++i26)
            {
                kp1[i26] = kp2[i26 - 1] + 1;
                kp2[i26] = kp2[i26 - 1] + 2;
            }
        }

        public static void PolyArea1(int k, double[] x, double[] y, out double sArea)
        {
            int num1;
            int i1 = num1 = 0;
            double num2;
            double num3 = num2 = 0.0;
            double num4 = num2;
            double num5 = num2;
            double num6 = x[k] - x[1];
            double num7 = y[k] - y[1];
            double num8 = Math.Sqrt(num6 * num6 + num7 * num7);
            if (num8 < 0.1)
                i1 = k - 1;
            if (num8 >= 0.1)
                i1 = k;
            double num9 = 0.0;
            double num10 = 0.0;
            for (int i2 = 1; i2 <= i1; ++i2)
            {
                num9 += x[i2];
                num10 += y[i2];
            }
            double num11 = num9 / (double)i1;
            double num12 = num10 / (double)i1;
            double num13 = 0.0;
            for (int i3 = 1; i3 <= i1; ++i3)
            {
                double num14 = x[i3] - num11;
                if (i3 == 1)
                {
                    num4 = y[i3 + 1] - num12;
                    num5 = y[i1] - num12;
                }
                if (i3 > 1 && i3 < i1)
                {
                    num4 = y[i3 + 1] - num12;
                    num5 = y[i3 - 1] - num12;
                }
                if (i3 == i1)
                {
                    num4 = y[1] - num12;
                    num5 = y[i1 - 1] - num12;
                }
                num13 += num14 * (num4 - num5);
            }
            sArea = 0.5 * Math.Abs(num13);
        }

        public static void PolyLabel1(
          int k,
          ref double[] x,
          ref double[] y,
          ref double[] xr,
          ref double[] yr,
          ref double[] dr,
          out double xc,
          out double yc)
        {
            xc = 0.0;
            yc = 0.0;
            double num1 = 9999999.9;
            double num2 = 9999999.9;
            double num3 = -9999999.9;
            double num4 = -9999999.9;
            for (int i = 1; i <= k; ++i)
            {
                if (x[i] < num1)
                    num1 = x[i];
                if (x[i] > num3)
                    num3 = x[i];
                if (y[i] < num2)
                    num2 = y[i];
                if (y[i] > num4)
                    num4 = y[i];
            }
            double x1 = num1 - 0.1;
            double x2 = num3 + 0.1;
            double y1 = 0.5 * (num2 + num4);
            double y2 = 0.5 * (num2 + num4);
            int i1 = -1;
            double ym;
            for (int i2 = 2; i2 <= k; ++i2)
            {
                double x3 = x[i2 - 1];
                double y3 = y[i2 - 1];
                double x4 = x[i2];
                double y4 = y[i2];
                double num5 = x4 - x3;
                double num6 = y4 - y3;
                if (Math.Sqrt(num5 * num5 + num6 * num6) >= 0.001)
                {
                    int ip = 1;
                    double xm;
                    TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip);
                    if (xm != 0.0 && ym != 0.0)
                    {
                        ++i1;
                        xr[i1] = xm;
                        yr[i1] = ym;
                        double num7 = xm - x1;
                        double num8 = ym - y1;
                        dr[i1] = Math.Sqrt(num7 * num7 + num8 * num8);
                    }
                }
            }
            for (int i3 = 0; i3 < i1; ++i3)
            {
                for (int i4 = i3 + 1; i4 <= i1; ++i4)
                {
                    if (dr[i3] > dr[i4])
                    {
                        double num9 = dr[i3];
                        double num10 = xr[i3];
                        ym = yr[i3];
                        dr[i3] = dr[i4];
                        xr[i3] = xr[i4];
                        yr[i3] = yr[i4];
                        dr[i4] = num9;
                        xr[i4] = num10;
                        yr[i4] = ym;
                    }
                }
            }
            double num11 = 0.0;
            for (int i5 = 1; i5 <= i1; ++i5)
            {
                double xt = 0.5 * (xr[i5 - 1] + xr[i5]);
                ym = 0.5 * (yr[i5 - 1] + yr[i5]);
                if (in_out(k, ref x, ref y, xt, ym) > 0)
                {
                    double num12 = dr[i5] - dr[i5 - 1];
                    if (num12 > num11)
                    {
                        num11 = num12;
                        xc = xt;
                        yc = ym;
                    }
                }
            }
        }

        public static void NearLine(
          int kDir,
          double[] dirAngle,
          int[] ni,
          double dirLine,
          out int numLine,
          int ik)
        {
            numLine = 0;
            double num1 = 3.1415926;
            double num2 = 2.0 * num1;
            int num3 = 43200;
            double num4 = num1 / 21600.0;
            double num5 = num4 + 0.01 * num4;
            double num6 = dirLine;
            if (ik == 1)
            {
                num6 -= num4;
                for (int i1 = 0; i1 <= num3; ++i1)
                {
                    num6 += num4;
                    if (num6 >= num2)
                        num6 -= num2;
                    for (int i2 = 0; i2 <= kDir; ++i2)
                    {
                        if (Math.Abs(dirAngle[i2] - num6) <= num5)
                        {
                            numLine = ni[i2];
                            return;
                        }
                    }
                }
            }
            if (ik != 2)
                return;
            double num7 = num6 + num4;
            for (int i3 = 0; i3 <= num3; ++i3)
            {
                num7 -= num4;
                if (num7 < 0.0)
                    num7 += num2;
                for (int i4 = 0; i4 <= kDir; ++i4)
                {
                    if (Math.Abs(dirAngle[i4] - num7) <= num5)
                    {
                        numLine = ni[i4];
                        return;
                    }
                }
            }
        }

        public static void PolyConstruct(
          double tol,
          int kLin,
          int[] k1,
          int[] k2,
          double[] x,
          double[] y,
          int knd,
          double[] xnd,
          double[] ynd,
          out int kPol,
          double[] xPol,
          double[] yPol,
          double[] sPol,
          double[] sLeg,
          int[] nSymbPol,
          int[] kp1,
          int[] kp2,
          int[] kp,
          double[] xp,
          double[] yp,
          double[] xa,
          double[] ya,
          double[] xb,
          double[] yb,
          double[] xm,
          double[] ym,
          double[] zm,
          int[] ina,
          int[] inb,
          int[] kd1,
          int[] kd2,
          int[] kLoc,
          StatusBarPanel panel1)
        {
            int[] ni = new int[100];
            double[] dirAngle = new double[100];
            int i1 = 0;
            kPol = 0;
            double num1 = 3.1415926;
            int num2;
            int num3 = num2 = 0;
            double num4;
            double yc = num4 = 0.0;
            double xc = num4;
            double sArea = num4;
            int num5;
            int num6 = num5 = 0;
            Cursor.Current = Cursors.WaitCursor;
            if (tol < 0.003)
                tol = 0.003;
            int i2 = knd;
            int i3 = 0;
            for (int i4 = 1; i4 <= kLin; ++i4)
            {
                int num7 = k1[i4];
                int num8 = k2[i4];
                int k = 0;
                for (int i5 = num7; i5 <= num8; ++i5)
                {
                    ++k;
                    xa[k] = x[i5];
                    ya[k] = y[i5];
                }
                double num9 = xa[1] - xa[k];
                double num10 = ya[1] - ya[k];
                if (Math.Sqrt(num9 * num9 + num10 * num10) <= tol)
                {
                    int num11 = 0;
                    PolyLabel1(k, ref xa, ref ya, ref xm, ref ym, ref zm, out xc, out yc);
                    PolyArea1(k, xa, ya, out sArea);
                    if (kPol > 0)
                    {
                        for (int i6 = 1; i6 <= kPol; ++i6)
                        {
                            double num12 = xPol[i6] - xc;
                            double num13 = yPol[i6] - yc;
                            double num14 = Math.Sqrt(num12 * num12 + num13 * num13);
                            double num15 = Math.Abs(sPol[i6] - sArea);
                            if (num14 < 0.2 && num15 < 0.2)
                            {
                                ++num11;
                                break;
                            }
                        }
                    }
                    if (num11 == 0)
                    {
                        ++kPol;
                        xPol[kPol] = xc;
                        yPol[kPol] = yc;
                        sPol[kPol] = sArea;
                        sLeg[kPol] = sArea;
                        kp[kPol] = k;
                        for (int i7 = 1; i7 <= k; ++i7)
                        {
                            ++i1;
                            xp[i1] = xa[i7];
                            yp[i1] = ya[i7];
                        }
                        ++i3;
                        kLoc[i3] = i4;
                        panel1.Text = "Подождите..Полигон =" + string.Format("{0}", (object)kPol);
                    }
                }
            }
            for (int i8 = 1; i8 <= kLin; ++i8)
            {
                int num16 = 0;
                if (i3 > 0)
                {
                    for (int i9 = 1; i9 <= i3; ++i9)
                    {
                        if (kLoc[i9] == i8)
                        {
                            ++num16;
                            break;
                        }
                    }
                }
                if (num16 <= 0)
                {
                    int i10 = k1[i8];
                    int i11 = k2[i8];
                    int num17 = 0;
                    for (int i12 = 1; i12 <= i2; ++i12)
                    {
                        double num18 = xnd[i12] - x[i10];
                        double num19 = ynd[i12] - y[i10];
                        if (Math.Sqrt(num18 * num18 + num19 * num19) < tol)
                        {
                            ++num17;
                            break;
                        }
                    }
                    if (num17 == 0)
                    {
                        ++i2;
                        xnd[i2] = x[i10];
                        ynd[i2] = y[i10];
                    }
                    int num20 = 0;
                    for (int i13 = 1; i13 <= i2; ++i13)
                    {
                        double num21 = xnd[i13] - x[i11];
                        double num22 = ynd[i13] - y[i11];
                        if (Math.Sqrt(num21 * num21 + num22 * num22) < tol)
                        {
                            ++num20;
                            break;
                        }
                    }
                    if (num20 == 0)
                    {
                        ++i2;
                        xnd[i2] = x[i11];
                        ynd[i2] = y[i11];
                    }
                }
            }
            if (i2 > 0)
            {
                for (int i14 = 1; i14 <= i2; ++i14)
                {
                    int i15 = 0;
                    int i16 = 0;
                    num3 = 0;
                    for (int i17 = 1; i17 <= kLin; ++i17)
                    {
                        int i18 = k1[i17];
                        int i19 = k2[i17];
                        double num23 = xnd[i14] - x[i18];
                        double num24 = ynd[i14] - y[i18];
                        if (Math.Sqrt(num23 * num23 + num24 * num24) < tol)
                        {
                            for (int i20 = i18; i20 <= i19; ++i20)
                            {
                                ++i16;
                                xb[i16] = x[i20];
                                yb[i16] = y[i20];
                            }
                            ++i15;
                            ina[i15] = i19 - i18 + 1;
                            inb[i15] = i17;
                        }
                        else
                        {
                            double num25 = xnd[i14] - x[i19];
                            double num26 = ynd[i14] - y[i19];
                            if (Math.Sqrt(num25 * num25 + num26 * num26) < tol)
                            {
                                int i21 = i19 + 1;
                                for (int i22 = i18; i22 <= i19; ++i22)
                                {
                                    --i21;
                                    ++i16;
                                    xb[i16] = x[i21];
                                    yb[i16] = y[i21];
                                }
                                ++i15;
                                ina[i15] = i19 - i18 + 1;
                                inb[i15] = i17;
                            }
                        }
                    }
                    if (i15 != 0)
                    {
                        kd1[1] = 1;
                        kd2[1] = ina[1];
                        for (int i23 = 2; i23 <= i15; ++i23)
                        {
                            kd1[i23] = kd2[i23 - 1] + 1;
                            kd2[i23] = kd2[i23 - 1] + ina[i23];
                        }
                        for (int i24 = 1; i24 <= i15; ++i24)
                        {
                            for (int ik = 1; ik <= 2; ++ik)
                            {
                                int num27 = 0;
                                int k = 0;
                                int num28 = kd1[i24];
                                int num29 = kd2[i24];
                                int num30 = inb[i24];
                                for (int i25 = num28; i25 <= num29; ++i25)
                                {
                                    ++k;
                                    xa[k] = xb[i25];
                                    ya[k] = yb[i25];
                                }
                                int i26 = num27 + 1;
                                kLoc[i26] = num30;
                                for (int i27 = 1; i27 <= kLin; ++i27)
                                {
                                    double x1 = xa[k - 1] - xa[k];
                                    double dirLine = Math.Atan2(ya[k - 1] - ya[k], x1);
                                    if (dirLine < 0.0)
                                        dirLine += 2.0 * num1;
                                    int kDir = -1;
                                    for (int i28 = 1; i28 <= kLin; ++i28)
                                    {
                                        if (i28 != num30)
                                        {
                                            int num31 = 0;
                                            if (i26 > 0)
                                            {
                                                for (int i29 = 1; i29 <= i26; ++i29)
                                                {
                                                    if (kLoc[i29] == i28)
                                                        ++num31;
                                                }
                                            }
                                            if (num31 <= 2)
                                            {
                                                int i30 = k1[i28];
                                                int i31 = k2[i28];
                                                double num32 = xa[k] - x[i30];
                                                double num33 = ya[k] - y[i30];
                                                if (Math.Sqrt(num32 * num32 + num33 * num33) < tol)
                                                {
                                                    ++kDir;
                                                    double x2 = x[i30 + 1] - x[i30];
                                                    double y1 = y[i30 + 1] - y[i30];
                                                    dirAngle[kDir] = Math.Atan2(y1, x2);
                                                    if (dirAngle[kDir] < 0.0)
                                                        dirAngle[kDir] = dirAngle[kDir] + 2.0 * num1;
                                                    ni[kDir] = i28;
                                                }
                                                else
                                                {
                                                    double num34 = xa[k] - x[i31];
                                                    double num35 = ya[k] - y[i31];
                                                    if (Math.Sqrt(num34 * num34 + num35 * num35) < tol)
                                                    {
                                                        ++kDir;
                                                        double x3 = x[i31 - 1] - x[i31];
                                                        double y2 = y[i31 - 1] - y[i31];
                                                        dirAngle[kDir] = Math.Atan2(y2, x3);
                                                        if (dirAngle[kDir] < 0.0)
                                                            dirAngle[kDir] = dirAngle[kDir] + 2.0 * num1;
                                                        ni[kDir] = i28;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (kDir >= 0)
                                    {
                                        int numLine = 0;
                                        if (kDir > 0)
                                            NearLine(kDir, dirAngle, ni, dirLine, out numLine, ik);
                                        if (kDir == 0)
                                            numLine = ni[0];
                                        int i32 = k1[numLine];
                                        int i33 = k2[numLine];
                                        int num36 = 0;
                                        double num37 = xa[k] - x[i32];
                                        double num38 = ya[k] - y[i32];
                                        if (Math.Sqrt(num37 * num37 + num38 * num38) < tol)
                                        {
                                            ++num36;
                                            num30 = numLine;
                                            for (int i34 = i32 + 1; i34 <= i33; ++i34)
                                            {
                                                ++k;
                                                xa[k] = x[i34];
                                                ya[k] = y[i34];
                                            }
                                            ++i26;
                                            kLoc[i26] = numLine;
                                        }
                                        if (num36 == 0)
                                        {
                                            double num39 = xa[k] - x[i33];
                                            double num40 = ya[k] - y[i33];
                                            if (Math.Sqrt(num39 * num39 + num40 * num40) < tol)
                                            {
                                                num30 = numLine;
                                                int i35 = i33;
                                                for (int i36 = i32; i36 < i33; ++i36)
                                                {
                                                    --i35;
                                                    ++k;
                                                    xa[k] = x[i35];
                                                    ya[k] = y[i35];
                                                }
                                                ++i26;
                                                kLoc[i26] = numLine;
                                            }
                                        }
                                        double num41 = xa[1] - xa[k];
                                        double num42 = ya[1] - ya[k];
                                        if (Math.Sqrt(num41 * num41 + num42 * num42) <= tol)
                                        {
                                            int num43 = 0;
                                            PolyLabel1(k, ref xa, ref ya, ref xm, ref ym, ref zm, out xc, out yc);
                                            PolyArea1(k, xa, ya, out sArea);
                                            if (kPol > 0)
                                            {
                                                for (int i37 = 1; i37 <= kPol; ++i37)
                                                {
                                                    double num44 = xPol[i37] - xc;
                                                    double num45 = yPol[i37] - yc;
                                                    double num46 = Math.Sqrt(num44 * num44 + num45 * num45);
                                                    double num47 = Math.Abs(sPol[i37] - sArea);
                                                    if (num46 < 0.05 && num47 < 0.05)
                                                    {
                                                        ++num43;
                                                        break;
                                                    }
                                                }
                                            }
                                            if (num43 == 0)
                                            {
                                                ++kPol;
                                                xPol[kPol] = xc;
                                                yPol[kPol] = yc;
                                                sPol[kPol] = sArea;
                                                sLeg[kPol] = sArea;
                                                kp[kPol] = k;
                                                for (int i38 = 1; i38 <= k; ++i38)
                                                {
                                                    ++i1;
                                                    xp[i1] = xa[i38];
                                                    yp[i1] = ya[i38];
                                                }
                                                panel1.Text = "Подождите..Полигон =" + string.Format("{0}", (object)kPol);
                                                break;
                                            }
                                            break;
                                        }
                                    }
                                    else
                                        break;
                                }
                            }
                        }
                    }
                }
            }
            panel1.Text = "Подождите..Полигон=" + string.Format("{0}", (object)kPol);
            kp1[1] = 1;
            kp2[1] = kp[1];
            nSymbPol[1] = 0;
            if (kPol <= 1)
                return;
            for (int i39 = 2; i39 <= kPol; ++i39)
            {
                nSymbPol[i39] = 0;
                kp1[i39] = kp2[i39 - 1] + 1;
                kp2[i39] = kp2[i39 - 1] + kp[i39];
            }
        }

        public static void PolygonLabel(
          int k,
          ref double[] x,
          ref double[] y,
          int kin,
          ref int[] k1,
          ref int[] k2,
          ref double[] xin,
          ref double[] yin,
          out double xpol,
          out double ypol,
          ref double[] xr,
          ref double[] yr,
          ref double[] zr,
          ref double[] xd,
          ref double[] yd,
          ref double[] zd)
        {
            double xx = 0.0;
            double yy = 0.0;
            double num1 = 0.0;
            double tol = 0.005;
            int[] nr = new int[100];
            int[] kp1 = new int[100];
            int[] kp2 = new int[100];
            double[] xp1 = new double[100];
            double[] yp1 = new double[100];
            double num2;
            double num3 = num2 = 0.0;
            double num4;
            double num5 = num4 = 0.0;
            xpol = 0.0;
            ypol = 0.0;
            double num6 = 9999999.9;
            double num7 = 9999999.9;
            double num8 = -9999999.9;
            double num9 = -9999999.9;
            for (int i = 1; i <= k; ++i)
            {
                if (x[i] < num6)
                    num6 = x[i];
                if (x[i] > num8)
                    num8 = x[i];
                if (y[i] < num7)
                    num7 = y[i];
                if (y[i] > num9)
                    num9 = y[i];
            }
            double yp2 = num9 - num7;
            num5 = num8 - num6;
            double yh1 = num7 - 1.0;
            double yk1 = num9 + 1.0;
            double xp2 = num8 - num6;
            double num10 = 0.5 * (num6 + num8);
            double xh1 = num10 - 0.4 * xp2;
            num3 = num10 + 0.4 * xp2;
            double num11 = 0.04 * xp2;
            double num12 = 0.0;
            int kLin;
            for (int i1 = 1; i1 < 20; ++i1)
            {
                xh1 += num11;
                double xk = xh1;
                kLin = 0;
                num1 = 0.0;
                ParcelIntersect(xh1, yh1, xk, yk1, k, ref x, ref y, kin, ref k1, ref k2, ref xin, ref yin, out kLin, ref kp1, ref kp2, ref xp1, ref yp1, ref xr, ref yr, ref zr, ref xd, ref yd, ref nr, tol);
                if (kLin != 0)
                {
                    for (int i2 = 1; i2 <= kLin; ++i2)
                    {
                        int i3 = kp1[i2];
                        int i4 = kp2[i2];
                        xp2 = xp1[i4] - xp1[i3];
                        yp2 = yp1[i4] - yp1[i3];
                        double num13 = Math.Sqrt(xp2 * xp2 + yp2 * yp2);
                        if (num13 > num12)
                        {
                            num12 = num13;
                            xpol = 0.5 * (xp1[i4] + xp1[i3]);
                            ypol = 0.5 * (yp1[i4] + yp1[i3]);
                            xx = xpol;
                            yy = ypol;
                        }
                    }
                }
            }
            double xh2 = num6 - 1.0;
            double xk1 = num8 + 1.0;
            double yh2 = yy;
            double yk2 = yh2;
            kLin = 0;
            double dist = 0.0;
            ParcelIntersect(xh2, yh2, xk1, yk2, k, ref x, ref y, kin, ref k1, ref k2, ref xin, ref yin, out kLin, ref kp1, ref kp2, ref xp1, ref yp1, ref xr, ref yr, ref zr, ref xd, ref yd, ref nr, tol);
            if (kLin == 0)
                return;
            for (int i5 = 1; i5 <= kLin; ++i5)
            {
                int i6 = kp1[i5];
                int i7 = kp2[i5];
                int ip = 0;
                DistPnt(xx, yy, xp1[i6], yp1[i6], xp1[i7], yp1[i7], out dist, out ip, out xp2, out yp2);
                if (ip > 0)
                {
                    xpol = 0.5 * (xp1[i7] + xp1[i6]);
                    ypol = 0.5 * (yp1[i7] + yp1[i6]);
                    break;
                }
            }
        }

        public static void TolerSum(
          int knum,
          ref int[] ind,
          ref double[] aDat,
          int ka,
          ref int[] kai,
          ref int[] kac,
          out double toler)
        {
            int[] numArray1 = new int[10];
            int[] numArray2 = new int[10];
            double[] numArray3 = new double[10];
            toler = 0.0;
            int num1;
            int num2 = num1 = 0;
            double num3;
            double num4 = num3 = 0.0;
            int i1 = 0;
            int i2 = 0;
            for (int i3 = 1; i3 <= ka; ++i3)
            {
                if (kac[i3] == 42)
                {
                    num3 = aDat[i3] * aDat[i3 + 1];
                    int i4 = i1 + 1;
                    numArray1[i4] = i3;
                    i1 = i4 + 1;
                    numArray1[i1] = i3 + 1;
                    ++i2;
                    numArray3[i2] = num3;
                    numArray2[i2] = i3;
                }
                if (kac[i3] == 47)
                {
                    if (aDat[i3 + 1] != 0.0)
                        num3 = aDat[i3] / aDat[i3 + 1];
                    if (aDat[i3 + 1] == 0.0)
                        num3 = aDat[i3];
                    int i5 = i1 + 1;
                    numArray1[i5] = i3;
                    i1 = i5 + 1;
                    numArray1[i1] = i3 + 1;
                    ++i2;
                    numArray3[i2] = num3;
                    numArray2[i2] = i3;
                }
            }
            if (i2 > 0)
            {
                for (int i6 = 1; i6 < knum; ++i6)
                {
                    int num5 = 0;
                    for (int i7 = 1; i7 < i1; ++i7)
                    {
                        if (numArray1[i7] == i6)
                        {
                            ++num5;
                            break;
                        }
                    }
                    if (num5 == 0)
                    {
                        ++i2;
                        numArray3[i2] = aDat[i6];
                        numArray2[i2] = i6;
                    }
                }
                if (i2 > 1)
                {
                    for (int i8 = 1; i8 < i2; ++i8)
                    {
                        for (int i9 = i8 + 1; i9 <= i2; ++i9)
                        {
                            if (numArray2[i8] > numArray2[i9])
                            {
                                int num6 = numArray2[i8];
                                double num7 = numArray3[i8];
                                numArray2[i8] = numArray2[i9];
                                numArray3[i8] = numArray3[i9];
                                numArray2[i9] = num6;
                                numArray3[i9] = num7;
                            }
                        }
                    }
                }
                knum = i2;
                for (int i10 = 1; i10 <= i2; ++i10)
                {
                    ind[i10] = numArray2[i10];
                    aDat[i10] = numArray3[i10];
                }
                int i11 = 0;
                for (int i12 = 1; i12 <= ka; ++i12)
                {
                    if (kac[i12] != 42 && kac[i12] != 47)
                    {
                        ++i11;
                        kai[i11] = kai[i12];
                        kac[i11] = kac[i12];
                    }
                }
                ka = i11;
            }
            if (knum == 1)
            {
                toler = aDat[1];
            }
            else
            {
                double num8 = 0.0;
                for (int i13 = 1; i13 <= ka; ++i13)
                {
                    if (kac[i13] == 43)
                    {
                        double num9 = aDat[i13] + aDat[i13 + 1];
                        num8 += num9;
                    }
                    if (kac[i13] == 45)
                    {
                        double num10 = aDat[i13] - aDat[i13 + 1];
                        num8 += num10;
                    }
                }
                toler = num8;
            }
        }

        public static void TolerForm3(int k, ref char[] sTemp, double A, out double aNum)
        {
            char[] sTemp1 = new char[20];
            int[] k1 = new int[10];
            int[] k2 = new int[10];
            int[] kac = new int[10];
            int[] kai = new int[10];
            int[] ksm = new int[10];
            int[] ksi = new int[10];
            int[] ind = new int[10];
            double[] aDat = new double[10];
            double d = 0.0;
            aNum = 0.0;
            int kt;
            int ka;
            int ks;
            TolerAction(k, ref sTemp, out kt, ref k1, ref k2, out ka, ref kai, ref kac, out ks, ref ksi, ref ksm);
            int knum = 0;
            if (kt > 0)
            {
                for (int i1 = 1; i1 <= kt; ++i1)
                {
                    int i2 = k1[i1];
                    int num1 = k2[i1];
                    int num2 = i2;
                    int num3 = (int)sTemp[i2];
                    if (num3 == 83 || num3 == 115)
                        num2 = i2 + 5;
                    if (num3 == 40)
                        num2 = i2 + 1;
                    int i3 = -1;
                    for (int i4 = num2; i4 < num1; ++i4)
                    {
                        ++i3;
                        sTemp1[i3] = sTemp[i4];
                    }
                    int k3 = i3 + 1;
                    sTemp1[k3] = char.MinValue;
                    TolerForm4(k3, ref sTemp1, A, out d);
                    if (num3 == 83 || num3 == 115)
                        d = Math.Sqrt(d);
                    ++knum;
                    ind[knum] = k1[i1];
                    aDat[knum] = d;
                }
            }
            if (ks > 0)
            {
                for (int i5 = 1; i5 <= ks; ++i5)
                {
                    int num4 = ksm[i5];
                    if (num4 > 47 && num4 < 58)
                    {
                        int num5 = ksi[i5];
                        int i6 = -1;
                        for (int i7 = num5; i7 <= k; ++i7)
                        {
                            switch (sTemp[i7])
                            {
                                case '.':
                                    ++i6;
                                    sTemp1[i6] = sTemp[i7];
                                    break;
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                    ++i6;
                                    sTemp1[i6] = sTemp[i7];
                                    break;
                                default:
                                    goto label_22;
                            }
                        }
                    label_22:
                        int km = i6 + 1;
                        sTemp1[km] = char.MinValue;
                        TolerForm1(km, ref sTemp, out d);
                        ++knum;
                        ind[knum] = ksi[i5];
                        aDat[knum] = d;
                    }
                    if (num4 == 65 || num4 == 97)
                    {
                        ++knum;
                        ind[knum] = ksi[i5];
                        aDat[knum] = A;
                    }
                }
            }
            for (int i8 = 1; i8 < knum; ++i8)
            {
                for (int i9 = i8 + 1; i9 <= knum; ++i9)
                {
                    if (ind[i8] > ind[i9])
                    {
                        int num = ind[i8];
                        d = aDat[i8];
                        ind[i8] = ind[i9];
                        aDat[i8] = aDat[i9];
                        ind[i9] = num;
                        aDat[i9] = d;
                    }
                }
            }
            TolerSum(knum, ref ind, ref aDat, ka, ref kai, ref kac, out d);
            aNum = d;
        }

        public static void TolerAction(
          int k,
          ref char[] sFormula,
          out int kt,
          ref int[] k1,
          ref int[] k2,
          out int ka,
          ref int[] kai,
          ref int[] kac,
          out int ks,
          ref int[] ksi,
          ref int[] ksm)
        {
            kt = 0;
            ka = 0;
            ks = 0;
            int num1;
            int num2 = num1 = 0;
            int num3;
            int num4 = num3 = 0;
            int i1 = 0;
            switch (sFormula[i1])
            {
                case '*':
                case '+':
                case '-':
                case '/':
                    ++i1;
                    break;
            }
            int num5 = 0;
            int num6 = 0;
            int i2 = 0;
            for (int i3 = i1; i3 <= k; ++i3)
            {
                int num7 = (int)sFormula[i3];
                if (num7 == 40)
                {
                    ++num5;
                    if (num5 == 1)
                        num2 = i3;
                }
                if (num7 == 41)
                {
                    ++num6;
                    if (num5 == num6)
                    {
                        int num8 = i3;
                        ++i2;
                        k1[i2] = num2;
                        switch (sFormula[num2 - 4])
                        {
                            case 'S':
                            case 's':
                                k1[i2] = num2 - 4;
                                break;
                        }
                        k2[i2] = num8;
                        num5 = 0;
                        num6 = 0;
                    }
                }
            }
            kt = i2;
            ks = 0;
            int i4 = 0;
            int num9 = (int)sFormula[i1];
            switch (num9)
            {
                case 83:
                case 115:
                    ka = 0;
                    int i5 = 0;
                    for (int i6 = i1; i6 < k; ++i6)
                    {
                        int num10 = (int)sFormula[i6];
                        switch (num10)
                        {
                            case 42:
                            case 43:
                            case 45:
                            case 47:
                                if (kt > 0)
                                {
                                    int num11 = 0;
                                    for (int i7 = 1; i7 <= i2; ++i7)
                                    {
                                        if (i6 > k1[i7] && i6 < k2[i7])
                                        {
                                            ++num11;
                                            break;
                                        }
                                    }
                                    if (num11 > 0)
                                        break;
                                }
                                ++i5;
                                kai[i5] = i6;
                                kac[i5] = num10;
                                if (i6 < k)
                                {
                                    int num12 = (int)sFormula[i6 + 1];
                                    switch (num12)
                                    {
                                        case 40:
                                        case 83:
                                        case 115:
                                            continue;
                                        default:
                                            ++i4;
                                            ksi[i4] = i6 + 1;
                                            ksm[i4] = num12;
                                            continue;
                                    }
                                }
                                else
                                    break;
                        }
                    }
                    ka = i5;
                    ks = i4;
                    break;
                default:
                    ++i4;
                    ksi[i4] = i1;
                    ksm[i4] = num9;
                    goto case 83;
            }
        }

        public static void TolerForm2(int k, ref char[] sTemp, double A, out double aNum)
        {
            char[] sTemp1 = new char[20];
            int[] k1 = new int[10];
            int[] k2 = new int[10];
            int[] kac = new int[10];
            int[] kai = new int[10];
            int[] ksm = new int[10];
            int[] ksi = new int[10];
            int[] ind = new int[10];
            double d = 0.0;
            double[] aDat = new double[10];
            aNum = 0.0;
            int kt;
            int ka;
            int ks;
            TolerAction(k, ref sTemp, out kt, ref k1, ref k2, out ka, ref kai, ref kac, out ks, ref ksi, ref ksm);
            int knum = 0;
            if (kt > 0)
            {
                for (int i1 = 1; i1 <= kt; ++i1)
                {
                    int i2 = k1[i1];
                    int num1 = k2[i1];
                    int num2 = i2;
                    int num3 = (int)sTemp[i2];
                    if (num3 == 83 || num3 == 115)
                        num2 = i2 + 5;
                    if (num3 == 40)
                        num2 = i2 + 1;
                    int i3 = -1;
                    for (int i4 = num2; i4 < num1; ++i4)
                    {
                        ++i3;
                        sTemp1[i3] = sTemp[i4];
                    }
                    int k3 = i3 + 1;
                    sTemp1[k3] = char.MinValue;
                    TolerForm3(k3, ref sTemp1, A, out d);
                    if (num3 == 83 || num3 == 115)
                        d = Math.Sqrt(d);
                    ++knum;
                    ind[knum] = k1[i1];
                    aDat[knum] = d;
                }
            }
            if (ks > 0)
            {
                for (int i5 = 1; i5 <= ks; ++i5)
                {
                    int num4 = ksm[i5];
                    if (num4 > 47 && num4 < 58)
                    {
                        int num5 = ksi[i5];
                        int i6 = -1;
                        for (int i7 = num5; i7 <= k; ++i7)
                        {
                            switch (sTemp[i7])
                            {
                                case '.':
                                    ++i6;
                                    sTemp1[i6] = sTemp[i7];
                                    break;
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                    ++i6;
                                    sTemp1[i6] = sTemp[i7];
                                    break;
                                default:
                                    goto label_22;
                            }
                        }
                    label_22:
                        int km = i6 + 1;
                        sTemp1[km] = char.MinValue;
                        TolerForm1(km, ref sTemp1, out d);
                        ++knum;
                        ind[knum] = ksi[i5];
                        aDat[knum] = d;
                    }
                    if (num4 == 65 || num4 == 97)
                    {
                        ++knum;
                        ind[knum] = ksi[i5];
                        aDat[knum] = A;
                    }
                }
            }
            for (int i8 = 1; i8 < knum; ++i8)
            {
                for (int i9 = i8 + 1; i9 <= knum; ++i9)
                {
                    if (ind[i8] > ind[i9])
                    {
                        int num = ind[i8];
                        d = aDat[i8];
                        ind[i8] = ind[i9];
                        aDat[i8] = aDat[i9];
                        ind[i9] = num;
                        aDat[i9] = d;
                    }
                }
            }
            TolerSum(knum, ref ind, ref aDat, ka, ref kai, ref kac, out d);
            aNum = d;
        }

        public static void TolerForm1(int km, ref char[] sTemp, out double aNum)
        {
            char[] chArray = new char[10];
            int num1;
            int num2 = num1 = 0;
            aNum = 0.0;
            int i1 = -1;
            for (int i2 = 0; i2 <= km; ++i2)
            {
                int num3 = (int)sTemp[i2];
                if (num3 > 47 && num3 < 58)
                {
                    ++i1;
                    chArray[i1] = sTemp[i2];
                }
                if (num3 == 46)
                {
                    ++i1;
                    chArray[i1] = sTemp[i2];
                }
                if (num3 < 46 || num3 > 57)
                    break;
            }
            int i3 = i1 + 1;
            chArray[i3] = char.MinValue;
            string str = "";
            for (int i4 = 0; i4 < chArray.Length; ++i4)
                str += Convert.ToString(chArray[i4]);
            aNum = Convert.ToDouble(str);
        }

        public static void NodeFirst(
          int kPnt,
          ref double[] xpn,
          ref double[] ypn,
          int kLin,
          ref int[] k1,
          ref int[] k2,
          ref double[] x,
          ref double[] y,
          out int kn,
          ref double[] xn,
          ref double[] yn,
          double tol,
          ref int[] nLine)
        {
            double num1;
            double num2 = num1 = 0.0;
            int num3 = num3 = 0;
            kn = 0;
            if (tol < 0.003)
                tol = 0.003;
            int kArray = 999999;
            doubleArray(xn, ref kArray);
            doubleArray(yn, ref kArray);
            int num4 = kArray - 3;
            for (int i1 = 0; i1 <= kPnt; ++i1)
            {
                nLine[i1] = 0;
                for (int i2 = 1; i2 <= kLin; ++i2)
                {
                    int i3 = k1[i2];
                    int i4 = k2[i2];
                    double num5 = xpn[i1] - x[i3];
                    double num6 = ypn[i1] - y[i3];
                    if (Math.Sqrt(num5 * num5 + num6 * num6) < tol)
                        ++nLine[i1];
                    double num7 = xpn[i1] - x[i4];
                    double num8 = ypn[i1] - y[i4];
                    if (Math.Sqrt(num7 * num7 + num8 * num8) < tol)
                        ++nLine[i1];
                }
            }
            for (int i = 0; i <= kPnt; ++i)
            {
                if (nLine[i] > 2)
                {
                    ++kn;
                    xn[kn] = xpn[i];
                    yn[kn] = ypn[i];
                    if (kn > num4)
                    {
                        int num9 = (int)MessageBox.Show("Индекс массива NodeFirst");
                        break;
                    }
                }
            }
        }

        public static void NodeTopo(
          int kLin,
          ref int[] k1,
          ref int[] k2,
          ref double[] x,
          ref double[] y,
          out int knd,
          ref double[] xnd,
          ref double[] ynd,
          double tol,
          StatusBarPanel panel1)
        {
            double dist = 0.0;
            double yp;
            double xp = yp = 0.0;
            double num1;
            double num2 = num1 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            double num5;
            double num6 = num5 = 0.0;
            int num7;
            int ip = num7 = 0;
            knd = 0;
            Cursor.Current = Cursors.WaitCursor;
            if (tol < 0.003)
                tol = 0.003;
            panel1.Text = "Подождите.. Топология узла";
            for (int i1 = 1; i1 <= kLin; ++i1)
            {
                panel1.Text = "Подождите.. Проверьте пересечение =" + string.Format("{0}", (object)i1);
                int i2 = k1[i1];
                int i3 = k2[i1];
                for (int i4 = i2 + 1; i4 <= i3; ++i4)
                {
                    double x1 = x[i4 - 1];
                    double y1 = y[i4 - 1];
                    double x2 = x[i4];
                    double y2 = y[i4];
                    for (int i5 = 1; i5 <= kLin; ++i5)
                    {
                        if (i1 != i5)
                        {
                            int i6 = k1[i5];
                            int i7 = k2[i5];
                            double num8 = x[i2] - x[i6];
                            double num9 = y[i2] - y[i6];
                            if (Math.Sqrt(num8 * num8 + num9 * num9) >= tol)
                            {
                                double num10 = x[i2] - x[i7];
                                double num11 = y[i2] - y[i7];
                                if (Math.Sqrt(num10 * num10 + num11 * num11) >= tol)
                                {
                                    double num12 = x[i3] - x[i6];
                                    double num13 = y[i3] - y[i6];
                                    if (Math.Sqrt(num12 * num12 + num13 * num13) >= tol)
                                    {
                                        double num14 = x[i3] - x[i7];
                                        double num15 = y[i3] - y[i7];
                                        if (Math.Sqrt(num14 * num14 + num15 * num15) >= tol)
                                        {
                                            for (int i8 = i6 + 1; i8 <= i7; ++i8)
                                            {
                                                double x3 = x[i8 - 1];
                                                double y3 = y[i8 - 1];
                                                double x4 = x[i8];
                                                double y4 = y[i8];
                                                ip = 1;
                                                double xm = 0.0;
                                                double ym = 0.0;
                                                TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip);
                                                if (xm != 0.0 || ym != 0.0)
                                                {
                                                    ip = 0;
                                                    if (knd > 0)
                                                    {
                                                        for (int i9 = 1; i9 <= knd; ++i9)
                                                        {
                                                            double num16 = xnd[i9] - xm;
                                                            double num17 = ynd[i9] - ym;
                                                            if (Math.Sqrt(num16 * num16 + num17 * num17) < tol)
                                                            {
                                                                ++ip;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    if (ip <= 0)
                                                    {
                                                        ++knd;
                                                        xnd[knd] = xm;
                                                        ynd[knd] = ym;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            for (int i10 = 1; i10 <= kLin; ++i10)
            {
                panel1.Text = "Подождите..Проверьте конечную строку на линии =" + string.Format("{0}", (object)i10);
                int num18 = k1[i10];
                int num19 = k2[i10];
                for (int i11 = num18 + 1; i11 <= num19; ++i11)
                {
                    double x1 = x[i11 - 1];
                    double y1 = y[i11 - 1];
                    double x2 = x[i11];
                    double y2 = y[i11];
                    for (int i12 = 1; i12 <= kLin; ++i12)
                    {
                        if (i10 != i12)
                        {
                            int i13 = k1[i12];
                            int i14 = k2[i12];
                            double num20 = x1 - x[i13];
                            double num21 = y1 - y[i13];
                            if (Math.Sqrt(num20 * num20 + num21 * num21) >= tol)
                            {
                                double num22 = x2 - x[i13];
                                double num23 = y2 - y[i13];
                                if (Math.Sqrt(num22 * num22 + num23 * num23) >= tol)
                                {
                                    double num24 = x1 - x[i14];
                                    double num25 = y1 - y[i14];
                                    if (Math.Sqrt(num24 * num24 + num25 * num25) >= tol)
                                    {
                                        double num26 = x2 - x[i14];
                                        double num27 = y2 - y[i14];
                                        if (Math.Sqrt(num26 * num26 + num27 * num27) >= tol)
                                        {
                                            DistPnt(x[i13], y[i13], x1, y1, x2, y2, out dist, out ip, out xp, out yp);
                                            if (ip > 0 && dist < tol)
                                            {
                                                int num28 = 0;
                                                if (knd > 0)
                                                {
                                                    for (int i15 = 1; i15 <= knd; ++i15)
                                                    {
                                                        double num29 = xnd[i15] - xp;
                                                        double num30 = ynd[i15] - yp;
                                                        if (Math.Sqrt(num29 * num29 + num30 * num30) < tol)
                                                        {
                                                            ++num28;
                                                            break;
                                                        }
                                                    }
                                                }
                                                if (num28 == 0)
                                                {
                                                    ++knd;
                                                    xnd[knd] = xp;
                                                    ynd[knd] = yp;
                                                    x[i13] = xp;
                                                    y[i13] = yp;
                                                }
                                            }
                                            DistPnt(x[i14], y[i14], x1, y1, x2, y2, out dist, out ip, out xp, out yp);
                                            if (ip > 0 && dist < tol)
                                            {
                                                int num31 = 0;
                                                if (knd > 0)
                                                {
                                                    for (int i16 = 1; i16 <= knd; ++i16)
                                                    {
                                                        double num32 = xnd[i16] - xp;
                                                        double num33 = ynd[i16] - yp;
                                                        if (Math.Sqrt(num32 * num32 + num33 * num33) < tol)
                                                        {
                                                            ++num31;
                                                            break;
                                                        }
                                                    }
                                                }
                                                if (num31 == 0)
                                                {
                                                    ++knd;
                                                    xnd[knd] = xp;
                                                    ynd[knd] = yp;
                                                    x[i14] = xp;
                                                    y[i14] = yp;
                                                    panel1.Text = "Подождите.. Топология узла =" + string.Format("{0}", (object)knd);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void NodeTopology(
          double tolerance,
          int kPnt,
          ref double[] xPnt,
          ref double[] yPnt,
          int kNew,
          ref int[] kt1,
          ref int[] kt2,
          ref double[] xWork1,
          ref double[] yWork1,
          out int kNode,
          ref double[] xNode,
          ref double[] yNode,
          ref int[] nWork,
          ref double[] xDop,
          ref double[] yDop,
          out int knd,
          ref double[] xPik,
          ref double[] yPik,
          StatusBarPanel panel1)
        {
            int kn = 0;
            double num1;
            double num2 = num1 = 0.0;
            knd = 0;
            kNode = 0;
            panel1.Text = "Подождите... Топология узла";
            int kArray1 = 999999;
            doubleArray(xPnt, ref kArray1);
            doubleArray(yPnt, ref kArray1);
            if (kPnt > kArray1)
            {
                int num3 = (int)MessageBox.Show("Индекс массива NodeTopology");
            }
            else
            {
                int kArray2 = 999999;
                intArray(kt1, ref kArray2);
                intArray(kt2, ref kArray2);
                if (kNew > kArray2)
                {
                    int num4 = (int)MessageBox.Show("Индекс массива NodeTopology");
                }
                else
                {
                    int kArray3 = 999999;
                    int num5 = kt2[kNew];
                    doubleArray(xWork1, ref kArray3);
                    doubleArray(yWork1, ref kArray3);
                    doubleArray(xDop, ref kArray3);
                    doubleArray(yDop, ref kArray3);
                    doubleArray(xPik, ref kArray3);
                    doubleArray(yPik, ref kArray3);
                    intArray(nWork, ref kArray3);
                    if (num5 > kArray3)
                    {
                        int num6 = (int)MessageBox.Show("Индекс массива NodeTopology");
                    }
                    else
                    {
                        kArray3 = 999999;
                        doubleArray(xNode, ref kArray3);
                        doubleArray(yNode, ref kArray3);
                        NodeFirst(kPnt, ref xPnt, ref yPnt, kNew, ref kt1, ref kt2, ref xWork1, ref yWork1, out kn, ref xNode, ref yNode, tolerance, ref nWork);
                        kNode = kn;
                        panel1.Text = "Подождите...Узел = " + string.Format("{0}", (object)kNode);
                        NodeTopo(kNew, ref kt1, ref kt2, ref xWork1, ref yWork1, out knd, ref xPik, ref yPik, tolerance, panel1);
                        panel1.Text = "Подождите...Узел = " + string.Format("{0}", (object)knd);
                        if (knd > 0 && kn > 0)
                        {
                            for (int i1 = 1; i1 <= knd; ++i1)
                            {
                                int num7 = 0;
                                for (int i2 = 1; i2 <= kn; ++i2)
                                {
                                    double num8 = xNode[i2] - xPik[i1];
                                    double num9 = yNode[i2] - yPik[i1];
                                    if (Math.Sqrt(num8 * num8 + num9 * num9) <= tolerance)
                                    {
                                        ++num7;
                                        break;
                                    }
                                }
                                if (num7 <= 0)
                                {
                                    ++kn;
                                    if (kn > kArray3)
                                    {
                                        int num10 = (int)MessageBox.Show("Индекс массива NodeTopology");
                                        return;
                                    }
                                    xNode[kn] = xPik[i1];
                                    yNode[kn] = yPik[i1];
                                }
                            }
                            kNode = kn;
                        }
                        if (knd <= 0 || kn != 0)
                            return;
                        for (int i = 1; i <= knd; ++i)
                        {
                            ++kNode;
                            if (kNode > kArray3)
                            {
                                int num11 = (int)MessageBox.Show("Индекс массива NodeTopology");
                                kNode = 0;
                                break;
                            }
                            xNode[kNode] = xPik[i];
                            yNode[kNode] = yPik[i];
                        }
                    }
                }
            }
        }

        public static void LineDivide(
          int kLin,
          ref double[] rad,
          ref int[] k1,
          ref int[] k2,
          ref double[] x,
          ref double[] y,
          int knd,
          ref double[] xnd,
          ref double[] ynd,
          out int kNew,
          ref double[] rNew,
          ref int[] kn1,
          ref int[] kn2,
          ref int[] kn,
          ref double[] xn,
          ref double[] yn,
          double tol,
          StatusBarPanel panel1)
        {
            int[] numArray1 = new int[200];
            double[] numArray2 = new double[200];
            double[] numArray3 = new double[200];
            double[] numArray4 = new double[200];
            double dist = 0.0;
            int num1;
            int num2 = num1 = 0;
            int num3;
            int num4 = num3 = 0;
            int ip = num3;
            int num5 = num3;
            double num6;
            double num7 = num6 = 0.0;
            double yp;
            double xp = yp = 0.0;
            kNew = 0;
            Cursor.Current = Cursors.WaitCursor;
            if (tol < 0.003)
                tol = 0.003;
            int kArray = 999999;
            doubleArray(xnd, ref kArray);
            doubleArray(ynd, ref kArray);
            if (knd > kArray)
            {
                int num8 = (int)MessageBox.Show("Индекс массива LineDivide");
            }
            else
            {
                kArray = 999999;
                intArray(k1, ref kArray);
                intArray(k2, ref kArray);
                intArray(kn1, ref kArray);
                intArray(kn2, ref kArray);
                doubleArray(rad, ref kArray);
                doubleArray(rNew, ref kArray);
                if (kLin > kArray)
                {
                    int num9 = (int)MessageBox.Show("Индекс массива LineDivide");
                }
                else
                {
                    kArray = 999999;
                    int num10 = k2[kLin];
                    doubleArray(x, ref kArray);
                    doubleArray(y, ref kArray);
                    doubleArray(xn, ref kArray);
                    doubleArray(yn, ref kArray);
                    if (num10 > kArray)
                    {
                        int num11 = (int)MessageBox.Show("Индекс массива LineDivide");
                    }
                    else
                    {
                        panel1.Text = "Подождите... Разделение линии";
                        int i1 = 0;
                        for (int i2 = 1; i2 <= kLin; ++i2)
                        {
                            panel1.Text = "Подождите..Топология Линий =" + string.Format("{0}", (object)kNew);
                            int i3 = k1[i2];
                            int i4 = k2[i2];
                            if (knd == 0)
                            {
                                int num12 = 0;
                                for (int i5 = i3; i5 <= i4; ++i5)
                                {
                                    ++num12;
                                    ++i1;
                                    xn[i1] = x[i5];
                                    yn[i1] = y[i5];
                                }
                                ++kNew;
                                kn[kNew] = num12;
                                rNew[kNew] = rad[i2];
                            }
                            else
                            {
                                int i6 = 1;
                                numArray1[i6] = i3;
                                numArray2[i6] = x[i3];
                                numArray3[i6] = y[i3];
                                numArray4[i6] = 0.0;
                                if (knd > 0)
                                {
                                    for (int i7 = i3 + 1; i7 <= i4; ++i7)
                                    {
                                        double x1 = x[i7 - 1];
                                        double y1 = y[i7 - 1];
                                        double x2 = x[i7];
                                        double y2 = y[i7];
                                        for (int i8 = 1; i8 <= knd; ++i8)
                                        {
                                            double num13 = xnd[i8] - x2;
                                            double num14 = ynd[i8] - y2;
                                            if (Math.Sqrt(num13 * num13 + num14 * num14) < tol)
                                            {
                                                int num15 = 0;
                                                for (int i9 = 1; i9 <= i6; ++i9)
                                                {
                                                    double num16 = x2 - numArray2[i9];
                                                    double num17 = y2 - numArray3[i9];
                                                    if (Math.Sqrt(num16 * num16 + num17 * num17) < tol)
                                                    {
                                                        ++num15;
                                                        break;
                                                    }
                                                }
                                                if (num15 <= 0)
                                                {
                                                    ++i6;
                                                    numArray1[i6] = i7;
                                                    numArray2[i6] = xnd[i8];
                                                    numArray3[i6] = ynd[i8];
                                                    double num18 = x[i3] - numArray2[i6];
                                                    double num19 = y[i3] - numArray3[i6];
                                                    numArray4[i6] = Math.Sqrt(num18 * num18 + num19 * num19);
                                                }
                                            }
                                        }
                                        for (int i10 = 1; i10 <= knd; ++i10)
                                        {
                                            DistPnt(xnd[i10], ynd[i10], x1, y1, x2, y2, out dist, out ip, out xp, out yp);
                                            if (ip > 0 && dist < tol)
                                            {
                                                int num20 = 0;
                                                for (int i11 = 1; i11 <= i6; ++i11)
                                                {
                                                    double num21 = xp - numArray2[i11];
                                                    double num22 = yp - numArray3[i11];
                                                    if (Math.Sqrt(num21 * num21 + num22 * num22) < tol)
                                                    {
                                                        ++num20;
                                                        break;
                                                    }
                                                }
                                                if (num20 <= 0)
                                                {
                                                    ++i6;
                                                    numArray1[i6] = i7;
                                                    numArray2[i6] = xnd[i10];
                                                    numArray3[i6] = ynd[i10];
                                                    double num23 = x[i3] - numArray2[i6];
                                                    double num24 = y[i3] - numArray3[i6];
                                                    numArray4[i6] = Math.Sqrt(num23 * num23 + num24 * num24);
                                                }
                                            }
                                        }
                                    }
                                    double num25 = x[i4] - numArray2[i6];
                                    double num26 = y[i4] - numArray3[i6];
                                    if (Math.Sqrt(num25 * num25 + num26 * num26) >= tol)
                                    {
                                        ++i6;
                                        numArray1[i6] = i4;
                                        numArray2[i6] = x[i4];
                                        numArray3[i6] = y[i4];
                                        double num27 = x[i3] - numArray2[i6];
                                        double num28 = y[i3] - numArray3[i6];
                                        numArray4[i6] = Math.Sqrt(num27 * num27 + num28 * num28);
                                    }
                                    if (i6 < 2)
                                    {
                                        int num29 = 0;
                                        for (int i12 = i3; i12 <= i4; ++i12)
                                        {
                                            ++num29;
                                            ++i1;
                                            xn[i1] = x[i12];
                                            yn[i1] = y[i12];
                                        }
                                        ++kNew;
                                        kn[kNew] = num29;
                                        rNew[kNew] = rad[i2];
                                    }
                                    if (i6 > 1)
                                    {
                                        int num30 = i4 - i3;
                                        if (num30 == 1)
                                        {
                                            for (int i13 = 1; i13 < i6; ++i13)
                                            {
                                                ip = i13 + 1;
                                                for (int i14 = ip; i14 <= i6; ++i14)
                                                {
                                                    if (numArray4[i13] > numArray4[i14])
                                                    {
                                                        num30 = numArray1[i13];
                                                        double num31 = numArray2[i13];
                                                        double num32 = numArray3[i13];
                                                        double num33 = numArray4[i13];
                                                        numArray1[i13] = numArray1[i14];
                                                        numArray2[i13] = numArray2[i14];
                                                        numArray3[i13] = numArray3[i14];
                                                        numArray4[i13] = numArray4[i14];
                                                        numArray1[i14] = num30;
                                                        numArray2[i14] = num31;
                                                        numArray3[i14] = num32;
                                                        numArray4[i14] = num33;
                                                    }
                                                }
                                            }
                                        }
                                        if (num30 > 1)
                                        {
                                            for (int i15 = 1; i15 < i6; ++i15)
                                            {
                                                ip = i15 + 1;
                                                for (int i16 = ip; i16 <= i6; ++i16)
                                                {
                                                    if (numArray1[i15] > numArray1[i16])
                                                    {
                                                        int num34 = numArray1[i15];
                                                        double num35 = numArray2[i15];
                                                        double num36 = numArray3[i15];
                                                        double num37 = numArray4[i15];
                                                        numArray1[i15] = numArray1[i16];
                                                        numArray2[i15] = numArray2[i16];
                                                        numArray3[i15] = numArray3[i16];
                                                        numArray4[i15] = numArray4[i16];
                                                        numArray1[i16] = num34;
                                                        numArray2[i16] = num35;
                                                        numArray3[i16] = num36;
                                                        numArray4[i16] = num37;
                                                    }
                                                }
                                            }
                                            for (int i17 = 1; i17 < i6; ++i17)
                                            {
                                                ip = i17 + 1;
                                                for (int i18 = ip; i18 <= i6; ++i18)
                                                {
                                                    if (numArray1[i17] == numArray1[i18] && numArray4[i17] > numArray4[i18])
                                                    {
                                                        int num38 = numArray1[i17];
                                                        double num39 = numArray2[i17];
                                                        double num40 = numArray3[i17];
                                                        double num41 = numArray4[i17];
                                                        numArray1[i17] = numArray1[i18];
                                                        numArray2[i17] = numArray2[i18];
                                                        numArray3[i17] = numArray3[i18];
                                                        numArray4[i17] = numArray4[i18];
                                                        numArray1[i18] = num38;
                                                        numArray2[i18] = num39;
                                                        numArray3[i18] = num40;
                                                        numArray4[i18] = num41;
                                                    }
                                                }
                                            }
                                        }
                                        num4 = i4 - i3;
                                        double num42 = numArray2[i6] - x[i4];
                                        double num43 = numArray3[i6] - y[i4];
                                        if (Math.Sqrt(num42 * num42 + num43 * num43) >= tol)
                                        {
                                            ++i6;
                                            numArray1[i6] = i4;
                                            numArray2[i6] = x[i4];
                                            numArray3[i6] = y[i4];
                                            double num44 = x[i3] - numArray2[i6];
                                            double num45 = y[i3] - numArray3[i6];
                                            numArray4[i6] = Math.Sqrt(num44 * num44 + num45 * num45);
                                        }
                                        for (int i19 = 2; i19 <= i6; ++i19)
                                        {
                                            int num46 = i4 - i3;
                                            if (num46 == 1)
                                            {
                                                int num47 = 1;
                                                int i20 = i1 + 1;
                                                xn[i20] = numArray2[i19 - 1];
                                                yn[i20] = numArray3[i19 - 1];
                                                num5 = num47 + 1;
                                                i1 = i20 + 1;
                                                xn[i1] = numArray2[i19];
                                                yn[i1] = numArray3[i19];
                                                ++kNew;
                                                kn[kNew] = 2;
                                                rNew[kNew] = rad[i2];
                                            }
                                            else if (num46 > 1)
                                            {
                                                int num48 = numArray1[i19 - 1];
                                                int num49 = numArray1[i19];
                                                int num50 = 1;
                                                ++i1;
                                                xn[i1] = numArray2[i19 - 1];
                                                yn[i1] = numArray3[i19 - 1];
                                                if (num49 > num48)
                                                {
                                                    for (int i21 = num48 + 1; i21 < num49; ++i21)
                                                    {
                                                        double num51 = xn[i1] - x[i21];
                                                        double num52 = yn[i1] - y[i21];
                                                        if (Math.Sqrt(num51 * num51 + num52 * num52) >= tol)
                                                        {
                                                            ++num50;
                                                            ++i1;
                                                            xn[i1] = x[i21];
                                                            yn[i1] = y[i21];
                                                        }
                                                    }
                                                }
                                                double num53 = xn[i1] - numArray2[i19];
                                                double num54 = yn[i1] - numArray3[i19];
                                                double num55 = Math.Sqrt(num53 * num53 + num54 * num54);
                                                if (num55 <= tol)
                                                {
                                                    xn[i1] = numArray2[i19];
                                                    yn[i1] = numArray3[i19];
                                                }
                                                if (num55 > tol)
                                                {
                                                    ++num50;
                                                    ++i1;
                                                    xn[i1] = numArray2[i19];
                                                    yn[i1] = numArray3[i19];
                                                }
                                                ++kNew;
                                                kn[kNew] = num50;
                                                rNew[kNew] = rad[i2];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        kn1[1] = 1;
                        kn2[1] = kn[1];
                        if (kNew <= 1)
                            return;
                        for (int i22 = 2; i22 <= kNew; ++i22)
                        {
                            kn1[i22] = kn2[i22 - 1] + 1;
                            kn2[i22] = kn2[i22 - 1] + kn[i22];
                        }
                    }
                }
            }
        }

        public static void LineTopoline(
          double tol,
          int kPnt,
          ref double[] xpn,
          ref double[] ypn,
          ref int kLine1,
          ref double[] rRad1,
          ref int[] k1,
          ref int[] k2,
          ref double[] xLin1,
          ref double[] yLin1,
          out int kLine2,
          ref double[] rRad2,
          ref int[] kt1,
          ref int[] kt2,
          ref double[] xLin2,
          ref double[] yLin2,
          ref int[] ktt,
          ref int[] indx,
          ref double[] xd,
          ref double[] yd,
          ref double[] rd,
          StatusBarPanel panel1)
        {
            int[] numArray1 = new int[200];
            double[] numArray2 = new double[200];
            double[] numArray3 = new double[200];
            kLine2 = 0;
            int num1;
            int ip = num1 = 0;
            int num2;
            int num3 = num2 = 0;
            double num4;
            double num5 = num4 = 0.0;
            double num6;
            double num7 = num6 = 0.0;
            double num8;
            double num9 = num8 = 0.0;
            double num10;
            double dist = num10 = 0.0;
            double yp = num10;
            double xp = num10;
            if (tol < 0.003)
                tol = 0.003;
            int kArray = 999999;
            doubleArray(xpn, ref kArray);
            doubleArray(ypn, ref kArray);
            if (kPnt > kArray)
            {
                int num11 = (int)MessageBox.Show("Индекс массива LineTopoline");
            }
            else
            {
                kArray = 999999;
                intArray(k1, ref kArray);
                intArray(k2, ref kArray);
                intArray(kt1, ref kArray);
                intArray(kt2, ref kArray);
                intArray(ktt, ref kArray);
                intArray(indx, ref kArray);
                doubleArray(rRad1, ref kArray);
                doubleArray(rRad2, ref kArray);
                if (kLine1 > kArray)
                {
                    int num12 = (int)MessageBox.Show("Индекс массива LineTopoline");
                }
                else
                {
                    kArray = 999999;
                    int num13 = k2[kLine1];
                    doubleArray(xLin1, ref kArray);
                    doubleArray(yLin1, ref kArray);
                    doubleArray(xLin2, ref kArray);
                    doubleArray(yLin2, ref kArray);
                    doubleArray(xd, ref kArray);
                    doubleArray(yd, ref kArray);
                    doubleArray(rd, ref kArray);
                    if (num13 > kArray)
                    {
                        int num14 = (int)MessageBox.Show("Индекс массива LineTopoline");
                    }
                    else
                    {
                        panel1.Text = "Wait...Line Divide";
                        int i1 = 0;
                        for (int i2 = 1; i2 <= kLine1; ++i2)
                        {
                            panel1.Text = "Подождите..Топология Линий =" + string.Format("{0}", (object)kLine2);
                            int i3 = k1[i2];
                            int i4 = k2[i2];
                            double num15 = xLin1[i3];
                            double num16 = yLin1[i3];
                            double num17 = xLin1[i4];
                            double num18 = yLin1[i4];
                            num3 = 0;
                            if (rRad1[i2] == 0.0)
                            {
                                int i5 = 1;
                                numArray1[i5] = i3;
                                numArray2[1] = num15;
                                numArray3[1] = num16;
                                for (int i6 = i3 + 1; i6 <= i4; ++i6)
                                {
                                    for (int i7 = 0; i7 <= kPnt; ++i7)
                                    {
                                        double num19 = xLin1[i6] - xpn[i7];
                                        double num20 = yLin1[i6] - ypn[i7];
                                        if (Math.Sqrt(num19 * num19 + num20 * num20) < tol && i6 - numArray1[i5 - 1] > 1)
                                        {
                                            ++i5;
                                            numArray1[i5] = i6;
                                            numArray2[i5] = xpn[i7];
                                            numArray3[i5] = ypn[i7];
                                        }
                                    }
                                }
                                if (i5 >= 2)
                                {
                                    for (int i8 = 2; i8 <= i5; ++i8)
                                    {
                                        double x1 = numArray2[i8 - 1];
                                        double y1 = numArray3[i8 - 1];
                                        double x2 = numArray2[i8];
                                        double y2 = numArray3[i8];
                                        int i9 = 1;
                                        xd[1] = x1;
                                        yd[1] = y1;
                                        rd[1] = 0.0;
                                        for (int i10 = 0; i10 <= kPnt; ++i10)
                                        {
                                            DistPnt(xpn[i10], ypn[i10], x1, y1, x2, y2, out dist, out ip, out xp, out yp);
                                            if (ip > 0 && dist < tol)
                                            {
                                                ++i9;
                                                indx[i9] = i9;
                                                xd[i9] = xpn[i10];
                                                yd[i9] = ypn[i10];
                                                double num21 = xpn[i10] - x1;
                                                double num22 = ypn[i10] - y1;
                                                rd[i9] = Math.Sqrt(num21 * num21 + num22 * num22);
                                            }
                                        }
                                        int i11 = i9 + 1;
                                        indx[i11] = i11;
                                        xd[i11] = x2;
                                        yd[i11] = y2;
                                        double num23 = x2 - x1;
                                        double num24 = y2 - y1;
                                        rd[i11] = Math.Sqrt(num23 * num23 + num24 * num24);
                                        if (i11 >= 2)
                                        {
                                            for (int i12 = 1; i12 < i11; ++i12)
                                            {
                                                ip = i12 + 1;
                                                for (int i13 = ip; i13 <= i11; ++i13)
                                                {
                                                    if (rd[i12] > rd[i13])
                                                    {
                                                        xp = xd[i12];
                                                        yp = yd[i12];
                                                        double num25 = rd[i12];
                                                        xd[i12] = xd[i13];
                                                        yd[i12] = yd[i13];
                                                        rd[i12] = rd[i13];
                                                        xd[i13] = xp;
                                                        yd[i13] = yp;
                                                        rd[i13] = num25;
                                                    }
                                                }
                                            }
                                            int i14 = 1;
                                            indx[i14] = i14;
                                            for (int i15 = 2; i15 <= i11; ++i15)
                                            {
                                                if (rd[i15] - rd[i15 - 1] > 0.0)
                                                {
                                                    ++i14;
                                                    indx[i14] = i14;
                                                    xd[i14] = xd[i15];
                                                    yd[i14] = yd[i15];
                                                    rd[i14] = rd[i15];
                                                }
                                            }
                                            int num26 = i14;
                                            if (num26 >= 2)
                                            {
                                                for (int i16 = 2; i16 <= num26; ++i16)
                                                {
                                                    int i17 = i1 + 1;
                                                    xLin2[i17] = xd[i16 - 1];
                                                    yLin2[i17] = yd[i16 - 1];
                                                    i1 = i17 + 1;
                                                    xLin2[i1] = xd[i16];
                                                    yLin2[i1] = yd[i16];
                                                    ++kLine2;
                                                    rRad2[kLine2] = rRad1[i2];
                                                    ktt[kLine2] = 2;
                                                }
                                            }
                                        }
                                    }
                                }
                                else
                                    continue;
                            }
                            if (rRad1[i2] > 0.0)
                            {
                                panel1.Text = "Подождите..Топология Линий =" + string.Format("{0}", (object)kLine2);
                                int i18 = 1;
                                indx[i18] = i3;
                                xd[1] = num15;
                                yd[1] = num16;
                                for (int i19 = i3 + 1; i19 <= i4; ++i19)
                                {
                                    for (int i20 = 0; i20 <= kPnt; ++i20)
                                    {
                                        double num27 = xLin1[i19] - xpn[i20];
                                        double num28 = yLin1[i19] - ypn[i20];
                                        if (Math.Sqrt(num27 * num27 + num28 * num28) < tol && i19 - indx[i18 - 1] > 1)
                                        {
                                            ++i18;
                                            indx[i18] = i19;
                                            xd[i18] = xpn[i20];
                                            yd[i18] = ypn[i20];
                                            double num29 = xpn[i20] - num15;
                                            double num30 = ypn[i20] - num16;
                                            rd[i18] = Math.Sqrt(num29 * num29 + num30 * num30);
                                        }
                                    }
                                }
                                if (i18 < 2)
                                {
                                    ++i18;
                                    indx[i18] = i4;
                                    xd[i18] = num17;
                                    yd[i18] = num18;
                                }
                                for (int i21 = 2; i21 <= i18; ++i21)
                                {
                                    int num31 = indx[i21 - 1];
                                    int num32 = indx[i21];
                                    double num33 = 0.0;
                                    for (int i22 = num31 + 1; i22 <= num32; ++i22)
                                    {
                                        double num34 = xLin1[i22] - xLin1[i22 - 1];
                                        double num35 = yLin1[i22] - yLin1[i22 - 1];
                                        double num36 = Math.Sqrt(num34 * num34 + num35 * num35);
                                        num33 += num36;
                                    }
                                    if (num33 >= tol)
                                    {
                                        int num37 = 0;
                                        for (int i23 = num31; i23 <= num32; ++i23)
                                        {
                                            ++i1;
                                            ++num37;
                                            xLin2[i1] = xLin1[i23];
                                            yLin2[i1] = yLin1[i23];
                                        }
                                        ++kLine2;
                                        rRad2[kLine2] = rRad1[i2];
                                        ktt[kLine2] = num37;
                                    }
                                }
                            }
                        }
                        kt1[1] = 1;
                        kt2[1] = ktt[1];
                        if (kLine2 <= 1)
                            return;
                        for (int i24 = 2; i24 <= kLine2; ++i24)
                        {
                            kt1[i24] = kt2[i24 - 1] + 1;
                            kt2[i24] = kt2[i24 - 1] + ktt[i24];
                        }
                    }
                }
            }
        }

        public static void LineTopology(
          double tolerance,
          ref int kPntPlus,
          ref double[] xPnt,
          ref double[] yPnt,
          ref int kLine,
          ref double[] rRadLine,
          ref int[] k1,
          ref int[] k2,
          ref double[] xLin,
          ref double[] yLin,
          out int kNode,
          ref double[] xNode,
          ref double[] yNode,
          out int kLineTopo,
          ref double[] radLine,
          ref int[] kl1,
          ref int[] kl2,
          ref double[] xTop,
          ref double[] yTop,
          ref int[] kt1,
          ref int[] kt2,
          ref int[] nWork,
          ref int[] nWork1,
          ref int[] nWork2,
          ref double[] xWork,
          ref double[] yWork,
          ref double[] zWork,
          ref double[] pWork,
          ref double[] rWork,
          ref double[] xWork1,
          ref double[] yWork1,
          ref double[] xAdd,
          ref double[] yAdd,
          ref int[] nDop1,
          ref int[] nDop2,
          ref double[] xDop,
          ref double[] yDop,
          ref double[] xPik,
          ref double[] yPik,
          StatusBarPanel panel1)
        {
            int num1;
            int kNew1 = num1 = 0;
            int knd = num1;
            int kNew2 = num1;
            int kLine2 = 0;
            LineTopoline(tolerance, kPntPlus, ref xPnt, ref yPnt, ref kLine, ref rRadLine, ref k1, ref k2, ref xLin, ref yLin, out kLine2, ref pWork, ref kt1, ref kt2, ref xWork1, ref yWork1, ref nWork1, ref nWork2, ref xWork, ref yWork, ref zWork, panel1);
            int kPnt = -1;
            for (int i = 0; i <= kPntPlus; ++i)
            {
                ++kPnt;
                xAdd[kPnt] = xPnt[i];
                yAdd[kPnt] = yPnt[i];
            }
            NodeTopology(tolerance, kPnt, ref xAdd, ref yAdd, kLine2, ref kt1, ref kt2, ref xWork1, ref yWork1, out kNode, ref xNode, ref yNode, ref nWork, ref xDop, ref yDop, out knd, ref xPik, ref yPik, panel1);
            LineDivide(kLine2, ref pWork, ref kt1, ref kt2, ref xWork1, ref yWork1, knd, ref xPik, ref yPik, out kNew1, ref rWork, ref k1, ref k2, ref nWork, ref xLin, ref yLin, tolerance, panel1);
            kLine = kNew1;
            RemoveDoubleLine(tolerance, ref kLine, ref rWork, ref k1, ref k2, ref xLin, ref yLin, out kNew2, ref pWork, ref nWork1, ref nWork2, ref xWork, ref yWork, ref xDop, ref yDop, ref nWork, ref nDop1, ref nDop2, panel1);
            kLineTopo = kLine;
            for (int i = 1; i <= kLineTopo; ++i)
            {
                if (k2[i] - k1[i] == 1)
                    radLine[i] = 0.0;
                radLine[i] = rWork[i];
                kl1[i] = k1[i];
                kl2[i] = k2[i];
            }
            int num2 = kl2[kLineTopo];
            for (int i = 1; i <= num2; ++i)
            {
                xTop[i] = xLin[i];
                yTop[i] = yLin[i];
            }
        }

        public static void TolerFormula(ref char[] sFormula, double A, out double toler)
        {
            int[] numArray = new int[50];
            int[] k1 = new int[10];
            int[] k2 = new int[10];
            int[] kac = new int[10];
            int[] kai = new int[10];
            int[] ksm = new int[10];
            int[] ksi = new int[10];
            int[] ind = new int[10];
            double[] aDat = new double[10];
            char[] sTemp = new char[50];
            toler = 0.0;
            int num1;
            int num2 = num1 = 0;
            int num3;
            int num4 = num3 = 0;
            int ks = num3;
            int ka = num3;
            int kt = num3;
            double toler1;
            double aNum = toler1 = 0.0;
            int i1 = -1;
            for (int i2 = 40; i2 <= 43; ++i2)
            {
                ++i1;
                numArray[i1] = i2;
            }
            for (int i3 = 45; i3 <= 57; ++i3)
            {
                ++i1;
                numArray[i1] = i3;
            }
            int i4 = i1 + 1;
            numArray[i4] = 65;
            int i5 = i4 + 1;
            numArray[i5] = 97;
            for (int i6 = 81; i6 <= 84; ++i6)
            {
                ++i5;
                numArray[i5] = i6;
            }
            for (int i7 = 113; i7 <= 116; ++i7)
            {
                ++i5;
                numArray[i5] = i7;
            }
            int length = sFormula.Length;
            int i8 = -1;
            for (int i9 = 0; i9 < length; ++i9)
            {
                switch (sFormula[i9])
                {
                    case char.MinValue:
                    case ' ':
                        continue;
                    default:
                        ++i8;
                        sFormula[i8] = sFormula[i9];
                        continue;
                }
            }
            int num5 = i8;
            for (int i10 = 0; i10 <= num5; ++i10)
            {
                int num6 = 0;
                int num7 = (int)sFormula[i10];
                for (int i11 = 0; i11 <= i5; ++i11)
                {
                    if (numArray[i11] == num7)
                    {
                        ++num6;
                        break;
                    }
                }
                if (num6 == 0)
                    return;
            }
            int k3 = num5 + 1;
            sFormula[k3] = char.MinValue;
            TolerAction(k3, ref sFormula, out kt, ref k1, ref k2, out ka, ref kai, ref kac, out ks, ref ksi, ref ksm);
            int knum = 0;
            if (kt > 0)
            {
                for (int i12 = 1; i12 <= kt; ++i12)
                {
                    int i13 = k1[i12];
                    int num8 = k2[i12];
                    int num9 = i13;
                    int num10 = (int)sFormula[i13];
                    if (num10 == 83 || num10 == 115)
                        num9 = i13 + 5;
                    if (num10 == 40)
                        num9 = i13 + 1;
                    int i14 = -1;
                    for (int i15 = num9; i15 < num8; ++i15)
                    {
                        ++i14;
                        sTemp[i14] = sFormula[i15];
                    }
                    int k4 = i14 + 1;
                    sTemp[k4] = char.MinValue;
                    TolerForm2(k4, ref sTemp, A, out aNum);
                    if (num10 == 83 || num10 == 115)
                        aNum = Math.Sqrt(aNum);
                    ++knum;
                    ind[knum] = k1[i12];
                    aDat[knum] = aNum;
                }
            }
            if (ks > 0)
            {
                for (int i16 = 1; i16 <= ks; ++i16)
                {
                    int num11 = ksm[i16];
                    if (num11 > 47 && num11 < 58)
                    {
                        int num12 = ksi[i16];
                        int i17 = -1;
                        for (int i18 = num12; i18 <= k3; ++i18)
                        {
                            switch (sFormula[i18])
                            {
                                case '.':
                                    ++i17;
                                    sTemp[i17] = sFormula[i18];
                                    break;
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                    ++i17;
                                    sTemp[i17] = sFormula[i18];
                                    break;
                                default:
                                    goto label_48;
                            }
                        }
                    label_48:
                        int km = i17 + 1;
                        sTemp[km] = char.MinValue;
                        TolerForm1(km, ref sTemp, out aNum);
                        ++knum;
                        ind[knum] = ksi[i16];
                        aDat[knum] = aNum;
                    }
                    if (num11 == 65 || num11 == 97)
                    {
                        ++knum;
                        ind[knum] = ksi[i16];
                        aDat[knum] = A;
                    }
                }
            }
            for (int i19 = 1; i19 < knum; ++i19)
            {
                for (int i20 = i19 + 1; i20 <= knum; ++i20)
                {
                    if (ind[i19] > ind[i20])
                    {
                        int num13 = ind[i19];
                        aNum = aDat[i19];
                        ind[i19] = ind[i20];
                        aDat[i19] = aDat[i20];
                        ind[i20] = num13;
                        aDat[i20] = aNum;
                    }
                }
            }
            TolerSum(knum, ref ind, ref aDat, ka, ref kai, ref kac, out toler1);
            toler = toler1;
        }

        public static void KeepPolyLabel(
          int kPolAct,
          ref string[] nameAct,
          ref double[] xLab,
          ref double[] yLab,
          ref int[] kPol1,
          ref int[] kPol2,
          ref double[] xPol,
          ref double[] yPol,
          ref double[] xa,
          ref double[] ya,
          ref double[] xb,
          ref double[] yb,
          ref double[] xd,
          ref double[] yd,
          ref double[] zd,
          ref double[] xe,
          ref double[] ye,
          ref double[] ze,
          ref int[] kb,
          ref int[] kb1,
          ref int[] kb2,
          StatusBarPanel panel1)
        {
            double xpol = 0.0;
            double ypol = 0.0;
            int num1;
            int num2 = num1 = 0;
            int num3;
            int num4 = num3 = 0;
            int kArray1 = 999999;
            stringArray(nameAct, ref kArray1);
            intArray(kPol1, ref kArray1);
            intArray(kPol2, ref kArray1);
            intArray(kb1, ref kArray1);
            intArray(kb2, ref kArray1);
            intArray(kb, ref kArray1);
            doubleArray(xLab, ref kArray1);
            doubleArray(yLab, ref kArray1);
            if (kPolAct > kArray1)
            {
                int num5 = (int)MessageBox.Show("Индекс массива KeepPolyLabel");
            }
            else
            {
                int num6 = kPol2[kPolAct];
                int kArray2 = 999999;
                doubleArray(xPol, ref kArray2);
                doubleArray(yPol, ref kArray2);
                doubleArray(xa, ref kArray2);
                doubleArray(ya, ref kArray2);
                doubleArray(xb, ref kArray2);
                doubleArray(yb, ref kArray2);
                doubleArray(xd, ref kArray2);
                doubleArray(yd, ref kArray2);
                doubleArray(zd, ref kArray2);
                doubleArray(xe, ref kArray2);
                doubleArray(ye, ref kArray2);
                doubleArray(ze, ref kArray2);
                if (num6 > kArray2)
                {
                    int num7 = (int)MessageBox.Show("Индекс массива KeepPolyLabel");
                }
                else
                {
                    Cursor.Current = Cursors.WaitCursor;
                    num2 = 0;
                    for (int i1 = 1; i1 <= kPolAct; ++i1)
                    {
                        panel1.Text = "Подождите..Метки =" + string.Format("{0}", (object)i1);
                        nameAct[i1] = Convert.ToString(i1);
                        int kin = 0;
                        int i2 = 0;
                        int num8 = kPol1[i1];
                        int num9 = kPol2[i1];
                        int k1 = -1;
                        for (int i3 = num8; i3 <= num9; ++i3)
                        {
                            ++k1;
                            xa[k1] = xPol[i3];
                            ya[k1] = yPol[i3];
                        }
                        for (int i4 = i1 + 1; i4 <= kPolAct; ++i4)
                        {
                            int num10 = kPol1[i4];
                            int num11 = kPol2[i4];
                            int num12 = 0;
                            for (int i5 = num10; i5 <= num11; ++i5)
                            {
                                num12 = in_out(k1, ref xa, ref ya, xPol[i5], yPol[i5]);
                                if (num12 == 0)
                                    break;
                            }
                            if (num12 != 0)
                            {
                                int num13 = 0;
                                for (int i6 = num10; i6 <= num11; ++i6)
                                {
                                    ++num13;
                                    ++i2;
                                    xb[i2] = xPol[i6];
                                    yb[i2] = yPol[i6];
                                }
                                ++kin;
                                kb[kin] = num13;
                            }
                        }
                        if (kin > 0)
                        {
                            kb1[1] = 1;
                            kb2[1] = kb[1];
                            if (kin > 1)
                            {
                                for (int i7 = 2; i7 <= kin; ++i7)
                                {
                                    kb1[i7] = kb2[i7 - 1] + 1;
                                    kb2[i7] = kb2[i7 - 1] + kb[i7];
                                }
                            }
                        }
                        int k2 = 0;
                        for (int i8 = num8; i8 <= num9; ++i8)
                        {
                            ++k2;
                            xa[k2] = xPol[i8];
                            ya[k2] = yPol[i8];
                        }
                        PolygonLabel(k2, ref xa, ref ya, kin, ref kb1, ref kb2, ref xb, ref yb, out xpol, out ypol, ref xd, ref yd, ref zd, ref xe, ref ye, ref ze);
                        xLab[i1] = xpol;
                        yLab[i1] = ypol;
                    }
                }
            }
        }

        public static void LinesToPoly(
          double tolerance,
          int kLine,
          ref int[] k1,
          ref int[] k2,
          ref double[] xLin,
          ref double[] yLin,
          int kNode,
          ref double[] xNode,
          ref double[] yNode,
          out int kPoly,
          ref string[] namePol,
          ref double[] xLab,
          ref double[] yLab,
          ref double[] areaPol,
          ref double[] aLegal,
          ref int[] nSymbPol,
          ref int[] kt1,
          ref int[] kt2,
          ref double[] xPol,
          ref double[] yPol,
          out int kInter,
          ref int[] indPol,
          ref int[] kn1,
          ref int[] kn2,
          ref int[] nWork,
          ref int[] indInter,
          ref double[] xWork1,
          ref double[] yWork1,
          ref int[] nWork1,
          ref int[] nWork2,
          ref double[] xWork,
          ref double[] yWork,
          ref double[] zWork,
          ref double[] xWork2,
          ref double[] yWork2,
          ref double[] pWork,
          ref double[] rWork,
          ref double[] qWork,
          StatusBarPanel panel1)
        {
            int kPol1 = 0;
            int kPol2 = 0;
            int kin = 0;
            kInter = 0;
            kPoly = 0;
            int kArray1 = 999999;
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            intArray(kt1, ref kArray1);
            intArray(kt2, ref kArray1);
            intArray(kn1, ref kArray1);
            intArray(kn2, ref kArray1);
            intArray(indPol, ref kArray1);
            intArray(nWork, ref kArray1);
            intArray(nWork1, ref kArray1);
            intArray(nWork1, ref kArray1);
            intArray(indInter, ref kArray1);
            if (kLine > kArray1)
            {
                int num1 = (int)MessageBox.Show("Индекс массива LinesToPoly");
            }
            else
            {
                int num2 = k2[kLine];
                int kArray2 = 999999;
                doubleArray(xLin, ref kArray2);
                doubleArray(yLin, ref kArray2);
                doubleArray(xNode, ref kArray2);
                doubleArray(yNode, ref kArray2);
                doubleArray(xLab, ref kArray2);
                doubleArray(yLab, ref kArray2);
                doubleArray(areaPol, ref kArray2);
                doubleArray(aLegal, ref kArray2);
                stringArray(namePol, ref kArray2);
                intArray(nSymbPol, ref kArray2);
                doubleArray(xPol, ref kArray2);
                doubleArray(yPol, ref kArray2);
                doubleArray(xWork, ref kArray2);
                doubleArray(yWork, ref kArray2);
                doubleArray(zWork, ref kArray2);
                doubleArray(xWork1, ref kArray2);
                doubleArray(yWork1, ref kArray2);
                doubleArray(xWork2, ref kArray2);
                doubleArray(yWork2, ref kArray2);
                doubleArray(pWork, ref kArray2);
                doubleArray(rWork, ref kArray2);
                doubleArray(qWork, ref kArray2);
                if (num2 > kArray2)
                {
                    int num3 = (int)MessageBox.Show("Индекс массива LinesToPoly");
                }
                else
                {
                    panel1.Text = "Подождите..Полигон Строится";
                    PolyConstruct(tolerance, kLine, k1, k2, xLin, yLin, kNode, xNode, yNode, out kPol1, xLab, yLab, areaPol, aLegal, nSymbPol, kt1, kt2, nWork, xPol, yPol, xWork1, yWork1, xWork2, yWork2, xWork, yWork, zWork, nWork1, nWork2, kn1, kn2, indPol, panel1);
                    kPoly = kPol1;
                    for (int i = 1; i <= kPol1; ++i)
                        namePol[i] = string.Format("{0}", (object)i);
                    kInter = 0;
                    if (kPoly <= 1)
                        return;
                    panel1.Text = "Подождите... Проверьте дубликат";
                    PolyDelete(kPol1, ref kt1, ref kt2, ref xPol, ref yPol, out kPol2, ref namePol, ref xLab, ref yLab, ref areaPol, ref aLegal, ref nSymbPol, ref kn1, ref kn2, ref xWork1, ref yWork1, tolerance, ref xWork2, ref yWork2, ref xWork, ref yWork, ref zWork, ref nWork);
                    kPoly = kPol2;
                    for (int i = 1; i <= kPol2; ++i)
                    {
                        kt1[i] = kn1[i];
                        kt2[i] = kn2[i];
                    }
                    int num4 = kn2[kPol2];
                    for (int i = 1; i <= num4; ++i)
                    {
                        xPol[i] = xWork1[i];
                        yPol[i] = yWork1[i];
                    }
                    panel1.Text = "Подождите... Проверьте внутренние полигоны";
                    PolyInterior(kPol2, ref xLab, ref yLab, ref areaPol, ref aLegal, ref kt1, ref kt2, ref xPol, ref yPol, out kin, ref indPol, ref kn1, ref kn2, ref nWork, ref indInter, ref xWork1, ref yWork1, ref xWork2, ref yWork2, ref xWork, ref yWork, ref zWork, ref rWork, ref pWork, ref qWork);
                    kInter = kin;
                }
            }
        }

        public static void RemoveDoubleLine(
          double tol,
          ref int kLine,
          ref double[] rRad,
          ref int[] k1,
          ref int[] k2,
          ref double[] xLin,
          ref double[] yLin,
          out int kNew,
          ref double[] rNew,
          ref int[] kt1,
          ref int[] kt2,
          ref double[] xNew,
          ref double[] yNew,
          ref double[] xDop,
          ref double[] yDop,
          ref int[] ktt,
          ref int[] kn1,
          ref int[] kn2,
          StatusBarPanel panel1)
        {
            int i1 = 0;
            kNew = 0;
            int num1;
            int num2 = num1 = 0;
            double num3;
            double num4 = num3 = 0.0;
            if (tol < 0.003)
                tol = 0.003;
            panel1.Text = "Подождите....Удалить двойные линии";
            int kArray = 999999;
            intArray(k1, ref kArray);
            intArray(k2, ref kArray);
            intArray(kn1, ref kArray);
            intArray(kn2, ref kArray);
            intArray(kt1, ref kArray);
            intArray(kt2, ref kArray);
            intArray(ktt, ref kArray);
            doubleArray(rRad, ref kArray);
            doubleArray(rNew, ref kArray);
            if (kLine > kArray)
            {
                int num5 = (int)MessageBox.Show("Индекс массива RemoveDoubleLine");
            }
            else
            {
                kArray = 999999;
                int num6 = k2[kLine];
                doubleArray(xLin, ref kArray);
                doubleArray(yLin, ref kArray);
                doubleArray(xNew, ref kArray);
                doubleArray(yNew, ref kArray);
                doubleArray(xDop, ref kArray);
                doubleArray(yDop, ref kArray);
                if (num6 > kArray)
                {
                    int num7 = (int)MessageBox.Show("Индекс массива RemoveDoubleLine");
                }
                else
                {
                    for (int i2 = 1; i2 <= kLine; ++i2)
                    {
                        int num8 = k1[i2];
                        int num9 = k2[i2];
                        for (int i3 = num8 + 1; i3 <= num9; ++i3)
                        {
                            ++i1;
                            xDop[i1] = 0.5 * (xLin[i3 - 1] + xLin[i3]);
                            yDop[i1] = 0.5 * (yLin[i3 - 1] + yLin[i3]);
                            kt1[i1] = i2;
                            kt2[i1] = i3;
                        }
                    }
                    int i4 = 0;
                    for (int i5 = 1; i5 < i1; ++i5)
                    {
                        for (int i6 = i5 + 1; i6 <= i1; ++i6)
                        {
                            double num10 = xDop[i5] - xDop[i6];
                            double num11 = yDop[i5] - yDop[i6];
                            if (Math.Sqrt(num10 * num10 + num11 * num11) < tol)
                            {
                                ++i4;
                                kn1[i4] = kt1[i6];
                                kn2[i4] = kt2[i6];
                            }
                        }
                    }
                    if (i4 == 0)
                        return;
                    int i7 = 0;
                    for (int i8 = 1; i8 <= kLine; ++i8)
                    {
                        int num12 = k1[i8];
                        int num13 = k2[i8];
                        int num14 = 0;
                        for (int i9 = 1; i9 <= i4; ++i9)
                        {
                            if (kn1[i9] == i8)
                            {
                                ++num14;
                                break;
                            }
                        }
                        if (num14 == 0)
                        {
                            int num15 = 0;
                            for (int i10 = num12; i10 <= num13; ++i10)
                            {
                                ++num15;
                                ++i7;
                                xNew[i7] = xLin[i10];
                                yNew[i7] = yLin[i10];
                            }
                            ++kNew;
                            rNew[kNew] = rRad[i8];
                            ktt[kNew] = num15;
                        }
                        if (num14 > 0)
                        {
                            int i11 = 0;
                            for (int i12 = num12; i12 <= num13; ++i12)
                            {
                                int num16 = 0;
                                for (int i13 = 1; i13 <= i4; ++i13)
                                {
                                    if (kn2[i13] == i12)
                                    {
                                        ++num16;
                                        break;
                                    }
                                }
                                if (num16 == 0)
                                {
                                    ++i11;
                                    xDop[i11] = xLin[i12];
                                    yDop[i11] = yLin[i12];
                                }
                                if (num16 > 0)
                                {
                                    if (i11 == 1)
                                    {
                                        xDop[i11] = xLin[i12];
                                        yDop[i11] = yLin[i12];
                                    }
                                    if (i11 > 1)
                                    {
                                        int num17 = 0;
                                        for (int i14 = 1; i14 <= i11; ++i14)
                                        {
                                            ++num17;
                                            ++i7;
                                            xNew[i7] = xDop[i14];
                                            yNew[i7] = yDop[i14];
                                        }
                                        ++kNew;
                                        rRad[kNew] = rRad[i8];
                                        ktt[kNew] = num17;
                                        i11 = 1;
                                        xDop[i11] = xLin[i12];
                                        yDop[i11] = yLin[i12];
                                    }
                                }
                            }
                            if (i11 > 1)
                            {
                                int num18 = 0;
                                for (int i15 = 1; i15 <= i11; ++i15)
                                {
                                    ++num18;
                                    ++i7;
                                    xNew[i7] = xDop[i15];
                                    yNew[i7] = yDop[i15];
                                }
                                ++kNew;
                                rRad[kNew] = rRad[i8];
                                ktt[kNew] = num18;
                            }
                        }
                    }
                    kLine = kNew;
                    k1[1] = 1;
                    k2[1] = ktt[1];
                    if (kLine > 1)
                    {
                        for (int i16 = 2; i16 <= kLine; ++i16)
                        {
                            k1[i16] = k2[i16 - 1] + 1;
                            k2[i16] = k2[i16 - 1] + ktt[i16];
                        }
                    }
                    for (int i17 = 1; i17 <= kLine; ++i17)
                    {
                        int num19 = k1[i17];
                        int num20 = k2[i17];
                        for (int i18 = num19; i18 <= num20; ++i18)
                        {
                            xLin[i18] = xNew[i18];
                            yLin[i18] = yNew[i18];
                        }
                    }
                }
            }
        }

        public static void CleanLineTopo(
          ref int kLine,
          ref int[] k1,
          ref int[] k2,
          ref double[] rRad,
          ref double[] xLine,
          ref double[] yLine,
          ref int[] kt,
          ref double[] xd,
          ref double[] yd,
          double tol)
        {
            if (tol < 0.003)
                tol = 0.003;
            int kArray = 999999;
            intArray(k1, ref kArray);
            intArray(k2, ref kArray);
            intArray(kt, ref kArray);
            doubleArray(rRad, ref kArray);
            if (kLine > kArray)
            {
                int num1 = (int)MessageBox.Show("Индекс массива CleanLineTopo");
            }
            else
            {
                int num2 = k2[kLine];
                kArray = 999999;
                doubleArray(xLine, ref kArray);
                doubleArray(yLine, ref kArray);
                doubleArray(xd, ref kArray);
                doubleArray(yd, ref kArray);
                if (num2 > kArray)
                {
                    int num3 = (int)MessageBox.Show("Индекс массива CleanLineTopo");
                }
                else
                {
                    int i1 = 0;
                    for (int i2 = 1; i2 <= kLine; ++i2)
                    {
                        int i3 = k1[i2];
                        int i4 = k2[i2];
                        int i5 = i1 + 1;
                        xd[i5] = xLine[i3];
                        yd[i5] = yLine[i3];
                        i1 = i5 + 1;
                        xd[i1] = xLine[i4];
                        yd[i1] = yLine[i4];
                    }
                    int i6 = 0;
                    int i7 = 0;
                    for (int i8 = 1; i8 <= kLine; ++i8)
                    {
                        int i9 = k1[i8];
                        int i10 = k2[i8];
                        int num4 = 0;
                        for (int i11 = 1; i11 <= i1; ++i11)
                        {
                            double num5 = xLine[i9] - xd[i11];
                            double num6 = yLine[i9] - yd[i11];
                            if (Math.Sqrt(num5 * num5 + num6 * num6) < tol)
                                ++num4;
                        }
                        if (num4 >= 2)
                        {
                            int num7 = 0;
                            for (int i12 = 1; i12 <= i1; ++i12)
                            {
                                double num8 = xLine[i10] - xd[i12];
                                double num9 = yLine[i10] - yd[i12];
                                if (Math.Sqrt(num8 * num8 + num9 * num9) < tol)
                                    ++num7;
                            }
                            if (num7 >= 2)
                            {
                                ++i6;
                                rRad[i6] = rRad[i8];
                                int num10 = 0;
                                for (int i13 = i9; i13 <= i10; ++i13)
                                {
                                    ++i7;
                                    ++num10;
                                    xLine[i7] = xLine[i13];
                                    yLine[i7] = yLine[i13];
                                }
                                kt[i6] = num10;
                            }
                        }
                    }
                    kLine = i6;
                    if (i6 == 0)
                        return;
                    k1[1] = 1;
                    k2[1] = kt[1];
                    if (kLine <= 1)
                        return;
                    for (int i14 = 2; i14 <= kLine; ++i14)
                    {
                        k1[i14] = k2[i14 - 1] + 1;
                        k2[i14] = k2[i14 - 1] + kt[i14];
                    }
                }
            }
        }

        public static void ParcelSelect(
          double xCur,
          double yCur,
          int kPoly,
          ref string[] namePoly,
          ref double[] xLab,
          ref double[] yLab,
          ref double[] areaCalc,
          ref double[] areaLeg,
          out string sName,
          out double sCalc,
          out double sLeg,
          out int indPoly)
        {
            sName = "";
            sCalc = 0.0;
            sLeg = 0.0;
            indPoly = 0;
            double num1;
            double num2 = num1 = 0.0;
            int kArray = 999999;
            stringArray(namePoly, ref kArray);
            doubleArray(xLab, ref kArray);
            doubleArray(yLab, ref kArray);
            doubleArray(areaCalc, ref kArray);
            doubleArray(areaLeg, ref kArray);
            if (kPoly > kArray)
            {
                int num3 = (int)MessageBox.Show("Индекс массива ParcelSelect");
            }
            else
            {
                double num4 = 9999999.9;
                for (int i = 1; i <= kPoly; ++i)
                {
                    double num5 = xLab[i] - xCur;
                    double num6 = yLab[i] - yCur;
                    double num7 = Math.Sqrt(num5 * num5 + num6 * num6);
                    if (num4 > num7)
                    {
                        num4 = num7;
                        indPoly = i;
                    }
                }
                sName = namePoly[indPoly];
                sCalc = areaCalc[indPoly];
                sLeg = areaLeg[indPoly];
            }
        }

        public static void DangleDelete(
          int kLine1,
          ref double[] rd1,
          ref int[] k1,
          ref int[] k2,
          ref double[] x1,
          ref double[] y1,
          out int kLine2,
          ref double[] rd2,
          ref int[] kt1,
          ref int[] kt2,
          ref double[] x2,
          ref double[] y2,
          double tol,
          out int kDan,
          ref int[] nLin,
          ref int[] ktt)
        {
            kLine2 = 0;
            kDan = 0;
            double num1;
            double num2 = num1 = 0.0;
            int num3;
            int num4 = num3 = 0;
            if (tol < 0.003)
                tol = 0.003;
            int kArray = 999999;
            doubleArray(x1, ref kArray);
            doubleArray(y1, ref kArray);
            doubleArray(x2, ref kArray);
            doubleArray(y2, ref kArray);
            kArray -= 3;
            if (k2[kLine1] > kArray)
            {
                int num5 = (int)MessageBox.Show("Индекс массива DangleDelete");
            }
            else
            {
                int num6;
                do
                {
                    num6 = 0;
                    for (int i1 = 1; i1 <= kLine1; ++i1)
                    {
                        int num7 = 0;
                        if (kDan > 0)
                        {
                            for (int i2 = 1; i2 <= kDan; ++i2)
                            {
                                if (nLin[i2] == i1)
                                {
                                    ++num7;
                                    break;
                                }
                            }
                        }
                        if (num7 <= 0)
                        {
                            int i3 = k1[i1];
                            int i4 = k2[i1];
                            double num8 = x1[i3] - x1[i4];
                            double num9 = y1[i3] - y1[i4];
                            if (Math.Sqrt(num8 * num8 + num9 * num9) >= tol)
                            {
                                int num10 = 0;
                                int num11 = 0;
                                for (int i5 = 1; i5 <= kLine1; ++i5)
                                {
                                    if (i1 != i5)
                                    {
                                        int num12 = 0;
                                        if (kDan > 0)
                                        {
                                            for (int i6 = 1; i6 <= kDan; ++i6)
                                            {
                                                if (nLin[i6] == i5)
                                                {
                                                    ++num12;
                                                    break;
                                                }
                                            }
                                        }
                                        if (num12 <= 0)
                                        {
                                            int i7 = k1[i5];
                                            int i8 = k2[i5];
                                            double num13 = x1[i3] - x1[i7];
                                            double num14 = y1[i3] - y1[i7];
                                            if (Math.Sqrt(num13 * num13 + num14 * num14) < tol)
                                                ++num10;
                                            double num15 = x1[i3] - x1[i8];
                                            double num16 = y1[i3] - y1[i8];
                                            if (Math.Sqrt(num15 * num15 + num16 * num16) < tol)
                                                ++num10;
                                            double num17 = x1[i4] - x1[i7];
                                            double num18 = y1[i4] - y1[i7];
                                            if (Math.Sqrt(num17 * num17 + num18 * num18) < tol)
                                                ++num11;
                                            double num19 = x1[i4] - x1[i8];
                                            double num20 = y1[i4] - y1[i8];
                                            if (Math.Sqrt(num19 * num19 + num20 * num20) < tol)
                                                ++num11;
                                        }
                                    }
                                }
                                if (num10 == 0 || num11 == 0)
                                {
                                    ++num6;
                                    ++kDan;
                                    nLin[kDan] = i1;
                                }
                            }
                        }
                    }
                }
                while (num6 > 0);
                int i9 = 0;
                for (int i10 = 1; i10 <= kLine1; ++i10)
                {
                    int num21 = k1[i10];
                    int num22 = k2[i10];
                    int num23 = 0;
                    if (kDan > 0)
                    {
                        for (int i11 = 1; i11 <= kDan; ++i11)
                        {
                            if (nLin[i11] == i10)
                            {
                                ++num23;
                                break;
                            }
                        }
                    }
                    if (num23 <= 0)
                    {
                        int num24 = 0;
                        for (int i12 = num21; i12 <= num22; ++i12)
                        {
                            ++i9;
                            ++num24;
                            x2[i9] = x1[i12];
                            y2[i9] = y1[i12];
                            if (i9 > kArray)
                            {
                                int num25 = (int)MessageBox.Show("Индекс массива DangleDelete");
                                return;
                            }
                        }
                        ++kLine2;
                        rd2[kLine2] = rd1[i10];
                        ktt[kLine2] = num24;
                    }
                }
                kt1[1] = 1;
                kt2[1] = ktt[1];
                if (kLine2 <= 1)
                    return;
                for (int i13 = 2; i13 <= kLine2; ++i13)
                {
                    kt1[i13] = kt2[i13 - 1] + 1;
                    kt2[i13] = kt2[i13 - 1] + ktt[i13];
                }
            }
        }

        public static void LineTopoDel(
          int indDel,
          int kLine,
          ref double[] Rad,
          ref int[] k1,
          ref int[] k2,
          ref double[] xLin,
          ref double[] yLin,
          out int kNew,
          ref double[] radNew,
          ref int[] kt1,
          ref int[] kt2,
          ref double[] xNew,
          ref double[] yNew,
          ref int[] ktt)
        {
            kNew = 0;
            int kArray1 = 999999;
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            intArray(kt1, ref kArray1);
            intArray(kt2, ref kArray1);
            doubleArray(Rad, ref kArray1);
            doubleArray(radNew, ref kArray1);
            if (kLine > kArray1)
            {
                int num1 = (int)MessageBox.Show("Индекс массива LineTopoDel");
            }
            else
            {
                int kArray2 = 999999;
                int num2 = k2[kLine];
                doubleArray(xLin, ref kArray2);
                doubleArray(yLin, ref kArray2);
                doubleArray(xNew, ref kArray2);
                doubleArray(yNew, ref kArray2);
                if (num2 > kArray2)
                {
                    int num3 = (int)MessageBox.Show("Индекс массива LineTopoDel");
                }
                else
                {
                    int num4;
                    int i1 = num4 = 0;
                    for (int i2 = 1; i2 <= kLine; ++i2)
                    {
                        if (i2 != indDel)
                        {
                            int num5 = k1[i2];
                            int num6 = k2[i2];
                            int num7 = 0;
                            for (int i3 = num5; i3 <= num6; ++i3)
                            {
                                ++num7;
                                ++i1;
                                xNew[i1] = xLin[i3];
                                yNew[i1] = yLin[i3];
                            }
                            ++kNew;
                            radNew[kNew] = Rad[i2];
                            ktt[kNew] = num7;
                        }
                    }
                    kt1[1] = 1;
                    kt2[1] = ktt[1];
                    if (kNew <= 1)
                        return;
                    for (int i4 = 2; i4 <= kNew; ++i4)
                    {
                        kt1[i4] = kt2[i4 - 1] + 1;
                        kt2[i4] = kt2[i4 - 1] + ktt[i4];
                    }
                }
            }
        }

        public static void DrawNode(
            PaintEventArgs e,
            int kNode,
            string[] nameNode,
            double[] xNode,
            double[] yNode,
            double scaleToWin,
            double xBegX,
            double yBegY,
            int xBegWin,
            int yBegWin)
        {
            Graphics graphics = e.Graphics;
            int xWin = 0;
            int yWin = 0;
            int emSize = 7;
            if (kNode <= 0)
                return;
            int kArray = 999999;
            DllClass1.stringArray(nameNode, ref kArray);
            DllClass1.doubleArray(xNode, ref kArray);
            DllClass1.doubleArray(yNode, ref kArray);
            if (kNode > kArray)
            {
                int num = (int)MessageBox.Show("Индекс массива DrawNode");
            }
            else
            {
                SolidBrush solidBrush = new SolidBrush(Color.Cyan);
                for (int index = 1; index <= kNode; ++index)
                {
                    DllClass1.XYtoWIN(xNode[index], yNode[index], scaleToWin, xBegX, yBegY, xBegWin, yBegWin, out xWin, out yWin);
                    if (xWin != 0 || yWin != 0)
                    {
                        graphics.FillRectangle((Brush)new SolidBrush(Color.Cyan), xWin - 2, yWin - 2, 5, 5);
                        graphics.DrawString(nameNode[index], new Font("Bold", (float)emSize), (Brush)solidBrush, (float)(xWin + emSize / 2), (float)(yWin - emSize + 2));
                    }
                }
            }
        }

        public static void InputLineStyle(
          PaintEventArgs e,
          SolidBrush iColor,
          Pen jColor,
          int iStyle,
          int iWid,
          int kr,
          double[] xr,
          double[] yr,
          double[] x,
          double[] y,
          double scaleWin,
          double xBegX,
          double yBegY,
          int xBegWin,
          int yBegWin)
        {
            Graphics graphics = e.Graphics;
            double num1 = 3.1415926;
            double num2;
            double num3 = num2 = 0.0;
            int num4;
            int num5 = num4 = 0;
            int yWin = num4;
            int xWin = num4;
            int kArray = 999999;
            doubleArray(xr, ref kArray);
            doubleArray(yr, ref kArray);
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            int num6 = kArray - 3;
            if (kr > num6)
            {
                int num7 = (int)MessageBox.Show("Индекс массива InputLineStyle");
            }
            else
            {
                if (iStyle > 7)
                    return;
                jColor.DashStyle = DashStyle.Solid;
                int iLine;
                int iBlank;
                int iDop;
                StyleParameters(iStyle, out iLine, out iBlank, out iDop);
                double num8 = 1.0 * (double)iLine;
                double num9 = 1.0 * (double)iBlank;
                double num10 = 1.0 * (double)iDop;
                int num11 = kr;
                for (int i = 0; i <= kr; ++i)
                {
                    XYtoWIN(xr[i], yr[i], scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin, out yWin);
                    x[i] = (double)xWin;
                    y[i] = (double)yWin;
                }
                jColor.Width = (float)iWid;
                for (int i = 1; i <= num11; ++i)
                {
                    double x1 = x[i] - x[i - 1];
                    double y1 = y[i] - y[i - 1];
                    double num12 = Math.Sqrt(x1 * x1 + y1 * y1);
                    double num13 = Math.Atan2(y1, x1);
                    if (num13 < 0.0)
                        num13 += 2.0 * num1;
                    if (iStyle == 1 || iStyle == 2)
                    {
                        int int32_1 = Convert.ToInt32(x[i - 1]);
                        int int32_2 = Convert.ToInt32(y[i - 1]);
                        int int32_3 = Convert.ToInt32(x[i]);
                        int int32_4 = Convert.ToInt32(y[i]);
                        graphics.DrawLine(jColor, int32_1, int32_2, int32_3, int32_4);
                    }
                    else
                    {
                        if (iStyle == 3 || iStyle == 4)
                        {
                            double num14 = x[i - 1];
                            double num15 = y[i - 1];
                            double num16 = 0.0;
                            do
                            {
                                double num17 = num16 + num8;
                                if (num17 >= num12)
                                {
                                    num3 = x[i];
                                    num2 = y[i];
                                    int int32_5 = Convert.ToInt32(num14);
                                    int int32_6 = Convert.ToInt32(num15);
                                    int int32_7 = Convert.ToInt32(num3);
                                    int int32_8 = Convert.ToInt32(num2);
                                    graphics.DrawLine(jColor, int32_5, int32_6, int32_7, int32_8);
                                    break;
                                }
                                if (num17 < num12)
                                {
                                    num3 = num14 + num8 * Math.Cos(num13);
                                    num2 = num15 + num8 * Math.Sin(num13);
                                    int int32_9 = Convert.ToInt32(num14);
                                    int int32_10 = Convert.ToInt32(num15);
                                    int int32_11 = Convert.ToInt32(num3);
                                    int int32_12 = Convert.ToInt32(num2);
                                    graphics.DrawLine(jColor, int32_9, int32_10, int32_11, int32_12);
                                }
                                num16 = num17 + num9;
                                if (num16 < num12)
                                {
                                    num14 = num3 + num9 * Math.Cos(num13);
                                    num15 = num2 + num9 * Math.Sin(num13);
                                }
                                else
                                    break;
                            }
                            while (num16 < num12);
                        }
                        if (iStyle == 5)
                        {
                            double num18 = x[i - 1];
                            double num19 = y[i - 1];
                            double num20 = 0.0;
                            do
                            {
                                double num21 = num20 + num8;
                                if (num21 >= num12)
                                {
                                    num3 = x[i];
                                    num2 = y[i];
                                    int int32_13 = Convert.ToInt32(num18);
                                    int int32_14 = Convert.ToInt32(num19);
                                    int int32_15 = Convert.ToInt32(num3);
                                    int int32_16 = Convert.ToInt32(num2);
                                    graphics.DrawLine(jColor, int32_13, int32_14, int32_15, int32_16);
                                    break;
                                }
                                if (num21 < num12)
                                {
                                    num3 = num18 + num8 * Math.Cos(num13);
                                    num2 = num19 + num8 * Math.Sin(num13);
                                    int int32_17 = Convert.ToInt32(num18);
                                    int int32_18 = Convert.ToInt32(num19);
                                    int int32_19 = Convert.ToInt32(num3);
                                    int int32_20 = Convert.ToInt32(num2);
                                    graphics.DrawLine(jColor, int32_17, int32_18, int32_19, int32_20);
                                }
                                double num22 = num21 + num9;
                                if (num22 < num12)
                                {
                                    double num23 = num3 + num9 * Math.Cos(num13);
                                    double num24 = num2 + num9 * Math.Sin(num13);
                                    double num25 = num22 + num10;
                                    if (num25 >= num12)
                                    {
                                        num3 = x[i];
                                        num2 = y[i];
                                        int int32_21 = Convert.ToInt32(num23);
                                        int int32_22 = Convert.ToInt32(num24);
                                        int int32_23 = Convert.ToInt32(num3);
                                        int int32_24 = Convert.ToInt32(num2);
                                        graphics.DrawLine(jColor, int32_21, int32_22, int32_23, int32_24);
                                        break;
                                    }
                                    if (num25 < num12)
                                    {
                                        num3 = num23 + num10 * Math.Cos(num13);
                                        num2 = num24 + num10 * Math.Sin(num13);
                                        int int32_25 = Convert.ToInt32(num23);
                                        int int32_26 = Convert.ToInt32(num24);
                                        int int32_27 = Convert.ToInt32(num3);
                                        int int32_28 = Convert.ToInt32(num2);
                                        graphics.DrawLine(jColor, int32_25, int32_26, int32_27, int32_28);
                                    }
                                    num20 = num25 + num9;
                                    if (num20 < num12)
                                    {
                                        num18 = num3 + num9 * Math.Cos(num13);
                                        num19 = num2 + num9 * Math.Sin(num13);
                                    }
                                    else
                                        break;
                                }
                                else
                                    break;
                            }
                            while (num20 < num12);
                        }
                        if (iStyle == 6)
                        {
                            double num26 = x[i - 1];
                            double num27 = y[i - 1];
                            double num28 = 0.0;
                            do
                            {
                                double num29 = num28 + num8;
                                if (num29 >= num12)
                                {
                                    num3 = x[i];
                                    num2 = y[i];
                                    int int32_29 = Convert.ToInt32(num26);
                                    int int32_30 = Convert.ToInt32(num27);
                                    int int32_31 = Convert.ToInt32(num3);
                                    int int32_32 = Convert.ToInt32(num2);
                                    graphics.DrawLine(jColor, int32_29, int32_30, int32_31, int32_32);
                                    break;
                                }
                                if (num29 < num12)
                                {
                                    num3 = num26 + num8 * Math.Cos(num13);
                                    num2 = num27 + num8 * Math.Sin(num13);
                                    int int32_33 = Convert.ToInt32(num26);
                                    int int32_34 = Convert.ToInt32(num27);
                                    int int32_35 = Convert.ToInt32(num3);
                                    int int32_36 = Convert.ToInt32(num2);
                                    graphics.DrawLine(jColor, int32_33, int32_34, int32_35, int32_36);
                                }
                                double num30 = num29 + num9;
                                if (num30 < num12)
                                {
                                    double num31 = num3 + num9 * Math.Cos(num13);
                                    double num32 = num2 + num9 * Math.Sin(num13);
                                    num3 = num31;
                                    num2 = num32;
                                    int int32_37 = Convert.ToInt32(num31);
                                    int int32_38 = Convert.ToInt32(num32);
                                    graphics.FillRectangle((Brush)iColor, int32_37 - 1, int32_38 - 1, 2, 2);
                                    num28 = num30 + num9;
                                    if (num28 < num12)
                                    {
                                        num26 = num3 + num9 * Math.Cos(num13);
                                        num27 = num2 + num9 * Math.Sin(num13);
                                    }
                                    else
                                        break;
                                }
                                else
                                    break;
                            }
                            while (num28 < num12);
                        }
                        if (iStyle == 7)
                        {
                            double num33 = x[i - 1];
                            double num34 = y[i - 1];
                            double num35 = 0.0;
                            do
                            {
                                num35 += num9;
                                if (num35 < num12)
                                {
                                    num3 = num33 + num9 * Math.Cos(num13);
                                    num2 = num34 + num9 * Math.Sin(num13);
                                    num33 = num3;
                                    num34 = num2;
                                    int int32_39 = Convert.ToInt32(num33);
                                    int int32_40 = Convert.ToInt32(num34);
                                    graphics.FillRectangle((Brush)iColor, int32_39 - 1, int32_40 - 1, 2, 2);
                                }
                                else
                                    break;
                            }
                            while (num35 < num12);
                        }
                    }
                }
                jColor.DashStyle = DashStyle.Solid;
            }
        }

        public static void StyleParameters(int iStyle, out int iLine, out int iBlank, out int iDop)
        {
            iLine = 0;
            iBlank = 3;
            iDop = 0;
            if (iStyle == 1 || iStyle == 2)
            {
                iLine = 16;
                iBlank = 0;
            }
            if (iStyle == 3)
                iLine = 16;
            if (iStyle == 4)
                iLine = 8;
            if (iStyle == 5)
            {
                iLine = 16;
                iDop = 8;
            }
            if (iStyle == 6)
            {
                iLine = 16;
                iDop = 2;
            }
            if (iStyle != 7)
                return;
            iLine = 0;
            iDop = 2;
        }

        public static void SplineToSpl(
          int k,
          double[] x,
          double[] y,
          out int ks,
          double[] xs,
          double[] ys)
        {
            double num1 = 3.1415926;
            double num2 = 0.2;
            int kArray = 999999;
            doubleArray(xs, ref kArray);
            doubleArray(ys, ref kArray);
            int num3 = kArray - 3;
            ks = 0;
            xs[ks] = x[0];
            ys[ks] = y[0];
            for (int i = 1; i <= k; ++i)
            {
                double x1 = x[i] - x[i - 1];
                double y1 = y[i] - y[i - 1];
                double num4 = Math.Sqrt(x1 * x1 + y1 * y1);
                if (num4 <= num2)
                {
                    if (ks > num3)
                    {
                        int num5 = (int)MessageBox.Show("Индекс массива SplineToSpl");
                        break;
                    }
                    ++ks;
                    xs[ks] = x[i];
                    ys[ks] = y[i];
                }
                else
                {
                    double num6 = Math.Atan2(y1, x1);
                    if (num6 < 0.0)
                        num6 += 2.0 * num1;
                    double num7 = 0.0;
                    do
                    {
                        num7 += num2;
                        if (num7 >= num4)
                        {
                            if (num7 - num4 < 0.2 * num2)
                            {
                                if (ks > num3)
                                {
                                    int num8 = (int)MessageBox.Show("Индекс массива SplineToSpl");
                                    return;
                                }
                                ++ks;
                                xs[ks] = x[i];
                                ys[ks] = y[i];
                                break;
                            }
                            xs[ks] = x[i];
                            ys[ks] = y[i];
                            break;
                        }
                        if (num7 < num4)
                        {
                            if (num4 - num7 < 0.2 * num2)
                            {
                                if (ks > num3)
                                {
                                    int num9 = (int)MessageBox.Show("Индекс массива SplineToSpl");
                                    return;
                                }
                                ++ks;
                                xs[ks] = x[i];
                                ys[ks] = y[i];
                                break;
                            }
                            ++ks;
                            xs[ks] = x[i - 1] + num7 * Math.Cos(num6);
                            ys[ks] = y[i - 1] + num7 * Math.Sin(num6);
                        }
                    }
                    while (num7 < num4);
                }
            }
        }

        public static void SelItemLine(
          string fitemLine,
          int nSelect,
          out int iLong,
          out int iWid,
          out int iHei,
          out int kPix,
          int[] ixSqu,
          int[] iySqu,
          int[] nColor,
          out string sTxt,
          out int mClr)
        {
            iLong = 0;
            iWid = 0;
            iHei = 0;
            kPix = 0;
            mClr = 0;
            sTxt = "";
            if (nSelect == 0 || !File.Exists(fitemLine))
                return;
            FileStream input = new FileStream(fitemLine, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            try
            {
                for (int i1 = 1; i1 <= nSelect; ++i1)
                {
                    binaryReader.ReadString();
                    iLong = binaryReader.ReadInt32();
                    if (iLong == 0)
                    {
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        iWid = binaryReader.ReadInt32();
                        iHei = binaryReader.ReadInt32();
                        kPix = binaryReader.ReadInt32();
                        if (kPix > 0)
                        {
                            for (int i2 = 1; i2 <= kPix; ++i2)
                            {
                                ixSqu[i2] = binaryReader.ReadInt32();
                                iySqu[i2] = binaryReader.ReadInt32();
                                nColor[i2] = binaryReader.ReadInt32();
                            }
                        }
                    }
                    if (iLong > 0)
                    {
                        binaryReader.ReadInt32();
                        mClr = binaryReader.ReadInt32();
                        sTxt = binaryReader.ReadString();
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        iWid = binaryReader.ReadInt32();
                        iHei = binaryReader.ReadInt32();
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            binaryReader.Close();
            input.Close();
        }

        public static void InputItemDraw(
          PaintEventArgs e,
          string fitemLine,
          int kItem,
          int[] numSign,
          int[] numItem,
          double[] xItem,
          double[] yItem,
          double[] az,
          int[] itemLoc,
          int[] nBaseSymb,
          string[] sInscr,
          double[] hInscr,
          int[] iColInscr,
          int kSymbLine,
          int[] ixSqu,
          int[] iySqu,
          int[] nColorItm,
          double scaleToWin,
          double xBegX,
          double yBegY,
          int xBegWin,
          int yBegWin,
          int[] nDop1,
          int[] nDop2,
          SolidBrush[] brColor)
        {
            double num1 = 3.1415926;
            double num2 = 0.254;
            int iLong = 0;
            for (int i1 = 1; i1 <= kItem; ++i1)
            {
                double num3 = az[i1];
                double num4 = num3 + 0.5 * num1;
                if (num4 > 2.0 * num1)
                    num4 -= 2.0 * num1;
                int i2 = numSign[i1];
                int nSelect = numItem[i1];
                int num5 = itemLoc[i2];
                int num6 = nBaseSymb[i2];
                int xWin;
                int yWin;
                XYtoWIN(xItem[i1], yItem[i1], scaleToWin, xBegX, yBegY, xBegWin, yBegWin, out xWin, out yWin);
                if (nSelect > 0)
                {
                    int iWid;
                    int iHei;
                    int kPix;
                    string sTxt;
                    int mClr;
                    SelItemLine(fitemLine, nSelect, out iLong, out iWid, out iHei, out kPix, ixSqu, iySqu, nColorItm, out sTxt, out mClr);
                    if (iLong == 0)
                    {
                        int num7 = iWid / 2;
                        int num8 = iHei / 2;
                        int num9 = xWin - Convert.ToInt32((double)num8 * Math.Cos(num4));
                        int num10 = yWin - Convert.ToInt32((double)num8 * Math.Sin(num4));
                        xWin = num9 - Convert.ToInt32((double)num7 * Math.Cos(num3));
                        yWin = num10 - Convert.ToInt32((double)num7 * Math.Sin(num3));
                        if (num5 == 1)
                        {
                            if (num6 < 8)
                            {
                                xWin -= Convert.ToInt32((double)num8 * Math.Cos(num4));
                                yWin -= Convert.ToInt32((double)num8 * Math.Sin(num4));
                            }
                            if (num6 == 8)
                            {
                                xWin -= Convert.ToInt32((double)iHei * Math.Cos(num4));
                                yWin -= Convert.ToInt32((double)iHei * Math.Sin(num4));
                            }
                        }
                        if (num5 == 3)
                        {
                            if (num6 < 8)
                            {
                                xWin += Convert.ToInt32((double)num8 * Math.Cos(num4));
                                yWin += Convert.ToInt32((double)num8 * Math.Sin(num4));
                            }
                            if (num6 == 8)
                            {
                                xWin += Convert.ToInt32((double)iHei * Math.Cos(num4));
                                yWin += Convert.ToInt32((double)iHei * Math.Sin(num4));
                            }
                        }
                        for (int i3 = 1; i3 <= kPix; ++i3)
                        {
                            nDop1[i3] = Convert.ToInt32((double)ixSqu[i3] * Math.Cos(num3)) - Convert.ToInt32((double)iySqu[i3] * Math.Sin(num3));
                            nDop2[i3] = Convert.ToInt32((double)ixSqu[i3] * Math.Sin(num3)) + Convert.ToInt32((double)iySqu[i3] * Math.Cos(num3));
                        }
                        SignDraw(e, xWin, yWin, kPix, nDop1, nDop2, nColorItm, brColor);
                    }
                    if (iLong > 0)
                    {
                        sTxt = sInscr[i2];
                        double num11 = hInscr[i2];
                        mClr = iColInscr[i2];
                        int length = sTxt.Length;
                        SolidBrush iColor = brColor[mClr];
                        int int32_1 = Convert.ToInt32(num11 / num2);
                        int int32_2 = Convert.ToInt32(0.8 * (double)int32_1);
                        int angle = RadGrad(num3);
                        if (num5 == 1)
                        {
                            if (num6 < 8)
                            {
                                xWin -= Convert.ToInt32((double)int32_2 * Math.Cos(num4));
                                yWin -= Convert.ToInt32((double)int32_2 * Math.Sin(num4));
                            }
                            if (num6 == 8)
                            {
                                xWin -= Convert.ToInt32((double)int32_1 * Math.Cos(num4));
                                yWin -= Convert.ToInt32((double)int32_1 * Math.Sin(num4));
                            }
                        }
                        if (num5 == 3)
                        {
                            if (num6 < 8)
                            {
                                xWin += Convert.ToInt32((double)int32_2 * Math.Cos(num4));
                                yWin += Convert.ToInt32((double)int32_2 * Math.Sin(num4));
                            }
                            if (num6 == 8)
                            {
                                xWin += Convert.ToInt32((double)int32_1 * Math.Cos(num4));
                                yWin += Convert.ToInt32((double)int32_1 * Math.Sin(num4));
                            }
                        }
                        RotText(e, sTxt, xWin, yWin, int32_1, angle, iColor, 1);
                    }
                }
            }
        }

        public static void DrawInputLine(
          PaintEventArgs e,
          int kLine,
          int[] k1,
          int[] k2,
          double[] xLin,
          double[] yLin,
          int[] nSymb,
          double[] dstLine,
          double[] rRad,
          double[] xRad,
          double[] yRad,
          double scaleWin,
          double xBeg,
          double yBeg,
          int xWin,
          int yWin,
          int[] nColLine,
          int[] iWd1,
          int[] iWd2,
          int[] iSt1,
          int[] iSt2,
          int[] nBase,
          double[] x,
          double[] y,
          double[] xit,
          double[] yit,
          double[] xr,
          double[] yr,
          int kSymbLine,
          int[] n1Sign,
          int[] n2Sign,
          SolidBrush[] brColor,
          Pen[] pnColor,
          int iParam)
        {
            Graphics graphics = e.Graphics;
            double num1 = 3.1415926;
            double Dist = 0.0;
            double rd1 = 0.0;
            if (kLine == 0)
                return;
            int kArray = 999999;
            intArray(k1, ref kArray);
            intArray(k2, ref kArray);
            intArray(nSymb, ref kArray);
            doubleArray(dstLine, ref kArray);
            doubleArray(rRad, ref kArray);
            doubleArray(xRad, ref kArray);
            doubleArray(yRad, ref kArray);
            kArray -= 3;
            if (kLine > kArray)
            {
                int num2 = (int)MessageBox.Show("Индекс массива DrawInputLine");
            }
            else
            {
                int num3 = k2[kLine];
                kArray = 999999;
                doubleArray(xLin, ref kArray);
                doubleArray(yLin, ref kArray);
                doubleArray(x, ref kArray);
                doubleArray(y, ref kArray);
                doubleArray(xr, ref kArray);
                doubleArray(yr, ref kArray);
                doubleArray(xit, ref kArray);
                doubleArray(yit, ref kArray);
                if (num3 > kArray)
                {
                    int num4 = (int)MessageBox.Show("Индекс массива DrawInputLine");
                }
                else
                {
                    for (int i1 = 1; i1 <= kLine; ++i1)
                    {
                        int i2 = 0;
                        for (int i3 = 1; i3 <= kSymbLine; ++i3)
                        {
                            if (n2Sign[i3] > 0 && n2Sign[i3] == nSymb[i1])
                            {
                                i2 = n1Sign[i3];
                                break;
                            }
                        }
                        if (i2 == 0)
                        {
                            for (int i4 = 1; i4 <= kSymbLine; ++i4)
                            {
                                if (n1Sign[i4] > 0 && n1Sign[i4] == nSymb[i1])
                                {
                                    i2 = n1Sign[i4];
                                    break;
                                }
                            }
                        }
                        int i5 = nColLine[i2];
                        if (iParam > 0)
                            i5 = 3;
                        int iWid1 = iWd1[i2];
                        int iWid2 = iWd2[i2];
                        int iStyle1 = iSt1[i2];
                        int iStyle2 = iSt2[i2];
                        int num5 = nBase[i2];
                        double num6 = dstLine[i1];
                        if (num6 == 0.0)
                            Dist = 1.0;
                        if (num6 > 0.0)
                            Dist = 0.5 * num6;
                        SolidBrush iColor = brColor[i5];
                        Pen pen = pnColor[i5];
                        int num7 = k1[i1];
                        int num8 = k2[i1];
                        int k = -1;
                        int i6 = -1;
                        int xWin1;
                        int yWin1;
                        for (int i7 = num7; i7 <= num8; ++i7)
                        {
                            XYtoWIN(xLin[i7], yLin[i7], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                            ++k;
                            x[k] = (double)xWin1;
                            y[k] = (double)yWin1;
                            ++i6;
                            xr[i6] = xLin[i7];
                            yr[i6] = yLin[i7];
                        }
                        int iStyle3 = iStyle1;
                        int num9 = iWid1;
                        int iLine;
                        int iBlank;
                        int iDop;
                        StyleParameters(iStyle3, out iLine, out iBlank, out iDop);
                        if (rRad[i1] > 0.0)
                        {
                            if (rRad[i1] == 1.0)
                            {
                                SplineToSpl(i6, xr, yr, out k, xit, yit);
                                for (int i8 = 0; i8 <= k; ++i8)
                                {
                                    XYtoWIN(xit[i8], yit[i8], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                                    x[i8] = (double)xWin1;
                                    y[i8] = (double)yWin1;
                                }
                            }
                            int num10 = 0;
                            for (int i9 = 1; i9 <= k; ++i9)
                            {
                                double num11 = x[i9] - x[i9 - 1];
                                double num12 = y[i9] - y[i9 - 1];
                                int int32 = Convert.ToInt32(Math.Sqrt(num11 * num11 + num12 * num12));
                                num10 += int32;
                                if (num10 >= iLine)
                                {
                                    num10 = i9;
                                    break;
                                }
                            }
                            int num13 = 0;
                            for (int i10 = 1; i10 <= k; ++i10)
                            {
                                double num14 = x[i10] - x[i10 - 1];
                                double num15 = y[i10] - y[i10 - 1];
                                int int32 = Convert.ToInt32(Math.Sqrt(num14 * num14 + num15 * num15));
                                num13 += int32;
                                if (num13 >= iBlank)
                                {
                                    num13 = i10;
                                    break;
                                }
                            }
                            int num16 = 0;
                            for (int i11 = 1; i11 <= k; ++i11)
                            {
                                double num17 = x[i11] - x[i11 - 1];
                                double num18 = y[i11] - y[i11 - 1];
                                int int32 = Convert.ToInt32(Math.Sqrt(num17 * num17 + num18 * num18));
                                num16 += int32;
                                if (num16 >= iDop)
                                {
                                    num16 = i11;
                                    break;
                                }
                            }
                            int num19;
                            if (num5 < 8)
                            {
                                if (iStyle3 == 1 || iStyle3 == 2)
                                {
                                    pen.Width = (float)num9;
                                    for (int i12 = 1; i12 <= k; ++i12)
                                    {
                                        int int32_1 = Convert.ToInt32(x[i12 - 1]);
                                        int int32_2 = Convert.ToInt32(y[i12 - 1]);
                                        int int32_3 = Convert.ToInt32(x[i12]);
                                        int int32_4 = Convert.ToInt32(y[i12]);
                                        graphics.DrawLine(pen, int32_1, int32_2, int32_3, int32_4);
                                    }
                                }
                                if (iStyle3 == 3 || iStyle3 == 4)
                                {
                                    pen.Width = (float)num9;
                                    int num20 = 0;
                                    num19 = 0;
                                    int num21;
                                    do
                                    {
                                        num21 = num20 + num10;
                                        if (num20 < k && num21 >= k)
                                        {
                                            if (k - num20 >= 2)
                                            {
                                                for (int i13 = num20 + 1; i13 <= k; ++i13)
                                                {
                                                    int int32_5 = Convert.ToInt32(x[i13 - 1]);
                                                    int int32_6 = Convert.ToInt32(y[i13 - 1]);
                                                    int int32_7 = Convert.ToInt32(x[i13]);
                                                    int int32_8 = Convert.ToInt32(y[i13]);
                                                    graphics.DrawLine(pen, int32_5, int32_6, int32_7, int32_8);
                                                }
                                                break;
                                            }
                                            break;
                                        }
                                        for (int i14 = num20 + 1; i14 <= num21; ++i14)
                                        {
                                            int int32_9 = Convert.ToInt32(x[i14 - 1]);
                                            int int32_10 = Convert.ToInt32(y[i14 - 1]);
                                            int int32_11 = Convert.ToInt32(x[i14]);
                                            int int32_12 = Convert.ToInt32(y[i14]);
                                            graphics.DrawLine(pen, int32_9, int32_10, int32_11, int32_12);
                                        }
                                        num20 = num21 + num13;
                                    }
                                    while (num20 < k && num21 < k);
                                }
                                if (iStyle3 == 5)
                                {
                                    pen.Width = (float)num9;
                                    int num22 = 0;
                                    num19 = 0;
                                    int num23;
                                    do
                                    {
                                        int num24 = num22 + num10;
                                        if (num22 < k && num24 >= k)
                                        {
                                            if (k - num22 >= 2)
                                            {
                                                for (int i15 = num22 + 1; i15 <= k; ++i15)
                                                {
                                                    int int32_13 = Convert.ToInt32(x[i15 - 1]);
                                                    int int32_14 = Convert.ToInt32(y[i15 - 1]);
                                                    int int32_15 = Convert.ToInt32(x[i15]);
                                                    int int32_16 = Convert.ToInt32(y[i15]);
                                                    graphics.DrawLine(pen, int32_13, int32_14, int32_15, int32_16);
                                                }
                                                break;
                                            }
                                            break;
                                        }
                                        for (int i16 = num22 + 1; i16 <= num24; ++i16)
                                        {
                                            int int32_17 = Convert.ToInt32(x[i16 - 1]);
                                            int int32_18 = Convert.ToInt32(y[i16 - 1]);
                                            int int32_19 = Convert.ToInt32(x[i16]);
                                            int int32_20 = Convert.ToInt32(y[i16]);
                                            graphics.DrawLine(pen, int32_17, int32_18, int32_19, int32_20);
                                        }
                                        int num25 = num24 + num13;
                                        if (num25 < k)
                                        {
                                            num23 = num25 + num16;
                                            if (num23 <= k)
                                            {
                                                for (int i17 = num25 + 1; i17 <= num23; ++i17)
                                                {
                                                    int int32_21 = Convert.ToInt32(x[i17 - 1]);
                                                    int int32_22 = Convert.ToInt32(y[i17 - 1]);
                                                    int int32_23 = Convert.ToInt32(x[i17]);
                                                    int int32_24 = Convert.ToInt32(y[i17]);
                                                    graphics.DrawLine(pen, int32_21, int32_22, int32_23, int32_24);
                                                }
                                                num22 = num23 + num13;
                                            }
                                            else
                                                break;
                                        }
                                        else
                                            break;
                                    }
                                    while (num22 < k && num23 < k);
                                }
                                if (iStyle3 == 6)
                                {
                                    pen.Width = (float)num9;
                                    int num26 = 0;
                                    num19 = 0;
                                    int num27;
                                    do
                                    {
                                        num27 = num26 + num10;
                                        if (num26 < k && num27 >= k)
                                        {
                                            if (k - num26 >= 2)
                                            {
                                                for (int i18 = num26 + 1; i18 <= k; ++i18)
                                                {
                                                    int int32_25 = Convert.ToInt32(x[i18 - 1]);
                                                    int int32_26 = Convert.ToInt32(y[i18 - 1]);
                                                    int int32_27 = Convert.ToInt32(x[i18]);
                                                    int int32_28 = Convert.ToInt32(y[i18]);
                                                    graphics.DrawLine(pen, int32_25, int32_26, int32_27, int32_28);
                                                }
                                                break;
                                            }
                                            break;
                                        }
                                        for (int i19 = num26 + 1; i19 <= num27; ++i19)
                                        {
                                            int int32_29 = Convert.ToInt32(x[i19 - 1]);
                                            int int32_30 = Convert.ToInt32(y[i19 - 1]);
                                            int int32_31 = Convert.ToInt32(x[i19]);
                                            int int32_32 = Convert.ToInt32(y[i19]);
                                            graphics.DrawLine(pen, int32_29, int32_30, int32_31, int32_32);
                                        }
                                        int i20 = num27 + num13 + num16;
                                        if (i20 < k)
                                        {
                                            int int32_33 = Convert.ToInt32(x[i20]);
                                            int int32_34 = Convert.ToInt32(y[i20]);
                                            graphics.FillRectangle((Brush)iColor, int32_33 - 1, int32_34 - 1, 2, 2);
                                            num26 = i20 + num13;
                                        }
                                        else
                                            break;
                                    }
                                    while (num26 < k && num27 < k);
                                }
                                if (iStyle3 == 7)
                                {
                                    int i21 = 0;
                                    do
                                    {
                                        i21 += num13;
                                        if (i21 < k)
                                        {
                                            int int32_35 = Convert.ToInt32(x[i21]);
                                            int int32_36 = Convert.ToInt32(y[i21]);
                                            graphics.FillRectangle((Brush)iColor, int32_35 - 1, int32_36 - 1, 2, 2);
                                        }
                                        else
                                            break;
                                    }
                                    while (i21 < k);
                                }
                            }
                            if (num5 == 8)
                            {
                                for (int i22 = 1; i22 <= 2; ++i22)
                                {
                                    if (rRad[i1] > 1.0)
                                    {
                                        if (i22 == 1)
                                        {
                                            rd1 = rRad[i1] - Dist;
                                            iStyle3 = iStyle1;
                                            num9 = iWid1;
                                        }
                                        if (i22 == 2)
                                        {
                                            rd1 = rRad[i1] + Dist;
                                            iStyle3 = iStyle2;
                                            num9 = iWid2;
                                        }
                                        double xrd1 = xRad[i1];
                                        double yrd1 = yRad[i1];
                                        ParallelArcCircle(i6, ref xr, ref yr, ref rd1, ref xrd1, ref yrd1, out k, ref x, ref y, out double _, out double _, out double _, ref xit, ref yit);
                                        if (k < 2)
                                            continue;
                                    }
                                    if (rRad[i1] == 1.0)
                                    {
                                        double ySel;
                                        double xSel = ySel = 0.0;
                                        if (i22 == 1)
                                        {
                                            double x1 = xr[1] - xr[0];
                                            double num28 = Math.Atan2(yr[1] - yr[0], x1);
                                            if (num28 < 0.0)
                                                num28 += 2.0 * num1;
                                            double num29 = num28 - 0.5 * num1;
                                            if (num29 < 0.0)
                                                num29 += 2.0 * num1;
                                            double num30 = 0.5 * (xr[1] + xr[0]);
                                            double num31 = 0.5 * (yr[1] + yr[0]);
                                            xSel = num30 + Dist * Math.Cos(num29);
                                            ySel = num31 + Dist * Math.Sin(num29);
                                            iStyle3 = iStyle1;
                                            num9 = iWid1;
                                        }
                                        if (i22 == 2)
                                        {
                                            double x2 = xr[1] - xr[0];
                                            double num32 = Math.Atan2(yr[1] - yr[0], x2);
                                            if (num32 < 0.0)
                                                num32 += 2.0 * num1;
                                            double num33 = num32 - 0.5 * num1;
                                            if (num33 < 0.0)
                                                num33 += 2.0 * num1;
                                            double num34 = 0.5 * (xr[1] + xr[0]);
                                            double num35 = 0.5 * (yr[1] + yr[0]);
                                            xSel = num34 - Dist * Math.Cos(num33);
                                            ySel = num35 - Dist * Math.Sin(num33);
                                            iStyle3 = iStyle2;
                                            num9 = iWid2;
                                        }
                                        ParallelLine(xSel, ySel, Dist, i6, ref xr, ref yr, out k, ref x, ref y);
                                        int ks;
                                        SplineToSpl(k, x, y, out ks, xit, yit);
                                        k = ks;
                                        for (int i23 = 0; i23 <= k; ++i23)
                                        {
                                            x[i23] = xit[i23];
                                            y[i23] = yit[i23];
                                        }
                                    }
                                    for (int i24 = 0; i24 <= k; ++i24)
                                    {
                                        XYtoWIN(x[i24], y[i24], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                                        x[i24] = (double)xWin1;
                                        y[i24] = (double)yWin1;
                                    }
                                    if (iStyle3 == 1 || iStyle3 == 2)
                                    {
                                        pen.Width = (float)num9;
                                        for (int i25 = 1; i25 <= k; ++i25)
                                        {
                                            int int32_37 = Convert.ToInt32(x[i25 - 1]);
                                            int int32_38 = Convert.ToInt32(y[i25 - 1]);
                                            int int32_39 = Convert.ToInt32(x[i25]);
                                            int int32_40 = Convert.ToInt32(y[i25]);
                                            graphics.DrawLine(pen, int32_37, int32_38, int32_39, int32_40);
                                        }
                                    }
                                    if (iStyle3 == 3 || iStyle3 == 4)
                                    {
                                        pen.Width = (float)num9;
                                        int num36 = 0;
                                        num19 = 0;
                                        int num37;
                                        do
                                        {
                                            num37 = num36 + num10;
                                            if (num36 < k && num37 >= k)
                                            {
                                                if (k - num36 >= 2)
                                                {
                                                    for (int i26 = num36 + 1; i26 <= k; ++i26)
                                                    {
                                                        int int32_41 = Convert.ToInt32(x[i26 - 1]);
                                                        int int32_42 = Convert.ToInt32(y[i26 - 1]);
                                                        int int32_43 = Convert.ToInt32(x[i26]);
                                                        int int32_44 = Convert.ToInt32(y[i26]);
                                                        graphics.DrawLine(pen, int32_41, int32_42, int32_43, int32_44);
                                                    }
                                                    break;
                                                }
                                                break;
                                            }
                                            for (int i27 = num36 + 1; i27 <= num37; ++i27)
                                            {
                                                int int32_45 = Convert.ToInt32(x[i27 - 1]);
                                                int int32_46 = Convert.ToInt32(y[i27 - 1]);
                                                int int32_47 = Convert.ToInt32(x[i27]);
                                                int int32_48 = Convert.ToInt32(y[i27]);
                                                graphics.DrawLine(pen, int32_45, int32_46, int32_47, int32_48);
                                            }
                                            num36 = num37 + num13;
                                        }
                                        while (num36 < k && num37 < k);
                                    }
                                    if (iStyle3 == 5)
                                    {
                                        pen.Width = (float)num9;
                                        int num38 = 0;
                                        num19 = 0;
                                        int num39;
                                        do
                                        {
                                            int num40 = num38 + num10;
                                            if (num38 < k && num40 >= k)
                                            {
                                                if (k - num38 >= 2)
                                                {
                                                    for (int i28 = num38 + 1; i28 <= k; ++i28)
                                                    {
                                                        int int32_49 = Convert.ToInt32(x[i28 - 1]);
                                                        int int32_50 = Convert.ToInt32(y[i28 - 1]);
                                                        int int32_51 = Convert.ToInt32(x[i28]);
                                                        int int32_52 = Convert.ToInt32(y[i28]);
                                                        graphics.DrawLine(pen, int32_49, int32_50, int32_51, int32_52);
                                                    }
                                                    break;
                                                }
                                                break;
                                            }
                                            for (int i29 = num38 + 1; i29 <= num40; ++i29)
                                            {
                                                int int32_53 = Convert.ToInt32(x[i29 - 1]);
                                                int int32_54 = Convert.ToInt32(y[i29 - 1]);
                                                int int32_55 = Convert.ToInt32(x[i29]);
                                                int int32_56 = Convert.ToInt32(y[i29]);
                                                graphics.DrawLine(pen, int32_53, int32_54, int32_55, int32_56);
                                            }
                                            int num41 = num40 + num13;
                                            if (num41 < k)
                                            {
                                                num39 = num41 + num16;
                                                if (num39 <= k)
                                                {
                                                    for (int i30 = num41 + 1; i30 <= num39; ++i30)
                                                    {
                                                        int int32_57 = Convert.ToInt32(x[i30 - 1]);
                                                        int int32_58 = Convert.ToInt32(y[i30 - 1]);
                                                        int int32_59 = Convert.ToInt32(x[i30]);
                                                        int int32_60 = Convert.ToInt32(y[i30]);
                                                        graphics.DrawLine(pen, int32_57, int32_58, int32_59, int32_60);
                                                    }
                                                    num38 = num39 + num13;
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                        while (num38 < k && num39 < k);
                                    }
                                    if (iStyle3 == 6)
                                    {
                                        pen.Width = (float)num9;
                                        int num42 = 0;
                                        num19 = 0;
                                        int num43;
                                        do
                                        {
                                            num43 = num42 + num10;
                                            if (num42 < k && num43 >= k)
                                            {
                                                if (k - num42 >= 2)
                                                {
                                                    for (int i31 = num42 + 1; i31 <= k; ++i31)
                                                    {
                                                        int int32_61 = Convert.ToInt32(x[i31 - 1]);
                                                        int int32_62 = Convert.ToInt32(y[i31 - 1]);
                                                        int int32_63 = Convert.ToInt32(x[i31]);
                                                        int int32_64 = Convert.ToInt32(y[i31]);
                                                        graphics.DrawLine(pen, int32_61, int32_62, int32_63, int32_64);
                                                    }
                                                    break;
                                                }
                                                break;
                                            }
                                            for (int i32 = num42 + 1; i32 <= num43; ++i32)
                                            {
                                                int int32_65 = Convert.ToInt32(x[i32 - 1]);
                                                int int32_66 = Convert.ToInt32(y[i32 - 1]);
                                                int int32_67 = Convert.ToInt32(x[i32]);
                                                int int32_68 = Convert.ToInt32(y[i32]);
                                                graphics.DrawLine(pen, int32_65, int32_66, int32_67, int32_68);
                                            }
                                            int i33 = num43 + num13 + num16;
                                            if (i33 < k)
                                            {
                                                int int32_69 = Convert.ToInt32(x[i33]);
                                                int int32_70 = Convert.ToInt32(y[i33]);
                                                graphics.FillRectangle((Brush)iColor, int32_69 - 1, int32_70 - 1, 2, 2);
                                                num42 = i33 + 2 * num13;
                                            }
                                            else
                                                break;
                                        }
                                        while (num42 < k && num43 < k);
                                    }
                                    if (iStyle3 == 7)
                                    {
                                        int i34 = 0;
                                        do
                                        {
                                            i34 += num13;
                                            if (i34 < k)
                                            {
                                                int int32_71 = Convert.ToInt32(x[i34]);
                                                int int32_72 = Convert.ToInt32(y[i34]);
                                                graphics.FillRectangle((Brush)iColor, int32_71 - 1, int32_72 - 1, 2, 2);
                                            }
                                            else
                                                break;
                                        }
                                        while (i34 < k);
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (num5 < 8)
                                InputLineStyle(e, iColor, pen, iStyle1, iWid1, i6, xr, yr, x, y, scaleWin, xBeg, yBeg, xWin, yWin);
                            if (num5 == 8)
                            {
                                double x3 = xr[1] - xr[0];
                                double num44 = Math.Atan2(yr[1] - yr[0], x3);
                                if (num44 < 0.0)
                                    num44 += 2.0 * num1;
                                double num45 = num44 - 0.5 * num1;
                                if (num45 < 0.0)
                                    num45 += 2.0 * num1;
                                double num46 = 0.5 * (xr[1] + xr[0]);
                                double num47 = 0.5 * (yr[1] + yr[0]);
                                double xSel1 = num46 + Dist * Math.Cos(num45);
                                double ySel1 = num47 + Dist * Math.Sin(num45);
                                int k2_1 = 0;
                                ParallelLine(xSel1, ySel1, Dist, i6, ref xr, ref yr, out k2_1, ref xit, ref yit);
                                if (k2_1 >= 1)
                                {
                                    InputLineStyle(e, iColor, pen, iStyle1, iWid1, k2_1, xit, yit, x, y, scaleWin, xBeg, yBeg, xWin, yWin);
                                    double xSel2 = num46 - Dist * Math.Cos(num45);
                                    double ySel2 = num47 - Dist * Math.Sin(num45);
                                    k2_1 = 0;
                                    ParallelLine(xSel2, ySel2, Dist, i6, ref xr, ref yr, out k2_1, ref xit, ref yit);
                                    if (k2_1 >= 1)
                                        InputLineStyle(e, iColor, pen, iStyle2, iWid2, k2_1, xit, yit, x, y, scaleWin, xBeg, yBeg, xWin, yWin);
                                    else
                                        continue;
                                }
                                else
                                    continue;
                            }
                            pen.Width = 1f;
                        }
                    }
                }
            }
        }

        public static void LineSpln(
          int it,
          ref double[] xb,
          ref double[] yb,
          int N,
          ref double[] xt,
          ref double[] yt,
          out int kxy,
          double shag)
        {
            double num1;
            double num2 = num1 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            double num5 = num3;
            double num6 = num3;
            double num7 = num3;
            double num8 = num3;
            double num9;
            double num10 = num9 = 0.0;
            double num11 = num9;
            double num12 = num9;
            double num13;
            double num14 = num13 = 0.0;
            double num15;
            double num16 = num15 = 0.0;
            int num17;
            int num18 = num17 = 0;
            kxy = 0;
            int kArray = 999999;
            doubleArray(xt, ref kArray);
            doubleArray(yt, ref kArray);
            xb[N + 1] = xb[0];
            yb[N + 1] = yb[0];
            double num19 = xb[1] - xb[0];
            double num20 = yb[1] - yb[0];
            double d = Math.Sqrt(num19 * num19 + num20 * num20);
            double num21 = d;
            if (it <= 0)
            {
                double num22 = xb[2] - xb[1];
                double num23 = yb[2] - yb[1];
                num2 = Math.Sqrt(num22 * num22 + num23 * num23);
                num8 = 1.25 * num19 / d - 0.25 * (xb[2] - xb[1]) / num2;
                num7 = 1.25 * num20 / d - 0.25 * (yb[2] - yb[1]) / num2;
                num18 = N;
            }
            if (it > 0)
            {
                double num24 = xb[0] - xb[N];
                double num25 = yb[0] - yb[N];
                num2 = Math.Sqrt(num24 * num24 + num25 * num25);
                num8 = 0.5 * ((xb[0] - xb[N]) / num2 + num19 / d);
                num7 = 0.5 * ((yb[0] - yb[N]) / num2 + num20 / d);
                num18 = N + 1;
            }
            int i1 = -1;
            for (int i2 = 1; i2 <= num18; ++i2)
            {
                if (i2 > N)
                {
                    num6 = 0.5 * (num19 / d + (xb[1] - xb[0])) / num21;
                    num5 = 0.5 * (num20 / d + (yb[1] - yb[0])) / num21;
                }
                if (i2 == N && it == 0)
                {
                    double num26 = xb[N - 1] - xb[N - 2];
                    double num27 = yb[N - 1] - yb[N - 2];
                    double num28 = Math.Sqrt(num26 * num26 + num27 * num27);
                    num6 = 1.25 * num19 / d - 0.25 * (xb[N - 1] - xb[N - 2]) / num28;
                    num5 = 1.25 * num20 / d - 0.25 * (yb[N - 1] - yb[N - 2]) / num28;
                }
                if (i2 == N && it > 0)
                {
                    num12 = xb[i2 + 1] - xb[i2];
                    num11 = yb[i2 + 1] - yb[i2];
                    num2 = Math.Sqrt(num12 * num12 + num11 * num11);
                    num6 = 0.5 * (num19 / d + num12 / num2);
                    num5 = 0.5 * (num20 / d + num11 / num2);
                }
                if (i2 < N)
                {
                    num12 = xb[i2 + 1] - xb[i2];
                    num11 = yb[i2 + 1] - yb[i2];
                    num2 = Math.Sqrt(num12 * num12 + num11 * num11);
                    num6 = 0.5 * (num19 / d + num12 / num2);
                    num5 = 0.5 * (num20 / d + num11 / num2);
                }
                double num29 = (num8 + num6 - 2.0 * num19 / d) / Math.Sqrt(d);
                double num30 = (num7 + num5 - 2.0 * num20 / d) / Math.Sqrt(d);
                double num31 = 3.0 * num19 / d - 2.0 * num8 - num6;
                double num32 = 3.0 * num20 / d - 2.0 * num7 - num5;
                double num33 = num8 * Math.Sqrt(d);
                double num34 = num7 * Math.Sqrt(d);
                int int32 = Convert.ToInt32(d / shag + 1E-06);
                double num35 = Math.Sqrt(d) / (double)int32;
                int num36 = int32 - 1;
                if (i2 == num18)
                    num36 = int32;
                int num37 = num36 + 1;
                for (int i3 = 0; i3 <= num37; ++i3)
                {
                    double num38 = (double)i3 * num35;
                    ++i1;
                    if (i1 > kArray)
                    {
                        int num39 = (int)MessageBox.Show("Индекс массива LineSpln");
                        kxy = 0;
                        return;
                    }
                    xt[i1] = xb[i2 - 1] + num29 * num38 * num38 * num38 + num31 * num38 * num38 + num33 * num38;
                    yt[i1] = yb[i2 - 1] + num30 * num38 * num38 * num38 + num32 * num38 * num38 + num34 * num38;
                }
                num8 = num6;
                num7 = num5;
                num19 = num12;
                num20 = num11;
                d = num2;
            }
            kxy = i1;
        }

        public static void BlindAlley(
          double xSel,
          double ySel,
          double x1,
          double y1,
          double x2,
          double y2,
          double x3,
          double y3,
          double x4,
          double y4,
          double rRad,
          double pRad,
          out int kt,
          ref double[] xt,
          ref double[] yt)
        {
            double num1;
            double num2 = num1 = 0.0;
            double ym1 = num1;
            double xm1 = num1;
            double ym2;
            double xm2 = ym2 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            double num5;
            double num6 = num5 = 0.0;
            double num7;
            double num8 = num7 = 0.0;
            double num9 = num7;
            double num10 = num7;
            kt = -1;
            double num11 = 3.1415926;
            double num12 = 2.0 * num11;
            double num13 = xSel - x1;
            double num14 = ySel - y1;
            double num15 = Math.Sqrt(num13 * num13 + num14 * num14);
            double num16 = xSel - x2;
            double num17 = ySel - y2;
            double num18 = Math.Sqrt(num16 * num16 + num17 * num17);
            if (num15 > num18)
            {
                double num19 = x1;
                double num20 = y1;
                x1 = x2;
                y1 = y2;
                x2 = num19;
                y2 = num20;
            }
            double x5 = x2 - x1;
            double y5 = y2 - y1;
            if (Math.Abs(x5) < 0.001 && Math.Abs(y5) < 0.001)
                return;
            double num21 = Math.Atan2(y5, x5);
            if (num21 < 0.0)
                num21 += num12;
            double num22 = x1 - x3;
            double num23 = y1 - y3;
            double num24 = Math.Sqrt(num22 * num22 + num23 * num23);
            double num25 = x1 - x4;
            double num26 = y1 - y4;
            double num27 = Math.Sqrt(num25 * num25 + num26 * num26);
            if (num24 > num27)
            {
                double num28 = x3;
                double num29 = y3;
                x3 = x4;
                y3 = y4;
                x4 = num28;
                y4 = num29;
            }
            double num30 = x2 - x1;
            double num31 = y2 - y1;
            double num32 = Math.Sqrt(num30 * num30 + num31 * num31);
            double x6 = x4 - x3;
            double y6 = y4 - y3;
            num9 = Math.Sqrt(x6 * x6 + y6 * y6);
            if (Math.Abs(x6) < 0.001 && Math.Abs(y6) < 0.001)
                return;
            double num33 = Math.Atan2(y6, x6);
            if (num33 < 0.0)
                num33 += num12;
            double xm3 = 0.5 * (x1 + x2);
            double ym3 = 0.5 * (y1 + y2);
            double num34 = num21 + 0.5 * num11;
            if (num34 >= num12)
                num34 -= num12;
            double num35 = num33 + 0.5 * num11;
            if (num35 >= num12)
                num35 -= num12;
            double x2_1 = xm3 + num32 * Math.Cos(num34);
            double y2_1 = ym3 + num32 * Math.Sin(num34);
            double x2_2 = xm3 + num32 * Math.Cos(num35);
            double y2_2 = ym3 + num32 * Math.Sin(num35);
            int ip = 0;
            TwoLine(xm3, ym3, x3, y3, x2_1, y2_1, x4, y4, out xm1, out ym1, ref ip);
            ip = 0;
            TwoLine(xm3, ym3, x3, y3, x2_2, y2_2, x4, y4, out xm2, out ym2, ref ip);
            double num36 = xm2 - xm1;
            double num37 = ym2 - ym1;
            double num38 = Math.Sqrt(num36 * num36 + num37 * num37);
            if (num38 <= 0.005)
            {
                double num39 = 0.5 * (xm3 + xm1);
                double num40 = 0.5 * (ym3 + ym1);
                double num41 = 0.5 * (xm3 + xm2);
                double num42 = 0.5 * (ym3 + ym2);
                num4 = 0.5 * (num41 + num39);
                num3 = 0.5 * (num42 + num40);
                xm2 = 0.5 * (xm1 + xm2);
                ym2 = 0.5 * (ym1 + ym2);
                double x7 = num4 - xm3;
                double y7 = num3 - ym3;
                if (Math.Abs(x7) < 0.001 && Math.Abs(y7) < 0.001)
                    return;
                num34 = Math.Atan2(y7, x7);
                if (num34 < 0.0)
                    num34 += num12;
                double x8 = num4 - xm2;
                double y8 = num3 - ym2;
                if (Math.Abs(x8) < 0.001 && Math.Abs(y8) < 0.001)
                    return;
                num35 = Math.Atan2(y8, x8);
                if (num35 < 0.0)
                    num35 += num12;
            }
            if (num38 > 0.005)
            {
                double x9 = xm1 - xm3;
                double y9 = ym1 - ym3;
                if (Math.Abs(x9) < 0.001 && Math.Abs(y9) < 0.001)
                    return;
                num34 = Math.Atan2(y9, x9);
                if (num34 < 0.0)
                    num34 += num12;
                double num43 = Math.Sqrt(x9 * x9 + y9 * y9);
                double x10 = xm3 - xm2;
                double y10 = ym3 - ym2;
                if (Math.Abs(x10) < 0.001 && Math.Abs(y10) < 0.001)
                    return;
                num35 = Math.Atan2(y10, x10);
                if (num35 < 0.0)
                    num35 += num12;
                double num44 = Math.Sqrt(x10 * x10 + y10 * y10);
                num10 = num43 * num44 / (num43 + num44);
                num4 = xm3 + num10 * Math.Cos(num34);
                num3 = ym3 + num10 * Math.Sin(num34);
                xm2 = num4 - num10 * Math.Cos(num35);
                ym2 = num3 - num10 * Math.Sin(num35);
            }
            double num45 = x1 - xm3;
            double num46 = y1 - ym3;
            double num47 = Math.Sqrt(num45 * num45 + num46 * num46);
            double num48 = x3 - xm2;
            double num49 = y3 - ym2;
            double num50 = Math.Sqrt(num48 * num48 + num49 * num49);
            if (num47 <= num50)
            {
                num10 = num47;
                x3 = xm2 - num10 * Math.Cos(num33);
                y3 = ym2 - num10 * Math.Sin(num33);
            }
            if (num47 > num50)
            {
                num10 = num50;
                x1 = xm3 - num10 * Math.Cos(num21);
                y1 = ym3 - num10 * Math.Sin(num21);
            }
            double num51 = x3 - x1;
            double num52 = y3 - y1;
            double num53 = Math.Sqrt(num51 * num51 + num52 * num52);
            if (rRad + pRad <= num53)
                return;
            if (num38 <= 0.005)
            {
                xm3 = 0.5 * (x1 + x3);
                ym3 = 0.5 * (y1 + y3);
            }
            if (num38 > 0.005)
            {
                double x2_3 = x1 + num10 * Math.Cos(num34);
                double y2_3 = y1 + num10 * Math.Sin(num34);
                double x4_1 = x3 + num10 * Math.Cos(num35);
                double y4_1 = y3 + num10 * Math.Sin(num35);
                ip = 0;
                TwoLine(x1, y1, x3, y3, x2_3, y2_3, x4_1, y4_1, out xm3, out ym3, ref ip);
            }
            double x11 = xm3 - num4;
            double y11 = ym3 - num3;
            if (Math.Abs(x11) < 0.001 && Math.Abs(y11) < 0.001)
                return;
            double num54 = Math.Atan2(y11, x11);
            if (num54 < 0.0)
                num54 += num12;
            double x12 = x1 - xm3;
            double y12 = y1 - ym3;
            double num55 = Math.Sqrt(x12 * x12 + y12 * y12);
            if (Math.Abs(x12) < 0.001 && Math.Abs(y12) < 0.001)
                return;
            double num56 = Math.Atan2(y12, x12);
            if (num56 < 0.0)
                num56 += num12;
            double x13 = x3 - xm3;
            double y13 = y3 - ym3;
            double num57 = Math.Sqrt(x13 * x13 + y13 * y13);
            if (Math.Abs(x13) < 0.001 && Math.Abs(y13) < 0.001)
                return;
            double num58 = Math.Atan2(y13, x13);
            if (num58 < 0.0)
                num58 += num12;
            double num59 = 0.5 * (num55 + num57);
            double num60 = xm3 + (num59 + pRad) * Math.Cos(num56);
            double num61 = ym3 + (num59 + pRad) * Math.Sin(num56);
            double num62 = xm3 + (num59 + pRad) * Math.Cos(num58);
            double num63 = ym3 + (num59 + pRad) * Math.Sin(num58);
            xt[0] = num60;
            yt[0] = num61;
            xt[1] = num62;
            yt[1] = num63;
            double num64 = 0.5 * (x1 + x3);
            double num65 = 0.5 * (y1 + y3);
            double num66 = rRad + pRad;
            double num67;
            double num68;
            do
            {
                num64 += 0.001 * Math.Cos(num54);
                num65 += 0.001 * Math.Sin(num54);
                num67 = num64 - num60;
                num68 = num65 - num61;
            }
            while (Math.Sqrt(num67 * num67 + num68 * num68) < num66);
            xt[2] = num64;
            yt[2] = num65;
            double x14 = num64 - num60;
            double y14 = num65 - num61;
            if (Math.Abs(x14) < 0.001 && Math.Abs(y14) < 0.001)
                return;
            double num69 = Math.Atan2(y14, x14);
            if (num69 < 0.0)
                num69 += num12;
            xt[3] = x1;
            yt[3] = y1;
            xt[5] = num60 + pRad * Math.Cos(num69);
            yt[5] = num61 + pRad * Math.Sin(num69);
            xm3 = 0.5 * (xt[3] + xt[5]);
            double num70 = 0.5 * (yt[3] + yt[5]);
            double x15 = xm3 - num60;
            double y15 = num70 - num61;
            if (Math.Abs(x15) < 0.001 && Math.Abs(y15) < 0.001)
                return;
            double num71 = Math.Atan2(y15, x15);
            if (num71 < 0.0)
                num71 += num12;
            xt[4] = num60 + pRad * Math.Cos(num71);
            yt[4] = num61 + pRad * Math.Sin(num71);
            double x16 = num64 - num62;
            double y16 = num65 - num63;
            if (Math.Abs(x16) < 0.001 && Math.Abs(y16) < 0.001)
                return;
            double num72 = Math.Atan2(y16, x16);
            if (num72 < 0.0)
                num72 += num12;
            xt[6] = x3;
            yt[6] = y3;
            xt[8] = num62 + pRad * Math.Cos(num72);
            yt[8] = num63 + pRad * Math.Sin(num72);
            double num73 = 0.5 * (xt[6] + xt[8]);
            double num74 = 0.5 * (yt[6] + yt[8]);
            double x17 = num73 - num62;
            double y17 = num74 - num63;
            if (Math.Abs(x17) < 0.001 && Math.Abs(y17) < 0.001)
                return;
            double num75 = Math.Atan2(y17, x17);
            if (num75 < 0.0)
                num75 += num12;
            xt[7] = num62 + pRad * Math.Cos(num75);
            yt[7] = num63 + pRad * Math.Sin(num75);
            xt[9] = num64 + rRad * Math.Cos(num54);
            yt[9] = num65 + rRad * Math.Sin(num54);
            kt = 9;
        }

        public static void FilletBisect(
          double x1,
          double y1,
          double x2,
          double y2,
          double x3,
          double y3,
          double x4,
          double y4,
          double bisec,
          out double Rad,
          out double xRad,
          out double yRad,
          out int kt,
          ref double[] xa,
          ref double[] ya,
          ref double[] xt,
          ref double[] yt)
        {
            Rad = xRad = yRad = 0.0;
            int kWork;
            int num1 = kWork = 0;
            double num2;
            double num3 = num2 = 0.0;
            double ym1 = num2;
            double xm1 = num2;
            double num4;
            double num5 = num4 = 0.0;
            double ym2 = num4;
            double xm2 = num4;
            double num6;
            double num7 = num6 = 0.0;
            double num8;
            double num9 = num8 = 0.0;
            double num10;
            double Rad1 = num10 = 0.0;
            double num11;
            double num12 = num11 = 0.0;
            double num13 = 3.1415926;
            double num14 = 2.0 * num13;
            kt = -1;
            if (bisec <= 0.0)
                return;
            int ip1 = 0;
            TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out num12, out num11, ref ip1);
            double num15 = x1 - num12;
            double num16 = y1 - num11;
            double num17 = Math.Sqrt(num15 * num15 + num16 * num16);
            double num18 = x2 - num12;
            double num19 = y2 - num11;
            if (Math.Sqrt(num18 * num18 + num19 * num19) < num17)
            {
                double num20 = x1;
                double num21 = y1;
                x1 = x2;
                y1 = y2;
                x2 = num20;
                y2 = num21;
            }
            double num22 = x3 - num12;
            double num23 = y3 - num11;
            double num24 = Math.Sqrt(num22 * num22 + num23 * num23);
            double num25 = x4 - num12;
            double num26 = y4 - num11;
            if (Math.Sqrt(num25 * num25 + num26 * num26) < num24)
            {
                double num27 = x3;
                double num28 = y3;
                x3 = x4;
                y3 = y4;
                x4 = num27;
                y4 = num28;
            }
            double x5 = x2 - x1;
            double y5 = y2 - y1;
            if (Math.Sqrt(x5 * x5 + y5 * y5) < 0.001)
                return;
            double num29 = Math.Atan2(y5, x5);
            if (num29 < 0.0)
                num29 += num14;
            double num30 = num29 + 0.5 * num13;
            if (num30 >= num14)
                num30 -= num14;
            double x6 = x4 - x3;
            double y6 = y4 - y3;
            if (Math.Sqrt(x6 * x6 + y6 * y6) < 0.001)
                return;
            double num31 = Math.Atan2(y6, x6);
            if (num31 < 0.0)
                num31 += num14;
            double num32 = num31 + 0.5 * num13;
            if (num32 >= num14)
                num32 -= num14;
            double num33 = x1 + bisec * Math.Cos(num29);
            double num34 = y1 + bisec * Math.Sin(num29);
            double num35 = x3 + bisec * Math.Cos(num31);
            double num36 = y3 + bisec * Math.Sin(num31);
            double num37 = num33 - num35;
            double num38 = num34 - num36;
            if (Math.Sqrt(num37 * num37 + num38 * num38) < 0.01)
                return;
            double num39 = 0.5 * (num33 + num35);
            double num40 = 0.5 * (num34 + num36);
            double x7 = num39 - num12;
            double num41 = Math.Atan2(num40 - num11, x7);
            if (num41 < 0.0)
                num41 += num14;
            double x4_1 = num12 + bisec * Math.Cos(num41);
            double y4_1 = num11 + bisec * Math.Sin(num41);
            double x3_1 = x4_1 + bisec * Math.Cos(num30);
            double y3_1 = y4_1 + bisec * Math.Sin(num30);
            int ip2 = 0;
            TwoLine(x1, y1, x3_1, y3_1, x2, y2, x4_1, y4_1, out xm1, out ym1, ref ip2);
            double num42 = x4_1 - xm1;
            double num43 = y4_1 - ym1;
            double num44 = Math.Sqrt(num42 * num42 + num43 * num43);
            double x3_2 = x4_1 + bisec * Math.Cos(num32);
            double y3_2 = y4_1 + bisec * Math.Sin(num32);
            int num45 = 0;
            TwoLine(x3, y3, x3_2, y3_2, x4, y4, x4_1, y4_1, out xm2, out ym2, ref num45);
            double num46 = x4_1 - xm2;
            double num47 = y4_1 - ym2;
            double num48 = Math.Sqrt(num46 * num46 + num47 * num47);
            double num49 = 0.5 * (num44 + num48);
            double num50 = bisec * num49 / (bisec - num49);
            double x3_3 = num12 + (bisec + num50) * Math.Cos(num41);
            double y3_3 = num11 + (bisec + num50) * Math.Sin(num41);
            double x4_2 = x3_3 + bisec * Math.Cos(num30);
            double y4_2 = y3_3 + bisec * Math.Sin(num30);
            num45 = 0;
            TwoLine(x1, y1, x3_3, y3_3, x2, y2, x4_2, y4_2, out xm1, out ym1, ref num45);
            double num51 = x3_3 - xm1;
            double num52 = y3_3 - ym1;
            double num53 = Math.Sqrt(num51 * num51 + num52 * num52);
            double x4_3 = x3_3 + bisec * Math.Cos(num32);
            double y4_3 = y3_3 + bisec * Math.Sin(num32);
            num45 = 0;
            TwoLine(x3, y3, x3_3, y3_3, x4, y4, x4_3, y4_3, out xm2, out ym2, ref num45);
            double num54 = x3_3 - xm2;
            double num55 = y3_3 - ym2;
            double num56 = Math.Sqrt(num54 * num54 + num55 * num55);
            double num57 = 0.5 * (num53 + num56);
            xt[0] = xm1;
            yt[0] = ym1;
            xt[1] = x3_3 - num57 * Math.Cos(num41);
            yt[1] = y3_3 - num57 * Math.Sin(num41);
            xt[2] = xm2;
            yt[2] = ym2;
            Rad = num57;
            xRad = x3_3;
            yRad = y3_3;
            Arc_3Pnt(xt, yt, out Rad1, out num12, out num11, out kWork, ref xa, ref ya, ref num45);
            kt = kWork;
        }

        public static void Fillet(
          int nFillet,
          double x1,
          double y1,
          double x2,
          double y2,
          double x3,
          double y3,
          double x4,
          double y4,
          int iLong,
          double rdd,
          out double Rad,
          out double xRad,
          out double yRad,
          out int kt,
          ref double[] xa,
          ref double[] ya,
          ref double[] xt,
          ref double[] yt)
        {
            Rad = xRad = yRad = 0.0;
            double yp;
            double xp = yp = 0.0;
            int num1;
            int ip1 = num1 = 0;
            int ip2 = num1;
            int kWork = num1;
            double ym1;
            double xm1 = ym1 = 0.0;
            double ym2;
            double xm2 = ym2 = 0.0;
            double num2;
            double ym3 = num2 = 0.0;
            double xm3 = num2;
            double ym4 = num2;
            double xm4 = num2;
            double num3;
            double num4 = num3 = 0.0;
            double num5;
            double num6 = num5 = 0.0;
            double num7 = num5;
            double num8 = num5;
            double num9;
            double dist1 = num9 = 0.0;
            double dist2 = num9;
            double yy = num9;
            double xx = num9;
            double num10 = 3.1415926;
            double num11 = 2.0 * num10;
            kt = -1;
            double num12 = x1 - x3;
            double num13 = y1 - y3;
            double num14 = Math.Sqrt(num12 * num12 + num13 * num13);
            double num15 = x2 - x3;
            double num16 = y2 - y3;
            double num17 = Math.Sqrt(num15 * num15 + num16 * num16);
            double num18 = x1 - x4;
            double num19 = y1 - y4;
            double num20 = Math.Sqrt(num18 * num18 + num19 * num19);
            double num21 = x2 - x4;
            double num22 = y2 - y4;
            double num23 = Math.Sqrt(num21 * num21 + num22 * num22);
            int num24 = 0;
            if (num14 < 0.05)
                ++num24;
            if (num17 < 0.05)
            {
                xx = x2;
                yy = y2;
                x2 = x1;
                y2 = y1;
                x1 = xx;
                y1 = yy;
                ++num24;
            }
            if (num20 < 0.05)
            {
                xx = x4;
                yy = y4;
                x4 = x3;
                y4 = y3;
                x3 = xx;
                y3 = yy;
                ++num24;
            }
            if (num23 < 0.05)
            {
                double num25 = x2;
                double num26 = y2;
                x2 = x1;
                y2 = y1;
                x1 = num25;
                y1 = num26;
                xx = x4;
                yy = y4;
                x4 = x3;
                y4 = y3;
                x3 = xx;
                y3 = yy;
                ++num24;
            }
            if (num24 > 1 || num24 == 1 && rdd <= 0.0)
                return;
            if (num24 == 1 && rdd > 0.0)
            {
                double x5 = x2 - x1;
                double y5 = y2 - y1;
                if (Math.Sqrt(x5 * x5 + y5 * y5) < 0.001)
                    return;
                double num27 = Math.Sqrt(x5 * x5 + y5 * y5);
                double num28 = Math.Atan2(y5, x5);
                if (num28 < 0.0)
                    num28 += num11;
                double num29 = num28 + 0.5 * num10;
                if (num29 >= num11)
                    num29 -= num11;
                double x6 = x4 - x3;
                double y6 = y4 - y3;
                if (Math.Sqrt(x6 * x6 + y6 * y6) < 0.001)
                    return;
                double num30 = Math.Sqrt(x6 * x6 + y6 * y6);
                double num31 = Math.Atan2(y6, x6);
                if (num31 < 0.0)
                    num31 += num11;
                double num32 = num31 + 0.5 * num10;
                if (num32 >= num11)
                    num32 -= num11;
                if (num27 >= num30)
                {
                    num8 = num27;
                    x4 = x3 + num8 * Math.Cos(num31);
                    y4 = y3 + num8 * Math.Sin(num31);
                }
                if (num30 > num27)
                {
                    num8 = num30;
                    x2 = x1 + num8 * Math.Cos(num28);
                    y2 = y1 + num8 * Math.Sin(num28);
                }
                double x2_1 = x2 + num8 * Math.Cos(num29);
                double y2_1 = y2 + num8 * Math.Sin(num29);
                double x4_1 = x4 + num8 * Math.Cos(num32);
                double y4_1 = y4 + num8 * Math.Sin(num32);
                int ip3 = 0;
                TwoLine(x2, y2, x4, y4, x2_1, y2_1, x4_1, y4_1, out xm4, out ym4, ref ip3);
                double num33 = x2 - xm4;
                double num34 = y2 - ym4;
                double num35 = Math.Sqrt(num33 * num33 + num34 * num34);
                double Rad1 = rdd * num8 / num35;
                double x1_1 = x1 + Rad1 * Math.Cos(num28);
                double y1_1 = y1 + Rad1 * Math.Sin(num28);
                double x2_2 = x1_1 + Rad1 * Math.Cos(num29);
                double y2_2 = y1_1 + Rad1 * Math.Sin(num29);
                double x3_1 = x3 + Rad1 * Math.Cos(num31);
                double y3_1 = y3 + Rad1 * Math.Sin(num31);
                double x4_2 = x3_1 + Rad1 * Math.Cos(num32);
                double y4_2 = y3_1 + Rad1 * Math.Sin(num32);
                int num36 = 0;
                TwoLine(x1_1, y1_1, x3_1, y3_1, x2_2, y2_2, x4_2, y4_2, out xm3, out ym3, ref num36);
                double x7 = xm4 - x1;
                double y7 = ym4 - y1;
                if (Math.Sqrt(x7 * x7 + y7 * y7) < 0.001)
                    return;
                double num37 = Math.Atan2(y7, x7);
                if (num37 < 0.0)
                    num37 += num11;
                xt[0] = x1_1;
                yt[0] = y1_1;
                xt[1] = xm3 - rdd * Math.Cos(num37);
                yt[1] = ym3 - rdd * Math.Sin(num37);
                if (iLong > 0)
                {
                    xt[1] = xm3 + rdd * Math.Cos(num37);
                    yt[1] = ym3 + rdd * Math.Sin(num37);
                }
                xt[2] = x3_1;
                yt[2] = y3_1;
                Rad = rdd;
                xRad = xm3;
                yRad = ym3;
                Arc_3Pnt(xt, yt, out Rad1, out xx, out yy, out kWork, ref xa, ref ya, ref num36);
                kt = kWork;
            }
            else
            {
                double num38 = x2 - x1;
                double num39 = y2 - y1;
                double num40 = Math.Sqrt(num38 * num38 + num39 * num39);
                double x8 = x4 - x3;
                double y8 = y4 - y3;
                if (Math.Abs(Math.Sqrt(x8 * x8 + y8 * y8) - num40) < 0.05)
                {
                    double num41 = Math.Atan2(y8, x8);
                    if (num41 < 0.0)
                        num41 += num11;
                    x4 += Math.Cos(num41);
                    y4 += Math.Sin(num41);
                    x3 -= Math.Cos(num41);
                    y3 -= Math.Sin(num41);
                }
                double xm5 = 0.5 * (x1 + x2);
                double ym5 = 0.5 * (y1 + y2);
                double xm6 = 0.5 * (x3 + x4);
                double ym6 = 0.5 * (y3 + y4);
                double x9 = xm6 - xm5;
                double y9 = ym6 - ym5;
                if (Math.Sqrt(x9 * x9 + y9 * y9) < 0.001)
                    return;
                double num42 = Math.Sqrt(x9 * x9 + y9 * y9);
                double num43 = Math.Atan2(y9, x9);
                if (num43 < 0.0)
                    num43 += num11;
                double x2_3 = x1 + Math.Cos(num43);
                double y2_3 = y1 + Math.Sin(num43);
                int ip4 = 0;
                TwoLine(x1, y1, x3, y3, x2_3, y2_3, x4, y4, out xm1, out ym1, ref ip4);
                double num44 = xm1 - x1;
                double num45 = ym1 - y1;
                double num46 = Math.Sqrt(num44 * num44 + num45 * num45);
                double x2_4 = x2 + Math.Cos(num43);
                double y2_4 = y2 + Math.Sin(num43);
                int ip5 = 0;
                TwoLine(x2, y2, x3, y3, x2_4, y2_4, x4, y4, out xm1, out ym1, ref ip5);
                double num47 = xm1 - x2;
                double num48 = ym1 - y2;
                double num49 = Math.Sqrt(num47 * num47 + num48 * num48);
                double Rad2 = Math.Abs(num49 - num46);
                int num50;
                if (Rad2 <= 0.015)
                {
                    double x10 = x2 - x1;
                    double y10 = y2 - y1;
                    if (Math.Sqrt(x10 * x10 + y10 * y10) < 0.001)
                        return;
                    double num51 = Math.Atan2(y10, x10);
                    if (num51 < 0.0)
                        num51 += num11;
                    double num52 = num51 + 0.5 * num10;
                    if (num52 >= num11)
                        num52 -= num11;
                    double x2_5 = x1 + num46 * Math.Cos(num52);
                    double y2_5 = y1 + num46 * Math.Sin(num52);
                    num50 = 1;
                    TwoLine(x1, y1, x3, y3, x2_5, y2_5, x4, y4, out xm1, out ym1, ref num50);
                    if (xm1 != 0.0 && ym1 != 0.0)
                    {
                        double num53 = xm1 - x1;
                        double num54 = ym1 - y1;
                        double num55 = 0.5 * Math.Sqrt(num53 * num53 + num54 * num54);
                        double num56 = 0.5 * (x1 + xm1);
                        double num57 = 0.5 * (y1 + ym1);
                        xt[0] = x1;
                        yt[0] = y1;
                        xt[1] = num56 - num55 * Math.Cos(num51);
                        yt[1] = num57 - num55 * Math.Sin(num51);
                        xt[2] = xm1;
                        yt[2] = ym1;
                        Rad = num55;
                        xRad = num56;
                        yRad = num57;
                        Arc_3Pnt(xt, yt, out Rad2, out xx, out yy, out kWork, ref xa, ref ya, ref num50);
                        kt = kWork;
                        return;
                    }
                    double x11 = x4 - x3;
                    double y11 = y4 - y3;
                    if (Math.Sqrt(x11 * x11 + y11 * y11) < 0.001)
                        return;
                    double num58 = Math.Atan2(y11, x11);
                    if (num58 < 0.0)
                        num58 += num11;
                    double num59 = num58 + 0.5 * num10;
                    if (num59 >= num11)
                        num59 -= num11;
                    double x2_6 = x3 + num49 * Math.Cos(num59);
                    double y2_6 = y3 + num49 * Math.Sin(num59);
                    num50 = 1;
                    TwoLine(x3, y3, x1, y1, x2_6, y2_6, x2, y2, out xm2, out ym2, ref num50);
                    if (xm2 != 0.0 && ym2 != 0.0)
                    {
                        double num60 = xm2 - x3;
                        double num61 = ym2 - y3;
                        double num62 = 0.5 * Math.Sqrt(num60 * num60 + num61 * num61);
                        double num63 = 0.5 * (x3 + xm2);
                        double num64 = 0.5 * (y3 + ym2);
                        xt[0] = x3;
                        yt[0] = y3;
                        xt[1] = num63 - num62 * Math.Cos(num58);
                        yt[1] = num64 - num62 * Math.Sin(num58);
                        xt[2] = xm2;
                        yt[2] = ym2;
                        Rad = num62;
                        xRad = num63;
                        yRad = num64;
                        Arc_3Pnt(xt, yt, out Rad2, out xx, out yy, out kWork, ref xa, ref ya, ref num50);
                        kt = kWork;
                        return;
                    }
                }
                num50 = 0;
                TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xx, out yy, ref num50);
                DistPnt(xx, yy, x1, y1, x2, y2, out dist2, out ip2, out xp, out yp);
                DistPnt(xx, yy, x3, y3, x4, y4, out dist1, out ip1, out xp, out yp);
                if (ip2 > 0 && ip1 > 0 && rdd <= 0.0)
                    return;
                if (ip2 > 0 && ip1 > 0 && rdd > 0.0)
                {
                    double num65 = xx - x1;
                    double num66 = yy - y1;
                    double num67 = Math.Sqrt(num65 * num65 + num66 * num66);
                    double num68 = xx - x2;
                    double num69 = yy - y2;
                    double num70 = Math.Sqrt(num68 * num68 + num69 * num69);
                    if (num67 <= num70)
                    {
                        x1 = xx;
                        y1 = yy;
                    }
                    if (num67 > num70)
                    {
                        x2 = xx;
                        y2 = yy;
                    }
                    double num71 = xx - x3;
                    double num72 = yy - y3;
                    double num73 = Math.Sqrt(num71 * num71 + num72 * num72);
                    double num74 = xx - x4;
                    double num75 = yy - y4;
                    double num76 = Math.Sqrt(num74 * num74 + num75 * num75);
                    if (num73 <= num76)
                    {
                        x3 = xx;
                        y3 = yy;
                    }
                    if (num73 > num76)
                    {
                        x4 = xx;
                        y4 = yy;
                    }
                    double x12 = x2 - x1;
                    double y12 = y2 - y1;
                    if (Math.Sqrt(x12 * x12 + y12 * y12) < 0.001)
                        return;
                    double num77 = Math.Sqrt(x12 * x12 + y12 * y12);
                    double num78 = Math.Atan2(y12, x12);
                    if (num78 < 0.0)
                        num78 += num11;
                    double num79 = num78 + 0.5 * num10;
                    if (num79 >= num11)
                        num79 -= num11;
                    double x13 = x4 - x3;
                    double y13 = y4 - y3;
                    if (Math.Sqrt(x13 * x13 + y13 * y13) < 0.001)
                        return;
                    double num80 = Math.Sqrt(x13 * x13 + y13 * y13);
                    double num81 = Math.Atan2(y13, x13);
                    if (num81 < 0.0)
                        num81 += num11;
                    double num82 = num81 + 0.5 * num10;
                    if (num82 >= num11)
                        num82 -= num11;
                    if (num77 >= num80)
                    {
                        num42 = num77;
                        x4 = x3 + num42 * Math.Cos(num81);
                        y4 = y3 + num42 * Math.Sin(num81);
                    }
                    if (num80 > num77)
                    {
                        num42 = num80;
                        x2 = x1 + num42 * Math.Cos(num78);
                        y2 = y1 + num42 * Math.Sin(num78);
                    }
                    double x2_7 = x2 + num42 * Math.Cos(num79);
                    double y2_7 = y2 + num42 * Math.Sin(num79);
                    double x4_3 = x4 + num42 * Math.Cos(num82);
                    double y4_3 = y4 + num42 * Math.Sin(num82);
                    num50 = 0;
                    TwoLine(x2, y2, x4, y4, x2_7, y2_7, x4_3, y4_3, out xm5, out ym5, ref num50);
                    double num83 = x2 - xm5;
                    double num84 = y2 - ym5;
                    double num85 = Math.Sqrt(num83 * num83 + num84 * num84);
                    double Rad3 = rdd * num42 / num85;
                    double x1_2 = x1 + Rad3 * Math.Cos(num78);
                    double y1_2 = y1 + Rad3 * Math.Sin(num78);
                    double x2_8 = x1_2 + Rad3 * Math.Cos(num79);
                    double y2_8 = y1_2 + Rad3 * Math.Sin(num79);
                    double x3_2 = x3 + Rad3 * Math.Cos(num81);
                    double y3_2 = y3 + Rad3 * Math.Sin(num81);
                    double x4_4 = x3_2 + Rad3 * Math.Cos(num82);
                    double y4_4 = y3_2 + Rad3 * Math.Sin(num82);
                    num50 = 0;
                    TwoLine(x1_2, y1_2, x3_2, y3_2, x2_8, y2_8, x4_4, y4_4, out xm6, out ym6, ref num50);
                    double x14 = xm5 - x1;
                    double y14 = ym5 - y1;
                    if (Math.Sqrt(x14 * x14 + y14 * y14) < 0.001)
                        return;
                    double num86 = Math.Atan2(y14, x14);
                    if (num86 < 0.0)
                        num86 += num11;
                    xt[0] = x1_2;
                    yt[0] = y1_2;
                    xt[1] = xm6 - rdd * Math.Cos(num86);
                    yt[1] = ym6 - rdd * Math.Sin(num86);
                    if (iLong > 0)
                    {
                        xt[1] = xm6 + rdd * Math.Cos(num86);
                        yt[1] = ym6 + rdd * Math.Sin(num86);
                    }
                    xt[2] = x3_2;
                    yt[2] = y3_2;
                    Rad = rdd;
                    xRad = xm6;
                    yRad = ym6;
                    Arc_3Pnt(xt, yt, out Rad3, out xx, out yy, out kWork, ref xa, ref ya, ref num50);
                    kt = kWork;
                }
                else
                {
                    double num87 = xx - x1;
                    double num88 = yy - y1;
                    double num89 = Math.Sqrt(num87 * num87 + num88 * num88);
                    double num90 = xx - x2;
                    double num91 = yy - y2;
                    if (Math.Sqrt(num90 * num90 + num91 * num91) < num89)
                    {
                        double num92 = x2;
                        double num93 = y2;
                        x2 = x1;
                        y2 = y1;
                        x1 = num92;
                        y1 = num93;
                    }
                    double num94 = xx - x3;
                    double num95 = yy - y3;
                    double num96 = Math.Sqrt(num94 * num94 + num95 * num95);
                    double num97 = xx - x4;
                    double num98 = yy - y4;
                    if (Math.Sqrt(num97 * num97 + num98 * num98) < num96)
                    {
                        double num99 = x4;
                        double num100 = y4;
                        x4 = x3;
                        y4 = y3;
                        x3 = num99;
                        y3 = num100;
                    }
                    if (ip2 > 0 && ip1 == 0)
                    {
                        double num101 = x3 - xx;
                        double num102 = y3 - yy;
                        double num103 = Math.Sqrt(num101 * num101 + num102 * num102);
                        double x15 = x2 - x1;
                        double y15 = y2 - y1;
                        if (Math.Sqrt(x15 * x15 + y15 * y15) < 0.001)
                            return;
                        double num104 = Math.Atan2(y15, x15);
                        if (num104 < 0.0)
                            num104 += num11;
                        x1 = xx + num103 * Math.Cos(num104);
                        y1 = yy + num103 * Math.Sin(num104);
                    }
                    if (ip2 == 0 && ip1 > 0)
                    {
                        double num105 = x1 - xx;
                        double num106 = y1 - yy;
                        double num107 = Math.Sqrt(num105 * num105 + num106 * num106);
                        double x16 = x4 - x3;
                        double y16 = y4 - y3;
                        if (Math.Sqrt(x16 * x16 + y16 * y16) < 0.001)
                            return;
                        double num108 = Math.Atan2(y16, x16);
                        if (num108 < 0.0)
                            num108 += num11;
                        x3 = xx + num107 * Math.Cos(num108);
                        y3 = yy + num107 * Math.Sin(num108);
                    }
                    double x17 = x2 - x1;
                    double y17 = y2 - y1;
                    if (Math.Sqrt(x17 * x17 + y17 * y17) < 0.001)
                        return;
                    double num109 = Math.Atan2(y17, x17);
                    if (num109 < 0.0)
                        num109 += num11;
                    double num110 = num109 + 0.5 * num10;
                    if (num110 >= num11)
                        num110 -= num11;
                    double x18 = x4 - x3;
                    double y18 = y4 - y3;
                    if (Math.Sqrt(x18 * x18 + y18 * y18) < 0.001)
                        return;
                    double num111 = Math.Atan2(y18, x18);
                    if (num111 < 0.0)
                        num111 += num11;
                    double num112 = num111 + 0.5 * num10;
                    if (num112 >= num11)
                        num112 -= num11;
                    double num113 = xx - x1;
                    double num114 = yy - y1;
                    double num115 = Math.Sqrt(num113 * num113 + num114 * num114);
                    double num116 = xx - x3;
                    double num117 = yy - y3;
                    double num118 = Math.Sqrt(num116 * num116 + num117 * num117);
                    if (num115 < num118)
                    {
                        num7 = num118;
                        x1 = xx + num118 * Math.Cos(num109);
                        y1 = yy + num118 * Math.Sin(num109);
                    }
                    if (num118 < num115)
                    {
                        num7 = num115;
                        x3 = xx + num115 * Math.Cos(num111);
                        y3 = yy + num115 * Math.Sin(num111);
                    }
                    double num119 = xx - x2;
                    double num120 = yy - y2;
                    double num121 = Math.Sqrt(num119 * num119 + num120 * num120);
                    double num122 = xx - x4;
                    double num123 = yy - y4;
                    double num124 = Math.Sqrt(num122 * num122 + num123 * num123);
                    if (num121 < num124)
                    {
                        num42 = num121;
                        x4 = xx + num121 * Math.Cos(num111);
                        y4 = yy + num121 * Math.Sin(num111);
                    }
                    if (num124 < num121)
                    {
                        num42 = num124;
                        x2 = xx + num124 * Math.Cos(num109);
                        y2 = yy + num124 * Math.Sin(num109);
                    }
                    double x2_9 = x1 + num42 * Math.Cos(num110);
                    double y2_9 = y1 + num42 * Math.Sin(num110);
                    double x4_5 = x3 + num42 * Math.Cos(num112);
                    double y4_5 = y3 + num42 * Math.Sin(num112);
                    num50 = 0;
                    TwoLine(x1, y1, x3, y3, x2_9, y2_9, x4_5, y4_5, out xm5, out ym5, ref num50);
                    double num125 = x1 - xm5;
                    double num126 = y1 - ym5;
                    double num127 = Math.Sqrt(num125 * num125 + num126 * num126);
                    double num128 = x3 - xm5;
                    double num129 = y3 - ym5;
                    double num130 = Math.Sqrt(num128 * num128 + num129 * num129);
                    double num131 = 0.5 * (num127 + num130);
                    double x2_10 = x2 + num42 * Math.Cos(num110);
                    double y2_10 = y2 + num42 * Math.Sin(num110);
                    double x4_6 = x4 + num42 * Math.Cos(num112);
                    double y4_6 = y4 + num42 * Math.Sin(num112);
                    num50 = 0;
                    TwoLine(x2, y2, x4, y4, x2_10, y2_10, x4_6, y4_6, out xm6, out ym6, ref num50);
                    double num132 = x2 - xm6;
                    double num133 = y2 - ym6;
                    double num134 = Math.Sqrt(num132 * num132 + num133 * num133);
                    double num135 = x4 - xm6;
                    double num136 = y4 - ym6;
                    double num137 = Math.Sqrt(num135 * num135 + num136 * num136);
                    double num138 = 0.5 * (num134 + num137);
                    double x19 = xm6 - xx;
                    double y19 = ym6 - yy;
                    if (Math.Sqrt(x19 * x19 + y19 * y19) < 0.001)
                        return;
                    double num139 = Math.Atan2(y19, x19);
                    if (num139 < 0.0)
                        num139 += num11;
                    if (rdd == 0.0 && iLong == 0)
                    {
                        xt[0] = x1;
                        yt[0] = y1;
                        xt[1] = xm5 - num131 * Math.Cos(num139);
                        yt[1] = ym5 - num131 * Math.Sin(num139);
                        if (nFillet == 2)
                        {
                            xt[1] = xm5 + num131 * Math.Cos(num139);
                            yt[1] = ym5 + num131 * Math.Sin(num139);
                        }
                        xt[2] = x3;
                        yt[2] = y3;
                        Rad = num131;
                        xRad = xm5;
                        yRad = ym5;
                        Arc_3Pnt(xt, yt, out Rad2, out xx, out yy, out kWork, ref xa, ref ya, ref num50);
                        kt = kWork;
                    }
                    else if (rdd == 0.0 && iLong > 0)
                    {
                        xt[0] = x2;
                        yt[0] = y2;
                        xt[1] = xm6 + num138 * Math.Cos(num139);
                        yt[1] = ym6 + num138 * Math.Sin(num139);
                        if (nFillet == 4)
                        {
                            xt[1] = xm6 - num138 * Math.Cos(num139);
                            yt[1] = ym6 - num138 * Math.Sin(num139);
                        }
                        xt[2] = x4;
                        yt[2] = y4;
                        Rad = num138;
                        xRad = xm6;
                        yRad = ym6;
                        Arc_3Pnt(xt, yt, out Rad2, out xx, out yy, out kWork, ref xa, ref ya, ref num50);
                        kt = kWork;
                    }
                    else
                    {
                        if (rdd <= 0.0)
                            return;
                        double Rad4 = rdd * num42 / num138;
                        double x1_3 = xx + Rad4 * Math.Cos(num109);
                        double y1_3 = yy + Rad4 * Math.Sin(num109);
                        double x2_11 = x1_3 + num42 * Math.Cos(num110);
                        double y2_11 = y1_3 + num42 * Math.Sin(num110);
                        double x3_3 = xx + Rad4 * Math.Cos(num111);
                        double y3_3 = yy + Rad4 * Math.Sin(num111);
                        double x4_7 = x3_3 + num42 * Math.Cos(num112);
                        double y4_7 = y3_3 + num42 * Math.Sin(num112);
                        num50 = 0;
                        TwoLine(x1_3, y1_3, x3_3, y3_3, x2_11, y2_11, x4_7, y4_7, out xx, out yy, ref num50);
                        xRad = xx;
                        yRad = yy;
                        xt[0] = x1_3;
                        yt[0] = y1_3;
                        xt[2] = x3_3;
                        yt[2] = y3_3;
                        if (iLong == 0)
                        {
                            xt[1] = xx - rdd * Math.Cos(num139);
                            yt[1] = yy - rdd * Math.Sin(num139);
                        }
                        if (iLong > 0)
                        {
                            xt[1] = xx + rdd * Math.Cos(num139);
                            yt[1] = yy + rdd * Math.Sin(num139);
                        }
                        Arc_3Pnt(xt, yt, out Rad4, out xx, out yy, out kWork, ref xa, ref ya, ref num50);
                        kt = kWork;
                    }
                }
            }
        }

        public static void ArcTangent(
          int iType,
          double RadArc,
          double Rad1,
          double xc1,
          double yc1,
          double Rad2,
          double xc2,
          double yc2,
          out double xArc,
          out double yArc,
          out double xh,
          out double yh,
          out double xk,
          out double yk)
        {
            double num1;
            double num2 = num1 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            double num5;
            double num6 = num5 = 0.0;
            double num7;
            double num8 = num7 = 0.0;
            int num9;
            int num10 = num9 = 0;
            double num11 = 3.1415926;
            double num12 = 2.0 * num11;
            xArc = 0.0;
            yArc = 0.0;
            xh = 0.0;
            yh = 0.0;
            xk = 0.0;
            yk = 0.0;
            double x1 = xc2 - xc1;
            double y1 = yc2 - yc1;
            if (Math.Sqrt(x1 * x1 + y1 * y1) < 0.001)
                return;
            double num13 = Math.Atan2(y1, x1);
            if (num13 < 0.0)
                num13 += num12;
            if (iType == 1)
            {
                double num14 = Math.Sqrt(x1 * x1 + y1 * y1) + Rad1 + Rad2;
                if (RadArc < 0.5 * num14)
                    return;
                if (num14 == 2.0 * RadArc)
                {
                    double num15 = xc1 - Rad1 * Math.Cos(num13);
                    double num16 = yc1 - Rad1 * Math.Sin(num13);
                    double num17 = xc2 + Rad2 * Math.Cos(num13);
                    double num18 = yc2 + Rad2 * Math.Sin(num13);
                    xh = num15;
                    yh = num16;
                    xk = num17;
                    yk = num18;
                    xArc = 0.5 * (num15 + num17);
                    yArc = 0.5 * (num16 + num18);
                    return;
                }
                double num19 = 0.5 * (xc1 + xc2);
                double num20 = 0.5 * (yc1 + yc2);
                double num21 = num13 + 0.5 * num11;
                if (num21 >= num12)
                    num21 -= num12;
                double num22 = num19 + 0.5 * RadArc * Math.Cos(num21);
                double num23 = num20 + 0.5 * RadArc * Math.Sin(num21);
                int int32 = Convert.ToInt32(10.0 * RadArc + 1E-06);
                for (int i = 0; i <= int32; ++i)
                {
                    x1 = xc1 - num22;
                    y1 = yc1 - num23;
                    if (Math.Sqrt(x1 * x1 + y1 * y1) >= 0.001)
                    {
                        double num24 = Math.Atan2(y1, x1);
                        if (num24 < 0.0)
                            num24 += num12;
                        double num25 = Math.Sqrt(x1 * x1 + y1 * y1) + Rad1;
                        x1 = xc2 - num22;
                        y1 = yc2 - num23;
                        if (Math.Sqrt(x1 * x1 + y1 * y1) >= 0.001)
                        {
                            double num26 = Math.Atan2(y1, x1);
                            if (num26 < 0.0)
                                num26 += num12;
                            double num27 = Math.Sqrt(x1 * x1 + y1 * y1) + Rad2;
                            if (Math.Abs(num25 - num27) < 0.002)
                            {
                                if (Math.Abs(RadArc - 0.5 * (num25 + num27)) < 0.002)
                                {
                                    xh = xc1 + Rad1 * Math.Cos(num24);
                                    yh = yc1 + Rad1 * Math.Sin(num24);
                                    xk = xc2 + Rad2 * Math.Cos(num26);
                                    yk = yc2 + Rad2 * Math.Sin(num26);
                                    xArc = num22;
                                    yArc = num23;
                                    return;
                                }
                                if (num25 > RadArc)
                                {
                                    double num28 = num25 - RadArc;
                                    num22 += num28 * Math.Cos(num24);
                                    num23 += num28 * Math.Sin(num24);
                                }
                                if (num25 < RadArc)
                                {
                                    double num29 = RadArc - num25;
                                    num22 -= num29 * Math.Cos(num24);
                                    num23 -= num29 * Math.Sin(num24);
                                }
                                if (num27 > RadArc)
                                {
                                    double num30 = num27 - RadArc;
                                    num22 += num30 * Math.Cos(num26);
                                    num23 += num30 * Math.Sin(num26);
                                }
                                if (num27 < RadArc)
                                {
                                    double num31 = RadArc - num27;
                                    num22 -= num31 * Math.Cos(num26);
                                    num23 -= num31 * Math.Sin(num26);
                                }
                            }
                            else
                            {
                                if (num25 > RadArc)
                                {
                                    double num32 = num25 - RadArc;
                                    num22 += num32 * Math.Cos(num24);
                                    num23 += num32 * Math.Sin(num24);
                                }
                                if (num25 < RadArc)
                                {
                                    double num33 = RadArc - num25;
                                    num22 -= num33 * Math.Cos(num24);
                                    num23 -= num33 * Math.Sin(num24);
                                }
                                if (num27 > RadArc)
                                {
                                    double num34 = num27 - RadArc;
                                    num22 += num34 * Math.Cos(num26);
                                    num23 += num34 * Math.Sin(num26);
                                }
                                if (num27 < RadArc)
                                {
                                    double num35 = RadArc - num27;
                                    num22 -= num35 * Math.Cos(num26);
                                    num23 -= num35 * Math.Sin(num26);
                                }
                            }
                        }
                    }
                }
            }
            if (iType != 2)
                return;
            double num36 = Math.Sqrt(x1 * x1 + y1 * y1) - Rad1 - Rad2;
            if (RadArc < 0.5 * num36)
                return;
            if (num36 == 2.0 * RadArc)
            {
                double num37 = xc1 + Rad1 * Math.Cos(num13);
                double num38 = yc1 + Rad1 * Math.Sin(num13);
                double num39 = xc2 - Rad2 * Math.Cos(num13);
                double num40 = yc2 - Rad2 * Math.Sin(num13);
                xh = num37;
                yh = num38;
                xk = num39;
                yk = num40;
                xArc = 0.5 * (num37 + num39);
                yArc = 0.5 * (num38 + num40);
            }
            else
            {
                double num41 = 0.5 * (xc1 + xc2);
                double num42 = 0.5 * (yc1 + yc2);
                double num43 = num13 + 0.5 * num11;
                if (num43 >= num12)
                    num43 -= num12;
                double num44 = num41 + 0.5 * RadArc * Math.Cos(num43);
                double num45 = num42 + 0.5 * RadArc * Math.Sin(num43);
                int int32 = Convert.ToInt32(10.0 * RadArc + 1E-06);
                for (int i = 0; i <= int32; ++i)
                {
                    double x2 = xc1 - num44;
                    double y2 = yc1 - num45;
                    if (Math.Sqrt(x2 * x2 + y2 * y2) >= 0.001)
                    {
                        double num46 = Math.Atan2(y2, x2);
                        if (num46 < 0.0)
                            num46 += num12;
                        double num47 = Math.Sqrt(x2 * x2 + y2 * y2) - Rad1;
                        double x3 = xc2 - num44;
                        double y3 = yc2 - num45;
                        if (Math.Sqrt(x3 * x3 + y3 * y3) >= 0.001)
                        {
                            double num48 = Math.Atan2(y3, x3);
                            if (num48 < 0.0)
                                num48 += num12;
                            double num49 = Math.Sqrt(x3 * x3 + y3 * y3) - Rad2;
                            if (Math.Abs(num47 - num49) < 0.002)
                            {
                                if (Math.Abs(RadArc - 0.5 * (num47 + num49)) < 0.002)
                                {
                                    xh = xc1 - Rad1 * Math.Cos(num46);
                                    yh = yc1 - Rad1 * Math.Sin(num46);
                                    xk = xc2 - Rad2 * Math.Cos(num48);
                                    yk = yc2 - Rad2 * Math.Sin(num48);
                                    xArc = num44;
                                    yArc = num45;
                                    break;
                                }
                                if (num47 > RadArc)
                                {
                                    double num50 = num47 - RadArc;
                                    num44 += num50 * Math.Cos(num46);
                                    num45 += num50 * Math.Sin(num46);
                                }
                                if (num47 < RadArc)
                                {
                                    double num51 = RadArc - num47;
                                    num44 -= num51 * Math.Cos(num46);
                                    num45 -= num51 * Math.Sin(num46);
                                }
                                if (num49 > RadArc)
                                {
                                    double num52 = num49 - RadArc;
                                    num44 += num52 * Math.Cos(num48);
                                    num45 += num52 * Math.Sin(num48);
                                }
                                if (num49 < RadArc)
                                {
                                    double num53 = RadArc - num49;
                                    num44 -= num53 * Math.Cos(num48);
                                    num45 -= num53 * Math.Sin(num48);
                                }
                            }
                            else
                            {
                                if (num47 > RadArc)
                                {
                                    double num54 = num47 - RadArc;
                                    num44 += num54 * Math.Cos(num46);
                                    num45 += num54 * Math.Sin(num46);
                                }
                                if (num47 < RadArc)
                                {
                                    double num55 = RadArc - num47;
                                    num44 -= num55 * Math.Cos(num46);
                                    num45 -= num55 * Math.Sin(num46);
                                }
                                if (num49 > RadArc)
                                {
                                    double num56 = num49 - RadArc;
                                    num44 += num56 * Math.Cos(num48);
                                    num45 += num56 * Math.Sin(num48);
                                }
                                if (num49 < RadArc)
                                {
                                    double num57 = RadArc - num49;
                                    num44 -= num57 * Math.Cos(num48);
                                    num45 -= num57 * Math.Sin(num48);
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void FindEndLine(
          double xx,
          double yy,
          int kLine,
          ref int[] k1,
          ref int[] k2,
          ref double[] x,
          ref double[] y,
          out int kp,
          ref double[] xp,
          ref double[] yp,
          out int indLine,
          out int nInd)
        {
            kp = 0;
            indLine = 0;
            nInd = 0;
            double num1;
            double num2 = num1 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            int i1;
            int num5 = i1 = 0;
            int kArray1 = 999999;
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            if (kLine > kArray1)
            {
                int num6 = (int)MessageBox.Show("Индекс массива FindEndLine");
            }
            else
            {
                int kArray2 = 999999;
                int num7 = k2[kLine];
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                doubleArray(xp, ref kArray2);
                doubleArray(yp, ref kArray2);
                if (num7 > kArray2)
                {
                    int num8 = (int)MessageBox.Show("Индекс массива FindEndLine");
                }
                else
                {
                    num5 = 0;
                    double num9 = 9999999.9;
                    for (int i2 = 1; i2 <= kLine; ++i2)
                    {
                        int i3 = k1[i2];
                        int i4 = k2[i2];
                        double num10 = x[i3] - xx;
                        double num11 = y[i3] - yy;
                        double num12 = Math.Sqrt(num10 * num10 + num11 * num11);
                        if (num9 > num12)
                        {
                            num9 = num12;
                            i1 = i2;
                        }
                        double num13 = x[i4] - xx;
                        double num14 = y[i4] - yy;
                        double num15 = Math.Sqrt(num13 * num13 + num14 * num14);
                        if (num9 > num15)
                        {
                            num9 = num15;
                            i1 = i2;
                        }
                    }
                    if (i1 <= 0)
                        return;
                    indLine = i1;
                    int num16 = k1[i1];
                    int num17 = k2[i1];
                    int i5 = -1;
                    for (int i6 = num16; i6 <= num17; ++i6)
                    {
                        ++i5;
                        xp[i5] = x[i6];
                        yp[i5] = y[i6];
                    }
                    kp = i5;
                    double num18 = xp[0] - xx;
                    double num19 = yp[0] - yy;
                    double num20 = Math.Sqrt(num18 * num18 + num19 * num19);
                    double num21 = xp[i5] - xx;
                    double num22 = yp[i5] - yy;
                    double num23 = Math.Sqrt(num21 * num21 + num22 * num22);
                    nInd = 0;
                    if (num23 >= num20)
                        return;
                    nInd = kp;
                }
            }
        }

        public static void LengthenLine(
          double xx,
          double yy,
          int kLine,
          ref int[] k1,
          ref int[] k2,
          ref double[] Rad,
          ref double[] xRad,
          ref double[] yRad,
          ref double[] x,
          ref double[] y,
          out double rd,
          out double xrd,
          out double yrd,
          out int kp,
          ref double[] xp,
          ref double[] yp,
          ref double[] xr,
          ref double[] yr,
          out double xs,
          out double ys)
        {
            rd = 0.0; // Позже убрать или заменить значение
            xrd = 0.0; // Убрать или изменить значение
            yrd = 0.0; // Убрать или изменить значение

            double[] x1 = new double[5];
            double[] y1 = new double[5];
            int num1 = 0;
            double num2 = 3.1415926;
            kp = 0;
            xs = ys = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            double num5 = num3;
            double num6 = num3;
            double num7 = num3;
            double ym = num3;
            double xm = num3;
            ref double local1 = ref rd;
            ref double local2 = ref xrd;
            ref double local3 = ref yrd;
            double num8;
            double num9 = num8 = 0.0;
            double num10 = num8;
            local3 = num8;
            double num11;
            double num12 = num11 = num10;
            local2 = num11;
            double num13 = num12;
            local1 = num13;
            double num14;
            double num15 = num14 = 0.0;
            double num16;
            double num17 = num16 = 0.0;
            double num18;
            double num19 = num18 = 0.0;
            int kWork;
            int num20 = kWork = 0;
            Cursor.Current = Cursors.WaitCursor;
            int kArray1 = 999999;
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            doubleArray(Rad, ref kArray1);
            doubleArray(xRad, ref kArray1);
            doubleArray(yRad, ref kArray1);
            if (kLine > kArray1)
            {
                int num21 = (int)MessageBox.Show("Индекс массива LengthenLine");
            }
            else
            {
                int kArray2 = 999999;
                int num22 = k2[kLine];
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                doubleArray(xp, ref kArray2);
                doubleArray(yp, ref kArray2);
                doubleArray(xr, ref kArray2);
                doubleArray(yr, ref kArray2);
                if (num22 > kArray2)
                {
                    int num23 = (int)MessageBox.Show("Индекс массива LengthenLine");
                }
                else
                {
                    num20 = 0;
                    double num24 = 9999999.9;
                    double num25 = 9999999.9;
                    double num26 = -9999999.9;
                    double num27 = -9999999.9;
                    for (int i1 = 1; i1 <= kLine; ++i1)
                    {
                        int num28 = k1[i1];
                        int num29 = k2[i1];
                        for (int i2 = num28; i2 <= num29; ++i2)
                        {
                            if (x[i2] < num24)
                                num24 = x[i2];
                            if (y[i2] < num25)
                                num25 = y[i2];
                            if (x[i2] > num26)
                                num26 = x[i2];
                            if (y[i2] > num27)
                                num27 = y[i2];
                        }
                    }
                    double num30 = num26 - num24;
                    double num31 = num27 - num25;
                    double num32 = Math.Sqrt(num30 * num30 + num31 * num31);
                    double num33 = 9999999.9;
                    double num34 = 9999999.9;
                    double num35 = 9999999.9;
                    int i3 = 0;
                    for (int i4 = 1; i4 <= kLine; ++i4)
                    {
                        if (Rad[i4] <= 1.0)
                        {
                            int i5 = k1[i4];
                            int i6 = k2[i4];
                            double num36 = x[i5] - xx;
                            double num37 = y[i5] - yy;
                            double num38 = Math.Sqrt(num36 * num36 + num37 * num37);
                            if (num33 > num38)
                                num33 = num38;
                            double num39 = x[i6] - xx;
                            double num40 = y[i6] - yy;
                            num4 = Math.Sqrt(num39 * num39 + num40 * num40);
                            if (num34 > num4)
                                num34 = num4;
                            if (num33 <= num34)
                                num6 = num33;
                            if (num34 < num33)
                                num6 = num34;
                            if (num35 > num6)
                            {
                                num35 = num6;
                                i3 = i4;
                            }
                        }
                    }
                    int num41;
                    if (i3 > 0)
                    {
                        int i7 = k1[i3];
                        int i8 = k2[i3];
                        rd = 0.0;
                        xrd = 0.0;
                        yrd = 0.0;
                        double num42 = x[i7] - xx;
                        double num43 = y[i7] - yy;
                        double num44 = Math.Sqrt(num42 * num42 + num43 * num43);
                        double num45 = x[i8] - xx;
                        double num46 = y[i8] - yy;
                        double num47 = Math.Sqrt(num45 * num45 + num46 * num46);
                        if (num44 <= num47)
                        {
                            num5 = x[i7];
                            num9 = y[i7];
                            double x2 = num5 - x[i7 + 1];
                            num4 = Math.Atan2(num9 - y[i7 + 1], x2);
                            if (num4 < 0.0)
                                num4 += 2.0 * num2;
                        }
                        if (num47 < num44)
                        {
                            num5 = x[i8];
                            num9 = y[i8];
                            double x3 = num5 - x[i8 - 1];
                            num4 = Math.Atan2(num9 - y[i8 - 1], x3);
                            if (num4 < 0.0)
                                num4 += 2.0 * num2;
                        }
                        double x1_1 = num5;
                        double y1_1 = num9;
                        double x2_1 = x1_1 + num32 * Math.Cos(num4);
                        double y2 = y1_1 + num32 * Math.Sin(num4);
                        double num48 = 9999999.9;
                        for (int i9 = 1; i9 <= kLine; ++i9)
                        {
                            if (i9 != i3)
                            {
                                int num49 = k1[i9];
                                int num50 = k2[i9];
                                if (Rad[i9] > 0.0)
                                {
                                    num7 = 0.0;
                                    for (int i10 = num49; i10 <= num50; ++i10)
                                    {
                                        double num51 = x[i10] - num5;
                                        double num52 = y[i10] - num9;
                                        double num53 = Math.Sqrt(num51 * num51 + num52 * num52);
                                        if (num53 > num7)
                                            num7 = num53;
                                    }
                                    if (num7 > 0.0)
                                    {
                                        x2_1 = num5 + num7 * Math.Cos(num4);
                                        y2 = num9 + num7 * Math.Sin(num4);
                                    }
                                }
                                for (int i11 = num49 + 1; i11 <= num50; ++i11)
                                {
                                    double x3 = x[i11 - 1];
                                    double y3 = y[i11 - 1];
                                    double x4 = x[i11];
                                    double y4 = y[i11];
                                    num41 = 1;
                                    TwoLine(x1_1, y1_1, x3, y3, x2_1, y2, x4, y4, out xm, out ym, ref num41);
                                    if (xm != 0.0 || ym != 0.0)
                                    {
                                        double num54 = xm - num5;
                                        double num55 = ym - num9;
                                        double num56 = Math.Sqrt(num54 * num54 + num55 * num55);
                                        if (num56 < num48)
                                        {
                                            num48 = num56;
                                            num19 = xm;
                                            num18 = ym;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    double num57 = 9999999.9;
                    double num58 = 9999999.9;
                    double num59 = 9999999.9;
                    int i12 = 0;
                    for (int i13 = 1; i13 <= kLine; ++i13)
                    {
                        if (Rad[i13] > 1.0 && i13 != i3)
                        {
                            int i14 = k1[i13];
                            int i15 = k2[i13];
                            double num60 = x[i14] - xx;
                            double num61 = y[i14] - yy;
                            double num62 = Math.Sqrt(num60 * num60 + num61 * num61);
                            if (num58 > num62)
                                num58 = num62;
                            double num63 = x[i15] - xx;
                            double num64 = y[i15] - yy;
                            double num65 = Math.Sqrt(num63 * num63 + num64 * num64);
                            if (num59 > num65)
                                num59 = num65;
                            if (num58 <= num59)
                                num7 = num58;
                            if (num59 < num58)
                                num7 = num59;
                            if (num57 > num7)
                            {
                                num57 = num7;
                                i12 = i13;
                            }
                        }
                    }
                    if (i12 > 0)
                    {
                        int i16 = k1[i12];
                        int i17 = k2[i12];
                        rd = Rad[i12];
                        xrd = xRad[i12];
                        yrd = yRad[i12];
                        int k = -1;
                        for (int i18 = i16; i18 <= i17; ++i18)
                        {
                            ++k;
                            xr[k] = x[i18];
                            yr[k] = y[i18];
                        }
                        num41 = in_out(k, ref xr, ref yr, xrd, yrd);
                        double num66 = x[i17] - x[i16];
                        double num67 = y[i17] - y[i16];
                        double num68 = Math.Sqrt(num66 * num66 + num67 * num67);
                        double num69 = Math.Abs(2.0 * rd - num68);
                        int num70 = 0;
                        if (num69 > 0.001 && num41 == 0)
                            num70 = 1;
                        double num71 = x[i16] - xx;
                        double num72 = y[i16] - yy;
                        double num73 = Math.Sqrt(num71 * num71 + num72 * num72);
                        double num74 = x[i17] - xx;
                        double num75 = y[i17] - yy;
                        double num76 = Math.Sqrt(num74 * num74 + num75 * num75);
                        if (num73 <= num76)
                        {
                            x1[0] = x[i16];
                            y1[0] = y[i16];
                            x1[2] = x[i17];
                            y1[2] = y[i17];
                        }
                        if (num76 < num73)
                        {
                            x1[0] = x[i17];
                            y1[0] = y[i17];
                            x1[2] = x[i16];
                            y1[2] = y[i16];
                        }
                        int i19 = (i16 + i17) / 2;
                        xs = x[i19];
                        ys = y[i19];
                        double x4 = xrd - xs;
                        double num77 = Math.Atan2(yrd - ys, x4);
                        if (num77 < 0.0)
                            num77 += 2.0 * num2;
                        x1[1] = xrd + rd * Math.Cos(num77);
                        y1[1] = yrd + rd * Math.Sin(num77);
                        num41 = num70;
                        Arc_3Pnt(x1, y1, out rd, out xrd, out yrd, out kWork, ref xr, ref yr, ref num41);
                        num1 = num41;
                        double num78 = 9999999.9;
                        int i20 = 0;
                        for (int i21 = 1; i21 <= kLine; ++i21)
                        {
                            if (i21 != i12)
                            {
                                int num79 = k1[i21];
                                int num80 = k2[i21];
                                for (int i22 = num79 + 1; i22 <= num80; ++i22)
                                {
                                    double x3 = x[i22 - 1];
                                    double y3 = y[i22 - 1];
                                    double x4_1 = x[i22];
                                    double y4 = y[i22];
                                    for (int i23 = 1; i23 <= kWork; ++i23)
                                    {
                                        double x1_2 = xr[i23 - 1];
                                        double y1_2 = yr[i23 - 1];
                                        double x2 = xr[i23];
                                        double y2 = yr[i23];
                                        num41 = 1;
                                        TwoLine(x1_2, y1_2, x3, y3, x2, y2, x4_1, y4, out xm, out ym, ref num41);
                                        if (xm != 0.0 || ym != 0.0)
                                        {
                                            double num81 = x1[0] - xm;
                                            double num82 = y1[0] - ym;
                                            double num83 = Math.Sqrt(num81 * num81 + num82 * num82);
                                            if (num83 < num78)
                                            {
                                                num78 = num83;
                                                i20 = i23 - 1;
                                                xs = xm;
                                                ys = ym;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (i20 > 0)
                        {
                            kp = i20;
                            xr[i20] = xs;
                            yr[i20] = ys;
                            for (int i24 = 0; i24 <= kp; ++i24)
                            {
                                xp[i24] = xr[i24];
                                yp[i24] = yr[i24];
                            }
                            xs = xp[kp];
                            ys = yp[kp];
                        }
                    }
                    if (i3 == 0 || num35 >= num57)
                        return;
                    kp = 1;
                    xp[0] = num5;
                    yp[0] = num9;
                    xp[1] = num19;
                    yp[1] = num18;
                    rd = 0.0;
                    xrd = 0.0;
                    yrd = 0.0;
                    xs = num19;
                    ys = num18;
                }
            }
        }

        public static void PerpToLine(
          double xx,
          double yy,
          int k,
          ref double[] x,
          ref double[] y,
          out double xs,
          out double ys,
          out double az,
          out int indSide)
        {
            double num1 = 3.1415926;
            indSide = 0;
            xs = ys = az = 0.0;
            double num2;
            double num3 = num2 = 0.0;
            double dist = num2;
            double yp = num2;
            double xp = num2;
            double num4;
            double num5 = num4 = 0.0;
            double num6;
            double num7 = num6 = 0.0;
            double num8 = num6;
            double num9 = num6;
            double num10 = num6;
            int ip = 0;
            int kArray = 999999;
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            if (k > kArray)
            {
                int num11 = (int)MessageBox.Show("Индекс массива PerpToLine");
            }
            else
            {
                double num12 = 9999999.9;
                for (int i = 1; i <= k; ++i)
                {
                    DistPnt(xx, yy, x[i - 1], y[i - 1], x[i], y[i], out dist, out ip, out xp, out yp);
                    if (num12 > dist && ip > 0)
                    {
                        indSide = i;
                        num12 = dist;
                        xs = xp;
                        ys = yp;
                        num10 = x[i - 1];
                        num9 = y[i - 1];
                        num8 = x[i];
                        num7 = y[i];
                        double num13 = x[i] - x[i - 1];
                        double num14 = y[i] - y[i - 1];
                        if (Math.Sqrt(num13 * num13 + num14 * num14) < 0.1)
                        {
                            if (i > 1)
                            {
                                num10 = x[i - 2];
                                num9 = y[i - 2];
                                num8 = x[i];
                                num7 = y[i];
                            }
                            else if (i < k)
                            {
                                num10 = x[i - 1];
                                num9 = y[i - 1];
                                num8 = x[i + 1];
                                num7 = y[i + 1];
                            }
                        }
                    }
                    double x1 = num8 - num10;
                    double y1 = num7 - num9;
                    az = Math.Atan2(y1, x1);
                    if (az < 0.0)
                        az += 2.0 * num1;
                }
            }
        }

        public static void LineDelete(
          int indLine,
          ref int kLine,
          ref int[] k1,
          ref int[] k2,
          ref int[] kt,
          ref int[] nCode,
          ref int[] nLong,
          ref double[] rWidth,
          ref double[] Rad,
          ref double[] xRad,
          ref double[] yRad,
          ref double[] x,
          ref double[] y,
          ref double[] z,
          out int kLin,
          ref double[] xp,
          ref double[] yp,
          ref double[] zp)
        {
            int num1;
            int num2 = num1 = 0;
            kLin = 0;
            int kArray1 = 999999;
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            intArray(kt, ref kArray1);
            intArray(nCode, ref kArray1);
            intArray(nLong, ref kArray1);
            doubleArray(Rad, ref kArray1);
            doubleArray(rWidth, ref kArray1);
            doubleArray(xRad, ref kArray1);
            doubleArray(yRad, ref kArray1);
            if (kLine > kArray1)
            {
                int num3 = (int)MessageBox.Show("Индекс массива LineDelete");
            }
            else
            {
                int kArray2 = 999999;
                int num4 = k2[kLine];
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                doubleArray(z, ref kArray2);
                doubleArray(xp, ref kArray2);
                doubleArray(yp, ref kArray2);
                doubleArray(zp, ref kArray2);
                if (num4 > kArray2)
                {
                    int num5 = (int)MessageBox.Show("Индекс массива LineDelete");
                }
                else
                {
                    int i1 = 0;
                    for (int i2 = 1; i2 <= kLine; ++i2)
                    {
                        if (i2 != indLine)
                        {
                            ++kLin;
                            nCode[kLin] = nCode[i2];
                            nLong[kLin] = nLong[i2];
                            rWidth[kLin] = rWidth[i2];
                            Rad[kLin] = Rad[i2];
                            xRad[kLin] = xRad[i2];
                            yRad[kLin] = yRad[i2];
                            int num6 = k1[i2];
                            int num7 = k2[i2];
                            int num8 = 0;
                            for (int i3 = num6; i3 <= num7; ++i3)
                            {
                                ++num8;
                                ++i1;
                                xp[i1] = x[i3];
                                yp[i1] = y[i3];
                                zp[i1] = z[i3];
                            }
                            kt[kLin] = num8;
                        }
                    }
                    kLine = kLin;
                    k1[1] = 1;
                    k2[1] = kt[1];
                    if (kLin > 1)
                    {
                        for (int i4 = 2; i4 <= kLin; ++i4)
                        {
                            k1[i4] = k2[i4 - 1] + 1;
                            k2[i4] = k2[i4 - 1] + kt[i4];
                        }
                    }
                    for (int i5 = 1; i5 <= i1; ++i5)
                    {
                        x[i5] = xp[i5];
                        y[i5] = yp[i5];
                        z[i5] = zp[i5];
                    }
                }
            }
        }

        public static void FindLine(
          double xx,
          double yy,
          int kLine,
          ref int[] k1,
          ref int[] k2,
          ref double[] Rad,
          ref double[] xRad,
          ref double[] yRad,
          ref double[] x,
          ref double[] y,
          out double rd,
          out double xrd,
          out double yrd,
          out int kp,
          ref double[] xp,
          ref double[] yp,
          ref double[] xr,
          ref double[] yr,
          out double xs,
          out double ys,
          out double az,
          out int indLine)
        {

            xrd = 0.0; // Переменная для устранения ошибки
            rd = 0.0; // Переменная для устранения ошибки
            yrd = 0.0; // Переменная для устранения ошибки

            double num1 = 3.1415926;
            kp = 0;
            indLine = 0;
            xs = ys = az = 0.0;
            double num2;
            double num3 = num2 = 0.0;
            double num4 = num2;
            double dist = num2;
            double yp1 = num2;
            double xp1 = num2;
            ref double local1 = ref rd;
            ref double local2 = ref xrd;
            ref double local3 = ref yrd;
            double num5;
            double num6 = num5 = 0.0;
            double num7 = num5;
            local3 = num5;
            double num8;
            double num9 = num8 = num7;
            local2 = num8;
            double num10 = num9;
            local1 = num10;
            double num11;
            double num12 = num11 = 0.0;
            double num13 = num11;
            double num14 = num11;
            double num15 = num11;
            double num16;
            double num17 = num16 = 0.0;
            double num18 = num16;
            double num19 = num16;
            double num20 = num16;
            int i1;
            int ip = i1 = 0;
            int kArray1 = 999999;
            intArray(k1, ref kArray1);
            intArray(k2, ref kArray1);
            doubleArray(Rad, ref kArray1);
            doubleArray(xRad, ref kArray1);
            doubleArray(yRad, ref kArray1);
            if (kLine > kArray1)
            {
                int num21 = (int)MessageBox.Show("Индекс массива FindLine");
            }
            else
            {
                int num22 = k2[kLine];
                int kArray2 = 999999;
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                if (num22 > kArray2)
                {
                    int num23 = (int)MessageBox.Show("Индекс массива FindLine");
                }
                else
                {
                    kArray2 = 999999;
                    doubleArray(xp, ref kArray2);
                    doubleArray(yp, ref kArray2);
                    doubleArray(xr, ref kArray2);
                    doubleArray(yr, ref kArray2);
                    double num24 = 9999999.9;
                    for (int i2 = 1; i2 <= kLine; ++i2)
                    {
                        int num25 = k1[i2];
                        int num26 = k2[i2];
                        int i3 = 0;
                        for (int i4 = num25; i4 <= num26; ++i4)
                        {
                            ++i3;
                            if (i3 > kArray2)
                            {
                                int num27 = (int)MessageBox.Show("Индекс массива FindLine");
                                return;
                            }
                            xr[i3] = x[i4];
                            yr[i3] = y[i4];
                        }
                        if (Rad[i2] <= 0.0)
                        {
                            double num28 = 999999.9;
                            for (int i5 = 2; i5 <= i3; ++i5)
                            {
                                DistPnt(xx, yy, xr[i5 - 1], yr[i5 - 1], xr[i5], yr[i5], out dist, out ip, out xp1, out yp1);
                                if (num28 > dist && ip > 0)
                                {
                                    num28 = dist;
                                    num4 = xp1;
                                    num6 = yp1;
                                    num15 = xr[i5 - 1];
                                    num14 = yr[i5 - 1];
                                    num13 = xr[i5];
                                    num12 = yr[i5];
                                    double num29 = xr[i5] - xr[i5 - 1];
                                    double num30 = yr[i5] - yr[i5 - 1];
                                    if (Math.Sqrt(num29 * num29 + num30 * num30) < 0.1)
                                    {
                                        if (i5 > 2)
                                        {
                                            num15 = xr[i5 - 2];
                                            num14 = yr[i5 - 2];
                                            num13 = xr[i5];
                                            num12 = yr[i5];
                                        }
                                        else if (i5 < i3)
                                        {
                                            num15 = xr[i5 - 1];
                                            num14 = yr[i5 - 1];
                                            num13 = xr[i5 + 1];
                                            num12 = yr[i5 + 1];
                                        }
                                    }
                                }
                            }
                            if (num24 > num28)
                            {
                                num24 = num28;
                                i1 = i2;
                                xs = num4;
                                ys = num6;
                                num20 = num15;
                                num19 = num14;
                                num18 = num13;
                                num17 = num12;
                            }
                            double x1 = num18 - num20;
                            double num31 = Math.Atan2(num17 - num19, x1);
                            if (num31 < 0.0)
                                num3 = num31 + 2.0 * num1;
                        }
                        if (Rad[i2] > 0.0)
                        {
                            double num32 = 999999.9;
                            for (int i6 = 1; i6 <= i3; ++i6)
                            {
                                double num33 = xr[i6] - xx;
                                double num34 = yr[i6] - yy;
                                dist = Math.Sqrt(num33 * num33 + num34 * num34);
                                if (num32 > dist)
                                    num32 = dist;
                            }
                            if (num24 > num32)
                            {
                                num24 = num32;
                                i1 = i2;
                            }
                        }
                    }
                    if (i1 <= 0)
                        return;
                    indLine = i1;
                    int num35 = k1[i1];
                    int num36 = k2[i1];
                    rd = Rad[i1];
                    xrd = xRad[i1];
                    yrd = yRad[i1];
                    int i7 = -1;
                    for (int i8 = num35; i8 <= num36; ++i8)
                    {
                        ++i7;
                        if (i7 > kArray2)
                        {
                            int num37 = (int)MessageBox.Show("Индекс массива FindLine");
                            return;
                        }
                        xp[i7] = x[i8];
                        yp[i7] = y[i8];
                    }
                    kp = i7;
                }
            }
        }

        // Создание интерфейса

        public static void FormCreate(
          int iParam,
          out int iRadio,
          out double rRad,
          out double pRad,
          out string sForm,
          out string pForm,
          string sTmp1,
          string sTmp2)
        {
            iRadio = 0;
            rRad = 0.0;
            pRad = 0.0;
            sForm = "";
            pForm = "";
            Form form = new Form();
            TextBox textBox1 = new TextBox();
            textBox1.Left = 110;
            textBox1.Top = 45;
            textBox1.Text = "0";
            textBox1.Width = 70;
            form.Size = new Size(230, 200);
            form.StartPosition = FormStartPosition.CenterScreen;
            form.FormBorderStyle = FormBorderStyle.FixedDialog;
            form.Text = "Входные данные";
            form.MaximizeBox = false;
            form.MinimizeBox = false;
            form.Controls.Add((Control)textBox1);
            form.BackColor = Color.Gold;
            Button button1 = new Button();
            button1.Text = "Подтвердить";
            button1.Font = new Font("Arial", 10f, FontStyle.Bold);
            button1.Size = new Size(80, 24);
            button1.Location = new Point(15, 120);
            button1.BackColor = Color.Silver;
            button1.Visible = true;
            button1.DialogResult = DialogResult.OK;
            form.Controls.Add((Control)button1);
            Button button2 = new Button();
            button2.Text = "Отмена";
            button2.Font = new Font("Arial", 10f, FontStyle.Bold);
            button2.Size = new Size(80, 24);
            button2.Location = new Point(125, 120);
            button2.BackColor = Color.Silver;
            button2.Visible = true;
            button2.DialogResult = DialogResult.Cancel;
            form.Controls.Add((Control)button2);
            Label label1 = new Label();
            label1.Left = 0;
            label1.Top = 0;
            label1.BackColor = Color.Yellow;
            label1.Width = 225;
            label1.Height = 15;
            sTmp2 = "Расстояние между выбранными точками = " + sTmp1 + " м";
            if (iParam == 1 || iParam == 4 || iParam == 5)
                sTmp2 = "";
            if (iParam == 6)
                sTmp2 = "Предшествующее расстояние между вершинами = " + sTmp1 + " м";
            label1.Text = sTmp2;
            form.Controls.Add((Control)label1);
            Label label2 = new Label();
            label2.Left = 15;
            label2.Top = 25;
            label2.BackColor = Color.Yellow;
            label2.Width = 190;
            label2.Height = 15;
            label2.Text = "Радиус должен быть > половины расстояния";
            if (iParam == 1 || iParam == 4 || iParam == 5 || iParam == 6)
                label2.Text = "";
            form.Controls.Add((Control)label2);
            Label label3 = new Label();
            label3.Left = 45;
            label3.Top = 47;
            label3.BackColor = Color.Yellow;
            label3.Width = 60;
            label3.Height = 15;
            label3.Text = "Радиус,м =";
            if (iParam == 4 || iParam == 5 || iParam == 6)
                label3.Text = "Расстояние, м =";
            form.Controls.Add((Control)label3);
            iRadio = 0;
            RadioButton radioButton1 = new RadioButton();
            RadioButton radioButton2 = new RadioButton();
            if (iParam == 2)
            {
                label1.Text = "Установите расстояние новой линии от выбранной линии";
                label2.Text = "и положение новой строки: слева или справа ";
                label3.Text = "Расстояние, м =";
                radioButton1.Top = 70;
                radioButton1.Left = 45;
                radioButton1.Width = 60;
                radioButton1.Height = 15;
                radioButton1.BackColor = Color.LightGray;
                radioButton1.Text = "Лево";
                radioButton1.Visible = true;
                radioButton1.Checked = true;
                form.Controls.Add((Control)radioButton1);
                radioButton2.Top = 70;
                radioButton2.Left = 120;
                radioButton2.Width = 60;
                radioButton2.Height = 15;
                radioButton2.BackColor = Color.LightGray;
                radioButton2.Text = "Право";
                radioButton2.Visible = true;
                form.Controls.Add((Control)radioButton2);
            }
            TextBox textBox2 = new TextBox();
            Label label4 = new Label();
            if (iParam == 3)
            {
                label3.Text = "Радиус,м =";
                label4.Left = 15;
                label4.Top = 90;
                label4.BackColor = Color.Yellow;
                label4.Width = 110;
                label4.Height = 15;
                label4.Text = "Переходный радиус, м =";
                form.Controls.Add((Control)label4);
                textBox2.Left = 130;
                textBox2.Top = 88;
                textBox2.Text = "0";
                textBox2.Width = 70;
                form.Controls.Add((Control)textBox2);
            }
            int num = (int)form.ShowDialog();
            if (textBox1.Text == "")
                textBox1.Text = "0";
            rRad = Convert.ToDouble(textBox1.Text);
            sForm = textBox1.Text;
            if (iParam == 3)
            {
                if (textBox2.Text == "")
                    textBox2.Text = string.Format("{0:F2}", (object)(0.5 * rRad));
                pRad = Convert.ToDouble(textBox2.Text);
                pForm = textBox2.Text;
            }
            if (radioButton1.Checked)
                iRadio = 1;
            if (radioButton2.Checked)
                iRadio = 2;
            if (form.DialogResult == DialogResult.OK)
            {
                form.Dispose();
            }
            else
            {
                iRadio = 0;
                rRad = 0.0;
                pRad = 0.0;
                sForm = "";
                pForm = "";
                form.Dispose();
            }
        }

        public static void Line_Spl(
          int ke,
          ref double[] xe,
          ref double[] ye,
          out int k,
          ref double[] x,
          ref double[] y,
          ref double[] xr,
          ref double[] yr,
          int nVertex)
        {
            double shag = 0.7;
            double num1;
            double num2 = num1 = 0.0;
            int num3;
            int num4 = num3 = 0;
            int it = num3;
            int num5 = num3;
            int i1 = num3;
            int kxy = num3;
            k = 0;
            int kArray1 = 999999;
            doubleArray(xe, ref kArray1);
            doubleArray(ye, ref kArray1);
            if (ke > kArray1)
            {
                int num6 = (int)MessageBox.Show("Индекс массива Line_Spl");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                doubleArray(xr, ref kArray2);
                doubleArray(yr, ref kArray2);
                double num7 = xe[0];
                double num8 = ye[0];
                double num9 = 0.0;
                for (int i2 = 1; i2 <= ke; ++i2)
                {
                    double num10 = xe[i2] - xe[i2 - 1];
                    double num11 = ye[i2] - ye[i2 - 1];
                    double num12 = Math.Sqrt(num10 * num10 + num11 * num11);
                    num9 += num12;
                }
                do
                {
                    shag += 0.05;
                }
                while (Convert.ToInt32(num9 / shag) > nVertex);
                int i3 = 0;
                for (int i4 = 1; i4 <= ke; ++i4)
                {
                    double num13 = xe[i4] - xe[i3];
                    double num14 = ye[i4] - ye[i3];
                    if (Math.Sqrt(num13 * num13 + num14 * num14) >= 0.1)
                    {
                        ++i3;
                        xe[i3] = xe[i4];
                        ye[i3] = ye[i4];
                    }
                }
                ke = i3;
                double num15 = xe[ke] - xe[0];
                double num16 = ye[ke] - ye[0];
                if (Math.Sqrt(num15 * num15 + num16 * num16) < 0.1)
                {
                    --ke;
                    it = 1;
                }
                LineSpln(it, ref xe, ref ye, ke, ref x, ref y, out kxy, shag);
                if (kxy > kArray2)
                {
                    int num17 = (int)MessageBox.Show("Индекс массива Line_Spl");
                    k = 0;
                }
                else
                {
                    k = kxy;
                    if (it > 0)
                    {
                        double num18 = 99999.9;
                        for (int i5 = 0; i5 <= kxy; ++i5)
                        {
                            double num19 = x[i5] - xe[ke];
                            double num20 = y[i5] - ye[ke];
                            double num21 = Math.Sqrt(num19 * num19 + num20 * num20);
                            if (num21 <= num18)
                            {
                                num18 = num21;
                                i1 = i5;
                            }
                        }
                        int i6 = 0;
                        xr[i6] = xe[ke];
                        yr[i6] = ye[ke];
                        int num22 = ke - 1;
                        for (int i7 = 0; i7 <= num22; ++i7)
                        {
                            ++i6;
                            xr[i6] = xe[i7];
                            yr[i6] = ye[i7];
                        }
                        int num23 = i6;
                        int i8 = 0;
                        for (int i9 = 1; i9 <= num23; ++i9)
                        {
                            double num24 = xr[i9] - xr[i8];
                            double num25 = yr[i9] - yr[i8];
                            if (Math.Sqrt(num24 * num24 + num25 * num25) >= 0.1)
                            {
                                ++i8;
                                xr[i8] = xr[i9];
                                yr[i8] = yr[i9];
                            }
                        }
                        int N = i8;
                        double num26 = xr[N] - xr[0];
                        double num27 = yr[N] - yr[0];
                        if (Math.Sqrt(num26 * num26 + num27 * num27) <= 0.1)
                            --N;
                        LineSpln(it, ref xr, ref yr, N, ref xe, ref ye, out ke, shag);
                        if (ke == 0)
                        {
                            int num28 = (int)MessageBox.Show("Индекс массива Line_Spl");
                            k = 0;
                        }
                        else
                        {
                            int num29 = 1;
                            double num30 = 99999.9;
                            for (int i10 = 0; i10 <= ke; ++i10)
                            {
                                double num31 = xe[i10] - xr[1];
                                double num32 = ye[i10] - yr[1];
                                double num33 = Math.Sqrt(num31 * num31 + num32 * num32);
                                if (num33 <= num30)
                                {
                                    num30 = num33;
                                    num5 = i10;
                                }
                            }
                            int num34 = num5 - 1;
                            for (int i11 = num29; i11 <= num34; ++i11)
                            {
                                ++i1;
                                x[i1] = xe[i11];
                                y[i1] = ye[i11];
                            }
                            kxy = i1;
                            k = i1;
                            ke = i1;
                            double num35 = x[0] - num7;
                            double num36 = y[0] - num8;
                            double num37 = Math.Sqrt(num35 * num35 + num36 * num36);
                            if (num37 >= 0.03)
                            {
                                xe[0] = num7;
                                ye[0] = num8;
                                int i12 = 0;
                                for (int i13 = 0; i13 <= ke; ++i13)
                                {
                                    ++i12;
                                    xe[i12] = x[i13];
                                    ye[i12] = y[i13];
                                }
                                ke = i12;
                                kxy = i12;
                                k = i12;
                                for (int i14 = 0; i14 <= kxy; ++i14)
                                {
                                    x[i14] = xe[i14];
                                    y[i14] = ye[i14];
                                }
                            }
                            if (num37 < 0.03)
                            {
                                for (int i15 = 0; i15 <= ke; ++i15)
                                {
                                    xe[i15] = x[i15];
                                    ye[i15] = y[i15];
                                }
                            }
                            double num38 = xe[ke] - xe[0];
                            double num39 = ye[ke] - ye[0];
                            if (Math.Sqrt(num38 * num38 + num39 * num39) < 0.005)
                                return;
                            xe[ke] = xe[0];
                            ye[ke] = ye[0];
                        }
                    }
                    else
                    {
                        x[0] = xe[0];
                        y[0] = ye[0];
                        x[kxy] = xe[ke];
                        y[kxy] = ye[ke];
                        int i16 = 0;
                        for (int i17 = 1; i17 <= kxy; ++i17)
                        {
                            double num40 = x[i17] - x[i16];
                            double num41 = y[i17] - y[i16];
                            if (Math.Sqrt(num40 * num40 + num41 * num41) > 0.1)
                            {
                                ++i16;
                                x[i16] = x[i17];
                                y[i16] = y[i17];
                            }
                        }
                        x[i16] = xe[ke];
                        y[i16] = ye[ke];
                        kxy = i16;
                        k = i16;
                        ke = kxy;
                        for (int i18 = 0; i18 <= ke; ++i18)
                        {
                            xe[i18] = x[i18];
                            ye[i18] = y[i18];
                        }
                        int i19 = 0;
                        for (int i20 = 1; i20 <= ke; ++i20)
                        {
                            double num42 = xe[i20] - xe[i19];
                            double num43 = ye[i20] - ye[i19];
                            if (Math.Sqrt(num42 * num42 + num43 * num43) >= 0.1)
                            {
                                ++i19;
                                xe[i19] = xe[i20];
                                ye[i19] = ye[i20];
                            }
                        }
                        ke = i19;
                    }
                }
            }
        }

        public static void Triangle(double a, double b, double c, out double dLine, out double dPerp)
        {
            dLine = 0.0;
            dPerp = 0.0;
            double num = b + c;
            if (num <= a)
                return;
            if (b <= a && c <= a)
            {
                num = (a * a + b * b - c * c) / (2.0 * a);
                dLine = num;
            }
            if (b > a || c > a)
            {
                num = (b * b - a * a - c * c) / (2.0 * a);
                dLine = a + num;
            }
            dPerp = Math.Sqrt(b * b - num * num);
        }

        public static double GraRad(double gra)
        {
            double num1 = 3.141592654 / 180.0;
            double num2 = num1 / 60.0;
            double num3 = num2 / 60.0;
            long int32_1 = (long)Convert.ToInt32(0.01 * gra);
            long int32_2 = (long)Convert.ToInt32(0.0001 * gra);
            double num4 = gra - 100.0 * (double)int32_1;
            long num5 = int32_1 - 100L * int32_2;
            return (double)int32_2 * num1 + (double)num5 * num2 + num4 * num3;
        }

        public static void LinearResect(
          int iParam,
          double x1,
          double y1,
          double x2,
          double y2,
          double dist1,
          double dist2,
          out double xt,
          out double yt)
        {
            xt = 0.0;
            yt = 0.0;
            double dPerp;
            double dLine = dPerp = 0.0;
            double num1;
            double num2 = num1 = 0.0;
            double num3 = 3.1415926;
            if (double.IsNaN(x1) || double.IsNaN(y1) || double.IsNaN(x2) || double.IsNaN(y2))
            {
                int num4 = (int)MessageBox.Show("Проблема данных-LinearResect");
            }
            else if (double.IsNaN(dist1) || double.IsNaN(dist2))
            {
                int num5 = (int)MessageBox.Show("Проблема данных-LinearResect");
            }
            else
            {
                if (dist1 == 0.0 || dist2 == 0.0)
                    return;
                double x = x2 - x1;
                double y = y2 - y1;
                double a = Math.Sqrt(x * x + y * y);
                double num6 = Math.Atan2(y, x);
                if (num6 < 0.0)
                    num6 += 2.0 * num3;
                if (a >= dist1 + dist2)
                    return;
                if (iParam == 1)
                {
                    num2 = num6 + 0.5 * num3;
                    if (num2 >= 2.0 * num3)
                        num2 -= 2.0 * num3;
                }
                if (iParam == 2)
                {
                    num2 = num6 - 0.5 * num3;
                    if (num2 < 0.0)
                        num2 += 2.0 * num3;
                }
                Triangle(a, dist1, dist2, out dLine, out dPerp);
                xt = x1 + dLine * Math.Cos(num6) + dPerp * Math.Cos(num2);
                yt = y1 + dLine * Math.Sin(num6) + dPerp * Math.Sin(num2);
            }
        }

        public static void Perpendicular(
          int iParam,
          double x1,
          double y1,
          double x2,
          double y2,
          double dist1,
          double dist2,
          out double xt,
          out double yt)
        {
            xt = 0.0;
            yt = 0.0;
            double num1;
            double num2 = num1 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            double num5 = 3.1415926;
            if (double.IsNaN(x1) || double.IsNaN(y1) || double.IsNaN(x2) || double.IsNaN(y2))
            {
                int num6 = (int)MessageBox.Show("Проблема данных-перпендикуляр");
            }
            else if (double.IsNaN(dist1) || double.IsNaN(dist2))
            {
                int num7 = (int)MessageBox.Show("Проблема данных-перпендикуляр");
            }
            else
            {
                if (dist1 == 0.0 && dist2 == 0.0)
                    return;
                double x = x2 - x1;
                double num8 = Math.Atan2(y2 - y1, x);
                if (num8 < 0.0)
                    num8 += 2.0 * num5;
                if (iParam == 1)
                {
                    num4 = num8 + 0.5 * num5;
                    if (num4 >= 2.0 * num5)
                        num4 -= 2.0 * num5;
                }
                if (iParam == 2)
                {
                    num4 = num8 - 0.5 * num5;
                    if (num4 < 0.0)
                        num4 += 2.0 * num5;
                }
                double num9 = x1 + dist1 * Math.Cos(num8);
                double num10 = y1 + dist1 * Math.Sin(num8);
                xt = num9 + dist2 * Math.Cos(num4);
                yt = num10 + dist2 * Math.Sin(num4);
            }
        }

        public static void Inverse(
          double[] x,
          double[] y,
          double[] dir,
          out double xt,
          out double yt)
        {
            double[] numArray = new double[5];
            double num1;
            double ym1 = num1 = 0.0;
            double xm1 = num1;
            double ym2 = num1;
            double xm2 = num1;
            double num2;
            double num3 = num2 = 0.0;
            double num4;
            double num5 = num4 = 0.0;
            double num6;
            double num7 = num6 = 0.0;
            xt = 0.0;
            yt = 0.0;
            double num8 = 3.141592654;
            double num9 = 2.0 * num8;
            int num10;
            int num11 = num10 = 0;
            int num12 = 2;
            int kArray = 999999;
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            doubleArray(dir, ref kArray);
            int num13 = kArray - 3;
            if (num12 > num13)
            {
                int num14 = (int)MessageBox.Show("Индекс массива Inverse");
            }
            else
            {
                for (int i = 0; i <= num12; ++i)
                    numArray[i] = GraRad(dir[i]);
                if (numArray[1] < numArray[0])
                    numArray[1] = numArray[1] + num9;
                if (numArray[2] < numArray[1])
                    numArray[2] = numArray[2] + num9;
                double num15 = numArray[1] - numArray[0];
                double num16 = numArray[2] - numArray[1];
                double x1 = x[0] - x[2];
                double y1 = y[0] - y[2];
                if (Math.Sqrt(x1 * x1 + y1 * y1) < 0.005)
                    return;
                double num17 = Math.Atan2(y1, x1);
                if (num17 < 0.0)
                    num17 += num9;
                double num18 = Math.Sqrt(x1 * x1 + y1 * y1);
                double num19 = num15 + num16;
                if (num19 > num8)
                {
                    double x1_1 = x[0];
                    double y1_1 = y[0];
                    double x3_1 = x[2];
                    double y3_1 = y[2];
                    double num20 = num17 + num16;
                    if (num20 >= num9)
                        num20 -= num9;
                    double x2_1 = x1_1 + num18 * Math.Cos(num20);
                    double y2_1 = y1_1 + num18 * Math.Sin(num20);
                    double num21 = num17 + num8 - num15;
                    if (num21 >= num9)
                        num21 -= num9;
                    if (num21 < 0.0)
                        num21 += num9;
                    double x4_1 = x3_1 + num18 * Math.Cos(num21);
                    double y4_1 = y3_1 + num18 * Math.Sin(num21);
                    int ip1 = 0;
                    TwoLine(x1_1, y1_1, x3_1, y3_1, x2_1, y2_1, x4_1, y4_1, out xm2, out ym2, ref ip1);
                    double x2 = x[1] - xm2;
                    double y2 = y[1] - ym2;
                    if (Math.Sqrt(x2 * x2 + y2 * y2) < 0.005)
                        return;
                    double num22 = Math.Atan2(y2, x2);
                    if (num22 < 0.0)
                        num22 += num9;
                    double num23 = num22 + num15;
                    if (num23 > num9)
                        num23 -= num9;
                    double x2_2 = x1_1 - num18 * Math.Cos(num23);
                    double y2_2 = y1_1 - num18 * Math.Sin(num23);
                    double x3_2 = xm2;
                    double y3_2 = ym2;
                    double x4_2 = x[1];
                    double y4_2 = y[1];
                    int ip2 = 0;
                    TwoLine(x1_1, y1_1, x3_2, y3_2, x2_2, y2_2, x4_2, y4_2, out xm2, out ym2, ref ip2);
                    double num24 = num22 - num16;
                    if (num24 < 0.0)
                        num24 += num9;
                    double x1_2 = x[2];
                    double y1_2 = y[2];
                    double x2_3 = x1_2 - num18 * Math.Cos(num24);
                    double y2_3 = y1_2 - num18 * Math.Sin(num24);
                    int ip3 = 0;
                    TwoLine(x1_2, y1_2, x3_2, y3_2, x2_3, y2_3, x4_2, y4_2, out xm1, out ym1, ref ip3);
                }
                if (num19 < num8)
                {
                    double x1_3 = x[0];
                    double y1_3 = y[0];
                    double x3_3 = x[2];
                    double y3_3 = y[2];
                    double num25 = num17 + num16 - num8;
                    if (num25 >= num9)
                        num25 -= num9;
                    if (num25 < 0.0)
                        num25 += num9;
                    double x2_4 = x1_3 + num18 * Math.Cos(num25);
                    double y2_4 = y1_3 + num18 * Math.Sin(num25);
                    double num26 = num17 - num15;
                    if (num26 >= num9)
                        num26 -= num9;
                    if (num26 < 0.0)
                        num26 += num9;
                    double x4_3 = x3_3 + num18 * Math.Cos(num26);
                    double y4_3 = y3_3 + num18 * Math.Sin(num26);
                    int ip4 = 0;
                    TwoLine(x1_3, y1_3, x3_3, y3_3, x2_4, y2_4, x4_3, y4_3, out xm2, out ym2, ref ip4);
                    double x3 = x[1] - xm2;
                    double y3 = y[1] - ym2;
                    if (Math.Sqrt(x3 * x3 + y3 * y3) < 0.005)
                        return;
                    double num27 = Math.Atan2(y3, x3);
                    if (num27 < 0.0)
                        num27 += num9;
                    double num28 = num27 + num15;
                    if (num28 > num9)
                        num28 -= num9;
                    double x2_5 = x1_3 - num18 * Math.Cos(num28);
                    double y2_5 = y1_3 - num18 * Math.Sin(num28);
                    double x3_4 = xm2;
                    double y3_4 = ym2;
                    double x4_4 = x[1];
                    double y4_4 = y[1];
                    int ip5 = 0;
                    TwoLine(x1_3, y1_3, x3_4, y3_4, x2_5, y2_5, x4_4, y4_4, out xm2, out ym2, ref ip5);
                    double num29 = num27 - num16;
                    if (num29 < 0.0)
                        num29 += num9;
                    double x1_4 = x[2];
                    double y1_4 = y[2];
                    double x2_6 = x1_4 - num18 * Math.Cos(num29);
                    double y2_6 = y1_4 - num18 * Math.Sin(num29);
                    int ip6 = 0;
                    TwoLine(x1_4, y1_4, x3_4, y3_4, x2_6, y2_6, x4_4, y4_4, out xm1, out ym1, ref ip6);
                }
                xt = 0.5 * (xm2 + xm1);
                yt = 0.5 * (ym2 + ym1);
            }
        }

        public static void AngularResect(
          int iParam,
          double xa,
          double ya,
          double xb,
          double yb,
          double ang1,
          double ang2,
          out double xt,
          out double yt)
        {
            xt = 0.0;
            yt = 0.0;
            double num1;
            double num2 = num1 = 0.0;
            double ym = num1;
            double xm = num1;
            double num3;
            double num4 = num3 = 0.0;
            double num5;
            double num6 = num5 = 0.0;
            double y2;
            double x2 = y2 = 0.0;
            double y4;
            double x4 = y4 = 0.0;
            double num7 = 3.1415926;
            if (double.IsNaN(xa) || double.IsNaN(ya) || double.IsNaN(xb) || double.IsNaN(yb))
            {
                int num8 = (int)MessageBox.Show("Проблема данных-AngularResect");
            }
            else if (double.IsNaN(ang1) || double.IsNaN(ang2))
            {
                int num9 = (int)MessageBox.Show("Проблема данных-AngularResect");
            }
            else
            {
                if (ang1 == 0.0 || ang2 == 0.0)
                    return;
                double x = xb - xa;
                double y = yb - ya;
                double num10 = Math.Sqrt(x * x + y * y);
                double num11 = Math.Atan2(y, x);
                if (num11 < 0.0)
                    num11 += 2.0 * num7;
                double num12 = GraRad(ang1);
                double num13 = GraRad(ang2);
                if (iParam == 1)
                {
                    double num14 = num11 + num12;
                    if (num14 >= 2.0 * num7)
                        num14 -= 2.0 * num7;
                    x2 = xa + num10 * Math.Cos(num14);
                    y2 = ya + num10 * Math.Sin(num14);
                    double num15 = num11 + num7 - num13;
                    if (num15 >= 2.0 * num7)
                        num15 -= 2.0 * num7;
                    if (num15 < 0.0)
                        num15 += 2.0 * num7;
                    x4 = xb + num10 * Math.Cos(num15);
                    y4 = yb + num10 * Math.Sin(num15);
                }
                if (iParam == 2)
                {
                    double num16 = num11 - num12;
                    if (num16 < 0.0)
                        num16 += 2.0 * num7;
                    x2 = xa + num10 * Math.Cos(num16);
                    y2 = ya + num10 * Math.Sin(num16);
                    double num17 = num11 - num7 + num13;
                    if (num17 >= 2.0 * num7)
                        num17 -= 2.0 * num7;
                    if (num17 < 0.0)
                        num17 += 2.0 * num7;
                    x4 = xb + num10 * Math.Cos(num17);
                    y4 = yb + num10 * Math.Sin(num17);
                }
                int ip = 0;
                TwoLine(xa, ya, xb, yb, x2, y2, x4, y4, out xm, out ym, ref ip);
                xt = xm;
                yt = ym;
            }
        }

        public static void SelPoint(
          int kPnt,
          double[] xp,
          double[] yp,
          double xx,
          double yy,
          out int indx)
        {
            indx = -1;
            int kArray = 999999;
            doubleArray(xp, ref kArray);
            doubleArray(yp, ref kArray);
            if (kPnt > kArray)
            {
                int num1 = (int)MessageBox.Show("Индекс массива SelPoint");
            }
            else
            {
                double num2 = 9999999.9;
                for (int i = 0; i <= kPnt; ++i)
                {
                    double num3 = xp[i] - xx;
                    double num4 = yp[i] - yy;
                    double num5 = Math.Sqrt(num3 * num3 + num4 * num4);
                    if (num5 < num2)
                    {
                        indx = i;
                        num2 = num5;
                    }
                }
            }
        }

        public static void NewPointName(int kPnt, string[] pntName, out int nName, out string sName)
        {
            nName = -9999999;
            sName = "";
            if (kPnt < 0)
                return;
            int kArray = 999999;
            DllClass1.stringArray(pntName, ref kArray);
            kArray -= 3;
            if (kPnt > kArray)
            {
                int num1 = (int)MessageBox.Show("Индекс массива NewPointName");
            }
            else
            {
                for (int index1 = 0; index1 <= kPnt; ++index1)
                {
                    if (!(pntName[index1] == ""))
                    {
                        string str1 = "";
                        string str2 = "aa" + pntName[index1];
                        int length = str2.Length;
                        int num2 = -1;
                        for (int index2 = 0; index2 < str2.Length; ++index2)
                        {
                            if (char.IsDigit(str2[index2]))
                            {
                                ++num2;
                                str1 += (object)str2[index2];
                                //str1 += (string)(object)str2[index2];
                            }
                        }
                        if (!(str1 == "") && num2 >= 0)
                        {
                            int int32 = Convert.ToInt32(str1);
                            if (int32 > nName)
                                nName = int32;
                        }
                    }
                }
                if (nName < 0)
                    nName = 998;
                ++nName;
                sName = Convert.ToString(nName);
            }
        }

        public static void KeepPntHeig(
          string fCurPnt,
          string fCurHeig,
          ref double xmin,
          ref double ymin,
          ref double xmax,
          ref double ymax,
          ref double zmin,
          ref double zmax,
          int kPntPlus,
          int kPntInput,
          string[] namePnt,
          double[] xPnt,
          double[] yPnt,
          double[] zPnt,
          int[] nCode1,
          int[] nCode2,
          ref int kHeight,
          string[] nameHeig,
          double[] xHeig,
          double[] yHeig,
          double[] zHeig)
        {
            xmin = 9999999.9;
            ymin = 9999999.9;
            zmin = 9999999.9;
            xmax = -9999999.9;
            ymax = -9999999.9;
            zmax = -9999999.9;
            for (int i = 0; i <= kPntPlus; ++i)
            {
                if (xPnt[i] < xmin)
                    xmin = xPnt[i];
                if (yPnt[i] < ymin)
                    ymin = yPnt[i];
                if (xPnt[i] > xmax)
                    xmax = xPnt[i];
                if (yPnt[i] > ymax)
                    ymax = yPnt[i];
                if (zPnt[i] != 0.0)
                {
                    if (zPnt[i] < zmin)
                        zmin = zPnt[i];
                    if (zPnt[i] > zmax)
                        zmax = zPnt[i];
                }
            }
            if (File.Exists(fCurPnt))
                File.Delete(fCurPnt);
            FileStream output1 = new FileStream(fCurPnt, FileMode.CreateNew);
            BinaryWriter binaryWriter1 = new BinaryWriter((Stream)output1);
            binaryWriter1.Write(kPntPlus);
            binaryWriter1.Write(xmin);
            binaryWriter1.Write(ymin);
            binaryWriter1.Write(zmin);
            binaryWriter1.Write(xmax);
            binaryWriter1.Write(ymax);
            binaryWriter1.Write(zmax);
            for (int i = 0; i <= kPntPlus; ++i)
            {
                binaryWriter1.Write(namePnt[i]);
                binaryWriter1.Write(xPnt[i]);
                binaryWriter1.Write(yPnt[i]);
                binaryWriter1.Write(zPnt[i]);
                binaryWriter1.Write(nCode1[i]);
                binaryWriter1.Write(nCode2[i]);
            }
            binaryWriter1.Write(kPntInput);
            binaryWriter1.Close();
            output1.Close();
            kHeight = -1;
            for (int i = 0; i <= kPntPlus; ++i)
            {
                if (zPnt[i] != 0.0)
                {
                    ++kHeight;
                    nameHeig[kHeight] = namePnt[i];
                    xHeig[kHeight] = xPnt[i];
                    yHeig[kHeight] = yPnt[i];
                    zHeig[kHeight] = zPnt[i];
                }
            }
            if (File.Exists(fCurHeig))
                File.Delete(fCurHeig);
            if (kHeight <= 3)
                return;
            FileStream output2 = new FileStream(fCurHeig, FileMode.CreateNew);
            BinaryWriter binaryWriter2 = new BinaryWriter((Stream)output2);
            binaryWriter2.Write(kHeight);
            for (int i = 0; i <= kHeight; ++i)
            {
                binaryWriter2.Write(nameHeig[i]);
                binaryWriter2.Write(xHeig[i]);
                binaryWriter2.Write(yHeig[i]);
                binaryWriter2.Write(zHeig[i]);
            }
            binaryWriter2.Close();
            output2.Close();
        }
        // загрузка точек в проект
        public static void PointsInput(
       out int kPntPlus,
       out int kPntInput,
       string[] namePnt,
       double[] xPnt,
       double[] yPnt,
       double[] zPnt,
       int[] nCode1,
       int[] nCode2,
       out int kHeight,
       string[] nameHeig,
       double[] xHeig,
       double[] yHeig,
       double[] zHeig,
       out double xmin,
       out double ymin,
       out double xmax,
       out double ymax,
       out double zmin,
       out double zmax,
       out int iCond)
        {
            char[] seps = new char[3] { ' ', ',', '\t' };
            iCond = 0;
            kPntPlus = -1;
            kPntInput = -1;
            kHeight = -1;
            xmin = 9999999.9;
            ymin = 9999999.9;
            zmin = 9999999.9;
            xmax = -9999999.9;
            ymax = -9999999.9;
            zmax = -9999999.9;
            int kArray = 999999;
            DllClass1.stringArray(namePnt, ref kArray);
            DllClass1.stringArray(nameHeig, ref kArray);
            DllClass1.intArray(nCode1, ref kArray);
            DllClass1.intArray(nCode2, ref kArray);
            DllClass1.doubleArray(xPnt, ref kArray);
            DllClass1.doubleArray(yPnt, ref kArray);
            DllClass1.doubleArray(zPnt, ref kArray);
            DllClass1.doubleArray(xHeig, ref kArray);
            DllClass1.doubleArray(yHeig, ref kArray);
            DllClass1.doubleArray(zHeig, ref kArray);
            int num1 = kArray - 999;
            string text = "Lines Number with error: ";
            OpenFileDialog openFileDialog = new OpenFileDialog();
            openFileDialog.Title = "Input Points File";
            openFileDialog.Filter = "All files (*.*)|*.*";
            string str1 = "";
            openFileDialog.FileName = str1;
            openFileDialog.FilterIndex = 2;
            openFileDialog.RestoreDirectory = true;
            if (openFileDialog.ShowDialog() == DialogResult.OK)
            {
                if (openFileDialog.OpenFile() == null)
                    return;
                Cursor.Current = Cursors.WaitCursor;
                StreamReader streamReader = new StreamReader(openFileDialog.FileName);
                int num2;
                int num3 = num2 = 0;
                int index1 = -1;
                kHeight = -1;
                string str2 = " ";
                int num4 = 0;
                double num5;
                double num6 = num5 = 0.0;
                int k = 0;
                int kPart = 50;
                string sLine;
                while ((sLine = streamReader.ReadLine()) != null)
                {
                    ++num3;
                    string[] sPart;
                    DllClass1.ShareString(sLine, kPart, seps, out k, out sPart);
                    if (k < 2)
                    {
                        ++num4;
                        string str3 = Convert.ToString(num3);
                        text = text + str3 + ",";
                        if (num4 > 10)
                        {
                            iCond = -99;
                            break;
                        }
                    }
                    else
                    {
                        double num7;
                        double num8 = num7 = 0.0;
                        double num9 = num7;
                        double num10 = num7;
                        int num11;
                        int num12 = num11 = 0;
                        int num13 = 0;
                        if (sPart[1].IndexOf('.') > -1)
                        {
                            num13 = 99;
                            try
                            {
                                num10 = Convert.ToDouble(sPart[1]);
                            }
                            catch (FormatException ex)
                            {
                                ++num4;
                                string str4 = Convert.ToString(num3);
                                text = text + str4 + ",";
                                if (num4 > 10)
                                {
                                    iCond = -99;
                                    break;
                                }
                                continue;
                            }
                        }
                        else
                            str2 = sPart[1];
                        if (num13 == 0)
                        {
                            if (sPart[2].IndexOf('.') > -1)
                            {
                                try
                                {
                                    num10 = Convert.ToDouble(sPart[2]);
                                }
                                catch (FormatException ex)
                                {
                                    ++num4;
                                    string str5 = Convert.ToString(num3);
                                    text = text + str5 + ",";
                                    if (num4 > 10)
                                    {
                                        iCond = -99;
                                        break;
                                    }
                                    continue;
                                }
                                if (sPart[3].IndexOf('.') > -1)
                                {
                                    try
                                    {
                                        num9 = Convert.ToDouble(sPart[3]);
                                    }
                                    catch (FormatException ex)
                                    {
                                        ++num4;
                                        string str6 = Convert.ToString(num3);
                                        text = text + str6 + ",";
                                        if (num4 > 10)
                                        {
                                            iCond = -99;
                                            break;
                                        }
                                        continue;
                                    }
                                    if (k > 3)
                                    {
                                        if (sPart[4].IndexOf('.') > -1)
                                        {
                                            try
                                            {
                                                num8 = Convert.ToDouble(sPart[4]);
                                            }
                                            catch (FormatException ex)
                                            {
                                                ++num4;
                                                string str7 = Convert.ToString(num3);
                                                text = text + str7 + ",";
                                                if (num4 > 10)
                                                {
                                                    iCond = -99;
                                                    break;
                                                }
                                                continue;
                                            }
                                        }
                                        else
                                        {
                                            try
                                            {
                                                num12 = Convert.ToInt32(sPart[4]);
                                            }
                                            catch
                                            {
                                                num12 = 0;
                                            }
                                        }
                                    }
                                    if (k > 4)
                                    {
                                        if (sPart[5].IndexOf('.') > -1)
                                        {
                                            ++num4;
                                            string str8 = Convert.ToString(num3);
                                            text = text + str8 + ",";
                                            if (num4 > 10)
                                            {
                                                iCond = -99;
                                                break;
                                            }
                                            continue;
                                        }
                                        try
                                        {
                                            num12 = Convert.ToInt32(sPart[5]);
                                        }
                                        catch (FormatException ex)
                                        {
                                            num12 = 0;
                                        }
                                    }
                                    if (k > 5)
                                    {
                                        if (sPart[6].IndexOf('.') > -1)
                                        {
                                            ++num4;
                                            string str9 = Convert.ToString(num3);
                                            text = text + str9 + ",";
                                            if (num4 > 10)
                                            {
                                                iCond = -99;
                                                break;
                                            }
                                            continue;
                                        }
                                        try
                                        {
                                            num12 = Convert.ToInt32(sPart[5]);
                                        }
                                        catch (FormatException ex)
                                        {
                                            num12 = 0;
                                        }
                                        try
                                        {
                                            num11 = Convert.ToInt32(sPart[6]);
                                        }
                                        catch (FormatException ex)
                                        {
                                            num11 = 0;
                                        }
                                    }
                                }
                                else
                                {
                                    ++num4;
                                    string str10 = Convert.ToString(num3);
                                    text = text + str10 + ",";
                                    if (num4 > 10)
                                    {
                                        iCond = -99;
                                        break;
                                    }
                                    continue;
                                }
                            }
                            else
                            {
                                ++num4;
                                string str11 = Convert.ToString(num3);
                                text = text + str11 + ",";
                                if (num4 > 10)
                                {
                                    iCond = -99;
                                    break;
                                }
                                continue;
                            }
                        }
                        if (num13 > 0)
                        {
                            str2 = Convert.ToString(num3);
                            if (sPart[1].IndexOf('.') > -1)
                            {
                                num10 = Convert.ToDouble(sPart[1]);
                                if (sPart[2].IndexOf('.') > -1)
                                {
                                    num9 = Convert.ToDouble(sPart[2]);
                                    if (k > 2)
                                    {
                                        if (sPart[3].IndexOf('.') > -1)
                                            num8 = Convert.ToDouble(sPart[3]);
                                        else
                                            num12 = Convert.ToInt32(sPart[3]);
                                    }
                                    if (k > 3)
                                    {
                                        if (sPart[4].IndexOf('.') > -1)
                                        {
                                            ++num4;
                                            string str12 = Convert.ToString(num3);
                                            text = text + str12 + ",";
                                            if (num4 > 10)
                                            {
                                                iCond = -99;
                                                break;
                                            }
                                            continue;
                                        }
                                        num12 = Convert.ToInt32(sPart[4]);
                                    }
                                    if (k > 4)
                                    {
                                        if (sPart[5].IndexOf('.') > -1)
                                        {
                                            ++num4;
                                            string str13 = Convert.ToString(num3);
                                            text = text + str13 + ",";
                                            if (num4 > 10)
                                            {
                                                iCond = -99;
                                                break;
                                            }
                                            continue;
                                        }
                                        num12 = Convert.ToInt32(sPart[4]);
                                        num11 = Convert.ToInt32(sPart[5]);
                                    }
                                }
                                else
                                {
                                    ++num4;
                                    string str14 = Convert.ToString(num3);
                                    text = text + str14 + ",";
                                    if (num4 > 10)
                                    {
                                        iCond = -99;
                                        break;
                                    }
                                    continue;
                                }
                            }
                            else
                            {
                                ++num4;
                                string str15 = Convert.ToString(num3);
                                text = text + str15 + ",";
                                if (num4 > 10)
                                {
                                    iCond = -99;
                                    break;
                                }
                                continue;
                            }
                        }
                        ++index1;
                        if (index1 > num1)
                        {
                            int num14 = (int)MessageBox.Show("Index array > 10000");
                            iCond = -1;
                            return;
                        }
                        namePnt[index1] = str2;
                        xPnt[index1] = num10;
                        yPnt[index1] = num9;
                        zPnt[index1] = num8;
                        nCode1[index1] = num12;
                        nCode2[index1] = num11;
                    }
                }
                if (num4 > 0)
                {
                    int num15 = (int)MessageBox.Show(text, "Points File Input", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                    iCond = -1;
                }
                else
                {
                    double num16;
                    double num17 = num16 = 0.0;
                    for (int index2 = 0; index2 < index1; ++index2)
                    {
                        if (xPnt[index2] != 0.0 || yPnt[index2] != 0.0)
                        {
                            for (int index3 = index2 + 1; index3 <= index1; ++index3)
                            {
                                if (xPnt[index3] != 0.0 || yPnt[index3] != 0.0)
                                {
                                    double num18 = xPnt[index3] - xPnt[index2];
                                    double num19 = yPnt[index3] - yPnt[index2];
                                    if (Math.Sqrt(num18 * num18 + num19 * num19) < 0.1)
                                    {
                                        xPnt[index3] = 0.0;
                                        yPnt[index3] = 0.0;
                                    }
                                }
                            }
                        }
                    }
                    int index4 = -1;
                    for (int index5 = 0; index5 <= index1; ++index5)
                    {
                        if (xPnt[index5] != 0.0 || yPnt[index5] != 0.0)
                        {
                            ++index4;
                            namePnt[index4] = namePnt[index5];
                            xPnt[index4] = xPnt[index5];
                            yPnt[index4] = yPnt[index5];
                            zPnt[index4] = zPnt[index5];
                            nCode1[index4] = nCode1[index5];
                            nCode2[index4] = nCode2[index5];
                        }
                    }
                    int num20 = index4;
                    int num21 = 0;
                    for (int index6 = 0; index6 <= num20; ++index6)
                    {
                        if (zPnt[index6] != 0.0)
                            ++num21;
                    }
                    for (int index7 = 0; index7 <= num20; ++index7)
                    {
                        if (xPnt[index7] < xmin)
                            xmin = xPnt[index7];
                        if (yPnt[index7] < ymin)
                            ymin = yPnt[index7];
                        if (num21 > 0 && zPnt[index7] != 0.0 && zPnt[index7] < zmin)
                            zmin = zPnt[index7];
                        if (xPnt[index7] > xmax)
                            xmax = xPnt[index7];
                        if (yPnt[index7] > ymax)
                            ymax = yPnt[index7];
                        if (num21 > 0 && zPnt[index7] != 0.0 && zPnt[index7] > zmax)
                            zmax = zPnt[index7];
                    }
                    if (num21 == 0)
                    {
                        zmin = 0.0;
                        zmax = 0.0;
                    }
                    kPntPlus = num20;
                    kPntInput = num20;
                    kHeight = -1;
                    for (int index8 = 0; index8 <= num20; ++index8)
                    {
                        if (zPnt[index8] != 0.0)
                        {
                            ++kHeight;
                            if (kHeight > num1)
                            {
                                int num22 = (int)MessageBox.Show("Index array > 10000");
                                iCond = -1;
                                break;
                            }
                            nameHeig[kHeight] = namePnt[index8];
                            xHeig[kHeight] = xPnt[index8];
                            yHeig[kHeight] = yPnt[index8];
                            zHeig[kHeight] = zPnt[index8];
                        }
                    }
                }
            }
            else
                iCond = -99;
        }

        public static void SelPntCode(
          int nCode,
          int kSymbPnt,
          int[] nSign1,
          int[] nSign2,
          out int nSymb)
        {
            nSymb = -1;
            int kArray = 999999;
            DllClass1.intArray(nSign1, ref kArray);
            DllClass1.intArray(nSign2, ref kArray);
            if (kSymbPnt > kArray)
            {
                int num = (int)MessageBox.Show("Индекс массива SelPntCode");
            }
            else if (nCode <= 0)
            {
                nSymb = 0;
            }
            else
            {
                for (int index = 0; index <= kSymbPnt; ++index)
                {
                    if (nSign2[index] > 0 && nSign2[index] == nCode)
                    {
                        nSymb = index;
                        return;
                    }
                }
                if (nSymb >= 0)
                    return;
                for (int index = 0; index <= kSymbPnt; ++index)
                {
                    if (nSign1[index] == nCode)
                    {
                        nSymb = index;
                        break;
                    }
                }
            }
        }
        public static void DrawVertical(
          PaintEventArgs e,
          string tText,
          int ix,
          int iy,
          int hText,
          SolidBrush dBrush)
        {
            Graphics graphics = e.Graphics;
            Font font = new Font("Bold", (float)hText);
            graphics.DrawString(tText, font, (Brush)dBrush, (float)ix, (float)iy, new StringFormat()
            {
                FormatFlags = StringFormatFlags.DirectionVertical
            });
            font.Dispose();
        }

        public static void Circle_3Pnt(
          double[] x,
          double[] y,
          out double Rad,
          out double xRad,
          out double yRad,
          out int kWork,
          ref double[] xWork,
          ref double[] yWork)
        {
            double num1;
            double num2 = num1 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            double num5;
            double num6 = num5 = 0.0;
            double num7;
            double num8 = num7 = 0.0;
            int num9;
            int i1 = num9 = 0;
            int i2 = num9;
            int num10 = num9;
            double num11 = 3.1415926;
            Rad = 0.0;
            xRad = 0.0;
            yRad = 0.0;
            kWork = 0;
            int kArray1 = 999999;
            doubleArray(x, ref kArray1);
            doubleArray(y, ref kArray1);
            if (kArray1 < 2)
            {
                int num12 = (int)MessageBox.Show("Индекс массива Circle_3Pnt");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(xWork, ref kArray2);
                doubleArray(yWork, ref kArray2);
                double x1 = x[1] - x[0];
                double y1 = y[1] - y[0];
                if (Math.Sqrt(x1 * x1 + y1 * y1) < 0.001)
                    return;
                double num13 = Math.Atan2(y1, x1);
                if (num13 < 0.0)
                    num13 += 2.0 * num11;
                double num14 = 0.5 * (x[0] + x[1]);
                double num15 = 0.5 * (y[0] + y[1]);
                double num16 = num13 + 0.5 * num11;
                if (num16 >= 2.0 * num11)
                    num16 -= 2.0 * num11;
                double num17 = x[2] - x[0];
                double num18 = y[2] - y[0];
                double num19 = Math.Sqrt(num17 * num17 + num18 * num18);
                double x1_1 = num14 + num19 * Math.Cos(num16);
                double y1_1 = num15 + num19 * Math.Sin(num16);
                double x2 = num14 - num19 * Math.Cos(num16);
                double y2 = num15 - num19 * Math.Sin(num16);
                double x3 = x[2] - x[1];
                double y3 = y[2] - y[1];
                if (Math.Sqrt(x3 * x3 + y3 * y3) < 0.001)
                    return;
                double num20 = Math.Atan2(y3, x3);
                if (num20 < 0.0)
                    num20 += 2.0 * num11;
                double xm = 0.5 * (x[1] + x[2]);
                double ym = 0.5 * (y[1] + y[2]);
                double num21 = num20 + 0.5 * num11;
                if (num21 >= 2.0 * num11)
                    num21 -= 2.0 * num11;
                double x3_1 = xm + num19 * Math.Cos(num21);
                double y3_1 = ym + num19 * Math.Sin(num21);
                double x4 = xm - num19 * Math.Cos(num21);
                double y4 = ym - num19 * Math.Sin(num21);
                int ip = 0;
                TwoLine(x1_1, y1_1, x3_1, y3_1, x2, y2, x4, y4, out xm, out ym, ref ip);
                xRad = xm;
                yRad = ym;
                double x5 = x[0] - xm;
                double y5 = y[0] - ym;
                if (Math.Sqrt(x5 * x5 + y5 * y5) < 0.001)
                    return;
                double num22 = Math.Atan2(y5, x5);
                if (num22 < 0.0)
                    num22 += 2.0 * num11;
                double num23 = Math.Sqrt(x5 * x5 + y5 * y5);
                double num24 = x[1] - xm;
                double num25 = y[1] - ym;
                double num26 = Math.Sqrt(num24 * num24 + num25 * num25);
                double num27 = x[2] - xm;
                double num28 = y[2] - ym;
                double num29 = Math.Sqrt(num27 * num27 + num28 * num28);
                double num30 = (num23 + num26 + num29) / 3.0;
                Rad = num30;
                double num31 = 2.0 * num11 * num30;
                double num32 = 0.195;
                num10 = Convert.ToInt32(num31 / num32 + 1E-06);
                int int32;
                do
                {
                    num32 += 0.005;
                    int32 = Convert.ToInt32(num31 / num32 + 1E-06);
                }
                while (int32 > kArray2);
                if (int32 > kArray2)
                {
                    int num33 = (int)MessageBox.Show("Индекс массива Circle_3Pnt");
                    kWork = 0;
                }
                else
                {
                    double num34 = 2.0 * num11 / (double)int32;
                    xWork[0] = x[0];
                    yWork[0] = y[0];
                    double num35 = num22;
                    for (int i3 = 1; i3 <= int32; ++i3)
                    {
                        num35 += num34;
                        if (num35 >= 2.0 * num11)
                            num35 -= 2.0 * num11;
                        xWork[i3] = xm + num30 * Math.Cos(num35);
                        yWork[i3] = ym + num30 * Math.Sin(num35);
                    }
                    xWork[int32] = x[0];
                    yWork[int32] = y[0];
                    kWork = int32;
                    double num36 = 999999.9;
                    for (int i4 = 0; i4 < int32; ++i4)
                    {
                        double num37 = xWork[i4] - x[1];
                        double num38 = yWork[i4] - y[1];
                        double num39 = Math.Sqrt(num37 * num37 + num38 * num38);
                        if (num39 < num36)
                        {
                            num36 = num39;
                            i2 = i4;
                        }
                    }
                    xWork[i2] = x[1];
                    yWork[i2] = y[1];
                    double num40 = 999999.9;
                    for (int i5 = 0; i5 < int32; ++i5)
                    {
                        double num41 = xWork[i5] - x[2];
                        double num42 = yWork[i5] - y[2];
                        double num43 = Math.Sqrt(num41 * num41 + num42 * num42);
                        if (num43 < num40)
                        {
                            num40 = num43;
                            i1 = i5;
                        }
                    }
                    xWork[i1] = x[2];
                    yWork[i1] = y[2];
                    if (i1 >= i2)
                        return;
                    double num44 = x[2];
                    double num45 = y[2];
                    x[2] = x[1];
                    y[2] = y[1];
                    x[1] = num44;
                    y[1] = num45;
                }
            }
        }

        public static void Arc_3Pnt(
          double[] x,
          double[] y,
          out double Rad,
          out double xRad,
          out double yRad,
          out int kWork,
          ref double[] xWork,
          ref double[] yWork,
          ref int iLong)
        {
            Rad = 0.0;  // Temp value
            xRad = 0.0; // Temp value
            yRad = 0.0; // Temp value
            double num1 = 3.1415926;
            ref double local1 = ref Rad;
            ref double local2 = ref xRad;
            ref double local3 = ref yRad;
            double num2;
            double num3 = num2 = 0.0;
            double num4 = num2;
            local3 = num2;
            double num5;
            double num6 = num5 = num4;
            local2 = num5;
            double num7 = num6;
            local1 = num7;
            kWork = 0;
            int kArray1 = 999999;
            doubleArray(x, ref kArray1);
            doubleArray(y, ref kArray1);
            if (kArray1 < 2)
            {
                int num8 = (int)MessageBox.Show("Индекс массива Arc_3Pnt");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(xWork, ref kArray2);
                doubleArray(yWork, ref kArray2);
                double x1 = x[1] - x[0];
                double y1 = y[1] - y[0];
                if (Math.Sqrt(x1 * x1 + y1 * y1) < 0.001)
                    return;
                double num9 = Math.Atan2(y1, x1);
                if (num9 < 0.0)
                    num9 += 2.0 * num1;
                double num10 = 0.5 * (x[0] + x[1]);
                double num11 = 0.5 * (y[0] + y[1]);
                double num12 = num9 + 0.5 * num1;
                if (num12 >= 2.0 * num1)
                    num12 -= 2.0 * num1;
                double num13 = x[2] - x[0];
                double num14 = y[2] - y[0];
                double num15 = Math.Sqrt(num13 * num13 + num14 * num14);
                double x1_1 = num10 + num15 * Math.Cos(num12);
                double y1_1 = num11 + num15 * Math.Sin(num12);
                double x2_1 = num10 - num15 * Math.Cos(num12);
                double y2_1 = num11 - num15 * Math.Sin(num12);
                double x2 = x[2] - x[1];
                double y2 = y[2] - y[1];
                if (Math.Sqrt(x2 * x2 + y2 * y2) < 0.001)
                    return;
                double num16 = Math.Atan2(y2, x2);
                if (num16 < 0.0)
                    num16 += 2.0 * num1;
                double xm1 = 0.5 * (x[1] + x[2]);
                double ym1 = 0.5 * (y[1] + y[2]);
                double num17 = num16 + 0.5 * num1;
                if (num17 >= 2.0 * num1)
                    num17 -= 2.0 * num1;
                double x3_1 = xm1 + num15 * Math.Cos(num17);
                double y3_1 = ym1 + num15 * Math.Sin(num17);
                double x4_1 = xm1 - num15 * Math.Cos(num17);
                double y4_1 = ym1 - num15 * Math.Sin(num17);
                int ip1 = 0;
                TwoLine(x1_1, y1_1, x3_1, y3_1, x2_1, y2_1, x4_1, y4_1, out xm1, out ym1, ref ip1);
                xRad = xm1;
                yRad = ym1;
                double x3 = x[0] - xm1;
                double y3 = y[0] - ym1;
                if (Math.Sqrt(x3 * x3 + y3 * y3) < 0.001)
                    return;
                double num18 = Math.Atan2(y3, x3);
                if (num18 < 0.0)
                    num18 += 2.0 * num1;
                double xm2 = Math.Sqrt(x3 * x3 + y3 * y3);
                double num19 = x[1] - xm1;
                double num20 = y[1] - ym1;
                double ym2 = Math.Sqrt(num19 * num19 + num20 * num20);
                double num21 = x[2] - xm1;
                double num22 = y[2] - ym1;
                double num23 = Math.Sqrt(num21 * num21 + num22 * num22);
                double num24 = (xm2 + ym2 + num23) / 3.0;
                Rad = num24;
                int i1 = in_out(2, ref x, ref y, xm1, ym1);
                iLong = i1;
                if (i1 > 0)
                    num3 = 2.0 * num1 * num24;
                if (i1 == 0)
                    num3 = num1 * num24;
                double num25 = num1 / 180.0 / 60.0;
                double num26 = 0.195;
                if (num3 < 2.0 * num26)
                    num26 = 0.25 * num3;
                int num27;
                double num28;
                do
                {
                    num26 += 0.005;
                    num27 = (int)(num3 / num26 + 1E-06);
                    num28 = num26 / num24;
                }
                while (num27 > 2000);
                double num29 = num28;
                double num30 = num18 + num28;
                double x1_2 = x[0];
                double y1_2 = y[0];
                double x2_2 = x[1];
                double y2_2 = y[1];
                double x3_2 = xm1;
                double y3_2 = ym1;
                double x4_2 = xm1 + 2.0 * num24 * Math.Cos(num30);
                double y4_2 = ym1 + 2.0 * num24 * Math.Sin(num30);
                int ip2 = 1;
                TwoLine(x1_2, y1_2, x3_2, y3_2, x2_2, y2_2, x4_2, y4_2, out xm2, out ym2, ref ip2);
                if (xm2 == 0.0 && ym2 == 0.0)
                    num29 = -num28;
                double num31 = 0.0;
                int i2 = 0;
                xWork[0] = x[0];
                yWork[0] = y[0];
                do
                {
                    ++num31;
                    double num32 = num18 + num31 * num29;
                    ++i2;
                    if (i2 > kArray2)
                    {
                        int num33 = (int)MessageBox.Show("Индекс массива Arc_3Pnt");
                        kWork = 0;
                        return;
                    }
                    xWork[i2] = xm1 + num24 * Math.Cos(num32);
                    yWork[i2] = ym1 + num24 * Math.Sin(num32);
                    double num34 = x[2] - xWork[i2];
                    double num35 = y[2] - yWork[i2];
                    xm2 = Math.Sqrt(num34 * num34 + num35 * num35);
                }
                while (xm2 > 0.5 * num26);
                xWork[i2] = x[2];
                yWork[i2] = y[2];
                kWork = i2;
                double num36 = 999999.9;
                for (int i3 = 0; i3 < i2; ++i3)
                {
                    double num37 = xWork[i3] - x[1];
                    double num38 = yWork[i3] - y[1];
                    double num39 = Math.Sqrt(num37 * num37 + num38 * num38);
                    if (num39 < num36)
                    {
                        num36 = num39;
                        i1 = i3;
                    }
                }
                xWork[i1] = x[1];
                yWork[i1] = y[1];
            }
        }

        public static void Circle_Rad(
          double Rad,
          double xRad,
          double yRad,
          out int kWork,
          ref double[] xWork,
          ref double[] yWork,
          ref double[] xa,
          ref double[] ya)
        {
            int kWork1 = 0;
            double num1;
            double yRad1 = num1 = 0.0;
            double xRad1 = num1;
            double Rad1 = num1;
            kWork = 0;
            int kArray = 999999;
            doubleArray(xa, ref kArray);
            doubleArray(ya, ref kArray);
            if (kArray < 2)
            {
                int num2 = (int)MessageBox.Show("Индекс массива Circle_rad");
            }
            else
            {
                double num3 = 3.1415926;
                double num4 = 2.0 * num3 / 3.0;
                double num5 = num3 / 4.0;
                xa[0] = xRad + Rad * Math.Cos(num5);
                ya[0] = yRad + Rad * Math.Sin(num5);
                double num6 = num5 + num4;
                xa[1] = xRad + Rad * Math.Cos(num6);
                ya[1] = yRad + Rad * Math.Sin(num6);
                double num7 = num6 + num4;
                xa[2] = xRad + Rad * Math.Cos(num7);
                ya[2] = yRad + Rad * Math.Sin(num7);
                Circle_3Pnt(xa, ya, out Rad1, out xRad1, out yRad1, out kWork1, ref xWork, ref yWork);
                if (kWork1 == 0)
                {
                    int num8 = (int)MessageBox.Show("Индекс массива Circle_rad");
                }
                else
                    kWork = kWork1;
            }
        }

        public static void Arc_2Pnt(
          double xh,
          double yh,
          double xk,
          double yk,
          double Rad,
          ref double xRad,
          ref double yRad,
          out int kWork,
          ref double[] xWork,
          ref double[] yWork,
          ref int iLong,
          ref double[] xa,
          ref double[] ya)
        {
            kWork = 0; // Убрать или заменить значение

            double[] x1 = new double[5];
            double[] y1 = new double[5];
            double num1 = 3.1415926;
            ref int local = ref kWork;
            int num2;
            int num3 = num2 = 0;
            int i1 = num2;
            int iLong1 = num2;
            local = num2;
            double num4;
            double num5 = num4 = 0.0;
            double x2 = xk - xh;
            double y2 = yk - yh;
            double num6 = 0.5 * Math.Sqrt(x2 * x2 + y2 * y2);
            if (Rad <= num6)
            {
                kWork = 0;
                xRad = 0.0;
                yRad = 0.0;
            }
            else
            {
                if (Math.Sqrt(x2 * x2 + y2 * y2) < 0.001)
                    return;
                double num7 = Math.Atan2(y2, x2);
                if (num7 < 0.0)
                    num7 += 2.0 * num1;
                double num8 = 0.5 * (xh + xk);
                double num9 = 0.5 * (yh + yk);
                double num10 = num7 + 0.5 * num1;
                if (num10 >= 2.0 * num1)
                    num10 -= 2.0 * num1;
                double num11 = Math.Sqrt(Rad * Rad - num6 * num6);
                if (iLong == 0)
                {
                    num5 = num8 + num11 * Math.Cos(num10);
                    num4 = num9 + num11 * Math.Sin(num10);
                }
                if (iLong == 1)
                {
                    num5 = num8 - num11 * Math.Cos(num10);
                    num4 = num9 - num11 * Math.Sin(num10);
                }
                xRad = num5;
                yRad = num4;
                x1[1] = num5 - Rad * Math.Cos(num10);
                y1[1] = num4 - Rad * Math.Sin(num10);
                x1[0] = xh;
                y1[0] = yh;
                x1[2] = xk;
                y1[2] = yk;
                int kWork1;
                Arc_3Pnt(x1, y1, out double _, out double _, out double _, out kWork1, ref xWork, ref yWork, ref iLong1);
                if (kWork1 == 0)
                    return;
                int kArray = 999999;
                doubleArray(xWork, ref kArray);
                doubleArray(yWork, ref kArray);
                if (kWork1 > kArray)
                {
                    int num12 = (int)MessageBox.Show("Индекс массива Arc_2Pnt");
                    kWork = 0;
                }
                else
                {
                    kWork = kWork1;
                    double num13 = 999999.9;
                    for (int i2 = 0; i2 < kWork1; ++i2)
                    {
                        double num14 = xWork[i2] - x1[1];
                        double num15 = yWork[i2] - y1[1];
                        double num16 = Math.Sqrt(num14 * num14 + num15 * num15);
                        if (num16 < num13)
                        {
                            num13 = num16;
                            i1 = i2;
                        }
                    }
                    xWork[i1] = x1[1];
                    yWork[i1] = y1[1];
                    xa[0] = xh;
                    ya[0] = yh;
                    xa[1] = x1[1];
                    ya[1] = y1[1];
                    xa[2] = xk;
                    ya[2] = yk;
                }
            }
        }

        public static void PntLine(
          double xx,
          double yy,
          double x1,
          double y1,
          double x2,
          double y2,
          out double xm,
          out double ym)
        {
            double num1;
            double num2 = num1 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            xm = 0.0;
            ym = 0.0;
            double num5 = 3.1415926;
            double num6 = 6.2831852;
            double num7 = x1 - xx;
            double num8 = y1 - yy;
            double xm1 = Math.Sqrt(num7 * num7 + num8 * num8);
            double num9 = x2 - xx;
            double num10 = y2 - yy;
            double ym1 = Math.Sqrt(num9 * num9 + num10 * num10);
            if (xm1 >= ym1)
                num4 = xm1;
            if (ym1 > xm1)
                num4 = ym1;
            double x = x2 - x1;
            double y = y2 - y1;
            if (Math.Abs(x) < 0.001 && Math.Abs(y) < 0.001)
                return;
            double num11 = Math.Atan2(y, x);
            if (num11 < 0.0)
                num11 += num6;
            double num12 = num11 + 0.5 * num5;
            if (num12 >= num6)
                num12 -= num6;
            double x3 = xx - num4 * Math.Cos(num12) - 1.0;
            double y3 = yy - num4 * Math.Sin(num12) - 1.0;
            double x4 = xx + num4 * Math.Cos(num12) + 1.0;
            double y4 = yy + num4 * Math.Sin(num12) + 1.0;
            int ip = 0;
            TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm1, out ym1, ref ip);
            xm = xm1;
            ym = ym1;
        }

        public static void LineStyle(
          PaintEventArgs e,
          Pen jColor,
          int iStyle,
          int iWid,
          int k,
          double[] x,
          double[] y,
          double scaleWin,
          double xBegX,
          double yBegY,
          int xBegWin,
          int yBegWin)
        {
            Graphics graphics = e.Graphics;
            double num1 = 0.0;
            double num2 = 0.0;
            double num3 = 0.0;
            double num4 = 3.1415926;
            int kArray = 999999;
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            if (k > kArray)
            {
                int num5 = (int)MessageBox.Show("Индекс массива LineStyle");
            }
            else
            {
                if (iStyle < 8 || iStyle > 14)
                    return;
                jColor.DashStyle = DashStyle.Solid;
                if (iStyle == 10)
                {
                    num3 = 0.0;
                    num1 = 8.0;
                    num2 = 1.1;
                }
                if (iStyle == 11)
                {
                    num3 = 0.0;
                    num1 = 4.0;
                    num2 = 0.7;
                }
                if (iStyle == 12)
                {
                    num1 = 8.0;
                    num2 = 1.0;
                    num3 = 4.0;
                }
                if (iStyle == 13)
                {
                    num1 = 8.0;
                    num2 = 1.0;
                    num3 = 0.3;
                }
                if (iStyle == 8 || iStyle == 9 || iStyle == 14)
                {
                    num3 = 0.0;
                    num1 = 30.0;
                    num2 = 0.0;
                }
                int num6;
                int yWin1 = num6 = 0;
                int xWin1 = num6;
                int yWin2 = num6;
                int xWin2 = num6;
                double num7;
                double num8 = num7 = 0.0;
                double yCur1;
                double xCur1 = yCur1 = 0.0;
                jColor.Width = (float)iWid;
                for (int i = 1; i <= k; ++i)
                {
                    double x1 = x[i] - x[i - 1];
                    double y1 = y[i] - y[i - 1];
                    double num9 = Math.Sqrt(x1 * x1 + y1 * y1);
                    double num10 = Math.Atan2(y1, x1);
                    if (num10 < 0.0)
                        num10 += 2.0 * num4;
                    if (iStyle == 8 || iStyle == 9)
                    {
                        XYtoWIN(x[i - 1], y[i - 1], scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin2, out yWin2);
                        if (xWin2 != 0 || yWin2 != 0)
                        {
                            XYtoWIN(x[i], y[i], scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin1, out yWin1);
                            if (xWin1 != 0 || yWin1 != 0)
                                graphics.DrawLine(jColor, xWin2, yWin2, xWin1, yWin1);
                        }
                    }
                    else
                    {
                        if (iStyle == 10 || iStyle == 11)
                        {
                            double xCur2 = x[i - 1];
                            double yCur2 = y[i - 1];
                            double num11 = 0.0;
                            if (num9 <= num1)
                            {
                                xCur1 = x[i];
                                yCur1 = y[i];
                                XYtoWIN(xCur2, yCur2, scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin2, out yWin2);
                                if (xWin2 != 0 || yWin2 != 0)
                                {
                                    XYtoWIN(xCur1, yCur1, scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin1, out yWin1);
                                    if (xWin1 != 0 || yWin1 != 0)
                                    {
                                        graphics.DrawLine(jColor, xWin2, yWin2, xWin1, yWin1);
                                        continue;
                                    }
                                    continue;
                                }
                                continue;
                            }
                            do
                            {
                                num11 += num1;
                                if (num11 < num9)
                                {
                                    xCur1 = xCur2 + num1 * Math.Cos(num10);
                                    yCur1 = yCur2 + num1 * Math.Sin(num10);
                                }
                                if (num11 >= num9)
                                {
                                    xCur1 = x[i];
                                    yCur1 = y[i];
                                }
                                XYtoWIN(xCur2, yCur2, scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin2, out yWin2);
                                if (xWin2 != 0 || yWin2 != 0)
                                {
                                    XYtoWIN(xCur1, yCur1, scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin1, out yWin1);
                                    if (xWin1 != 0 || yWin1 != 0)
                                    {
                                        graphics.DrawLine(jColor, xWin2, yWin2, xWin1, yWin1);
                                        xCur2 = xCur1 + num2 * Math.Cos(num10);
                                        yCur2 = yCur1 + num2 * Math.Sin(num10);
                                        num11 += num2;
                                    }
                                }
                            }
                            while (num11 < num9);
                        }
                        if (iStyle == 12 || iStyle == 13)
                        {
                            double xCur3 = x[i - 1];
                            double yCur3 = y[i - 1];
                            double num12 = 0.0;
                            if (num9 <= num1)
                            {
                                xCur1 = x[i];
                                yCur1 = y[i];
                                XYtoWIN(xCur3, yCur3, scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin2, out yWin2);
                                if (xWin2 != 0 || yWin2 != 0)
                                {
                                    XYtoWIN(xCur1, yCur1, scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin1, out yWin1);
                                    if (xWin1 != 0 || yWin1 != 0)
                                    {
                                        graphics.DrawLine(jColor, xWin2, yWin2, xWin1, yWin1);
                                        continue;
                                    }
                                    continue;
                                }
                                continue;
                            }
                            do
                            {
                                num12 += num1;
                                if (num12 < num9)
                                {
                                    xCur1 = xCur3 + num1 * Math.Cos(num10);
                                    yCur1 = yCur3 + num1 * Math.Sin(num10);
                                }
                                if (num12 >= num9)
                                {
                                    xCur1 = x[i];
                                    yCur1 = y[i];
                                }
                                XYtoWIN(xCur3, yCur3, scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin2, out yWin2);
                                if (xWin2 != 0 || yWin2 != 0)
                                {
                                    XYtoWIN(xCur1, yCur1, scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin1, out yWin1);
                                    if (xWin1 != 0 || yWin1 != 0)
                                    {
                                        graphics.DrawLine(jColor, xWin2, yWin2, xWin1, yWin1);
                                        xCur3 = xCur1 + num2 * Math.Cos(num10);
                                        yCur3 = yCur1 + num2 * Math.Sin(num10);
                                        double num13 = num12 + num2;
                                        if (num13 < num9)
                                        {
                                            num12 = num13 + num3;
                                            if (num12 < num9)
                                            {
                                                xCur1 = xCur3 + num3 * Math.Cos(num10);
                                                yCur1 = yCur3 + num3 * Math.Sin(num10);
                                                XYtoWIN(xCur3, yCur3, scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin2, out yWin2);
                                                if (xWin2 != 0 || yWin2 != 0)
                                                {
                                                    XYtoWIN(xCur1, yCur1, scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin1, out yWin1);
                                                    if (xWin1 != 0 || yWin1 != 0)
                                                    {
                                                        graphics.DrawLine(jColor, xWin2, yWin2, xWin1, yWin1);
                                                        xCur3 = xCur1 + num2 * Math.Cos(num10);
                                                        yCur3 = yCur1 + num2 * Math.Sin(num10);
                                                        num12 += num2;
                                                    }
                                                    else
                                                        goto label_53;
                                                }
                                                else
                                                    goto label_53;
                                            }
                                            if (num12 >= num9)
                                            {
                                                xCur1 = x[i];
                                                yCur1 = y[i];
                                                XYtoWIN(xCur3, yCur3, scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin2, out yWin2);
                                                if (xWin2 != 0 || yWin2 != 0)
                                                {
                                                    XYtoWIN(xCur1, yCur1, scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin1, out yWin1);
                                                    if (xWin1 != 0 || yWin1 != 0)
                                                        graphics.DrawLine(jColor, xWin2, yWin2, xWin1, yWin1);
                                                }
                                            }
                                        }
                                        else
                                            break;
                                    }
                                }
                            label_53:;
                            }
                            while (num12 < num9);
                        }
                        if (iStyle == 14)
                        {
                            XYtoWIN(x[i - 1], y[i - 1], scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin2, out yWin2);
                            if (xWin2 != 0 || yWin2 != 0)
                            {
                                XYtoWIN(x[i], y[i], scaleWin, xBegX, yBegY, xBegWin, yBegWin, out xWin1, out yWin1);
                                if (xWin1 != 0 || yWin1 != 0)
                                {
                                    jColor.Width = 2f;
                                    jColor.DashPattern = new float[4]
                                    {
                    1f,
                    2f,
                    1f,
                    2f
                                    };
                                    graphics.DrawLine(jColor, xWin2, yWin2, xWin1, yWin1);
                                }
                            }
                        }
                    }
                }
                jColor.DashStyle = DashStyle.Solid;
            }
        }

        public static void ParallelLine(
          double xSel,
          double ySel,
          double Dist,
          int k1,
          ref double[] x1,
          ref double[] y1,
          out int k2,
          ref double[] x2,
          ref double[] y2)
        {
            int ip;
            int num1 = ip = 0;
            double num2;
            double dist = num2 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            double num5 = num3;
            double num6 = num3;
            double num7;
            double num8 = num7 = 0.0;
            double ym = num7;
            double xm = num7;
            double num9;
            double num10 = num9 = 0.0;
            double yp;
            double xp = yp = 0.0;
            double num11 = 3.1415926;
            double num12 = 2.0 * num11;
            k2 = -1;
            int i1 = -1;
            int num13 = 0;
            Cursor.Current = Cursors.WaitCursor;
            int kArray1 = 999999;
            doubleArray(x1, ref kArray1);
            doubleArray(y1, ref kArray1);
            if (k1 > kArray1)
            {
                int num14 = (int)MessageBox.Show("Индекс массива ParallelLine");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(x2, ref kArray2);
                doubleArray(y2, ref kArray2);
                double num15 = 99999.9;
                for (int i2 = 1; i2 <= k1; ++i2)
                {
                    double x1_1 = x1[i2 - 1];
                    double y1_1 = y1[i2 - 1];
                    double x2_1 = x1[i2];
                    double y2_1 = y1[i2];
                    DistPnt(xSel, ySel, x1_1, y1_1, x2_1, y2_1, out dist, out ip, out xp, out yp);
                    if (ip > 0 && dist > 0.0 && dist < num15)
                    {
                        num15 = dist;
                        double x3 = x2_1 - x1_1;
                        double y3 = y2_1 - y1_1;
                        if (Math.Abs(x3) >= 0.001 || Math.Abs(y3) >= 0.001)
                        {
                            double num16 = Math.Atan2(y3, x3);
                            if (num16 < 0.0)
                                num16 += num12;
                            PntLine(xSel, ySel, x1_1, y1_1, x2_1, y2_1, out xm, out ym);
                            double x4 = xSel - xm;
                            double y4 = ySel - ym;
                            if (Math.Abs(x4) >= 0.001 || Math.Abs(y4) >= 0.001)
                            {
                                num6 = Math.Atan2(y4, x4);
                                if (num6 < 0.0)
                                    num6 += num12;
                                double num17 = num16 + 0.5 * num11;
                                if (num17 >= num12)
                                    num17 -= num12;
                                if (num6 >= num17)
                                    num5 = num6 - num17;
                                if (num17 > num6)
                                    num5 = num17 - num6;
                            }
                        }
                    }
                }
                if (num5 > 0.5 * num11)
                    num13 = 1;
                for (int i3 = 1; i3 <= k1; ++i3)
                {
                    double num18 = x1[i3 - 1];
                    double num19 = y1[i3 - 1];
                    double num20 = x1[i3];
                    double num21 = y1[i3];
                    double x5 = num20 - num18;
                    double y5 = num21 - num19;
                    if (Math.Abs(x5) >= 0.001 || Math.Abs(y5) >= 0.001)
                    {
                        double num22 = Math.Atan2(y5, x5);
                        if (num22 < 0.0)
                            num22 += num12;
                        if (num13 == 0)
                        {
                            num6 = num22 + 0.5 * num11;
                            if (num6 >= num12)
                                num6 -= num12;
                        }
                        if (num13 > 0)
                        {
                            num6 = num22 - 0.5 * num11;
                            if (num6 < 0.0)
                                num6 += num12;
                        }
                        if (i3 == 1)
                        {
                            ++i1;
                            if (i1 > kArray2)
                            {
                                int num23 = (int)MessageBox.Show("Индекс массива ParallelLine");
                                k2 = 0;
                                return;
                            }
                            x2[i1] = x1[i3 - 1] + Dist * Math.Cos(num6);
                            y2[i1] = y1[i3 - 1] + Dist * Math.Sin(num6);
                        }
                        if (i3 == k1)
                        {
                            ++i1;
                            if (i1 > kArray2)
                            {
                                int num24 = (int)MessageBox.Show("Индекс массива ParallelLine");
                                k2 = 0;
                                return;
                            }
                            x2[i1] = x1[i3] + Dist * Math.Cos(num6);
                            y2[i1] = y1[i3] + Dist * Math.Sin(num6);
                        }
                        if (i3 < k1)
                        {
                            double x6 = x1[i3 + 1] - x1[i3];
                            double y6 = y1[i3 + 1] - y1[i3];
                            if (Math.Abs(x6) >= 0.001 || Math.Abs(y6) >= 0.001)
                            {
                                double num25 = Math.Atan2(y6, x6);
                                if (num25 < 0.0)
                                    num25 += num12;
                                if (num13 == 0)
                                {
                                    num5 = num25 + 0.5 * num11;
                                    if (num5 >= num12)
                                        num5 -= num12;
                                }
                                if (num13 > 0)
                                {
                                    num5 = num25 - 0.5 * num11;
                                    if (num5 < 0.0)
                                        num5 += num12;
                                }
                                double num26 = x1[i3] + Dist * Math.Cos(num6);
                                double num27 = y1[i3] + Dist * Math.Sin(num6);
                                double num28 = x1[i3] + Dist * Math.Cos(num5);
                                double num29 = y1[i3] + Dist * Math.Sin(num5);
                                double num30 = num28 - num26;
                                double num31 = num29 - num27;
                                if (Math.Sqrt(num30 * num30 + num31 * num31) < 0.001)
                                {
                                    ++i1;
                                    if (i1 > kArray2)
                                    {
                                        int num32 = (int)MessageBox.Show("Индекс массива ParallelLine");
                                        k2 = 0;
                                        return;
                                    }
                                    x2[i1] = x1[i3] + Dist * Math.Cos(num6);
                                    y2[i1] = y1[i3] + Dist * Math.Sin(num6);
                                }
                                else
                                {
                                    double num33 = 0.5 * (num26 + num28);
                                    double num34 = 0.5 * (num27 + num29);
                                    double x7 = num33 - x1[i3];
                                    double y7 = num34 - y1[i3];
                                    if (Math.Abs(x7) >= 0.001 || Math.Abs(y7) >= 0.001)
                                    {
                                        double num35 = Math.Sqrt(x7 * x7 + y7 * y7);
                                        double num36 = Math.Atan2(y7, x7);
                                        if (num36 < 0.0)
                                            num36 += num12;
                                        double num37 = Dist * Dist / num35;
                                        ++i1;
                                        if (i1 > kArray2)
                                        {
                                            int num38 = (int)MessageBox.Show("Индекс массива ParallelLine");
                                            k2 = 0;
                                            return;
                                        }
                                        x2[i1] = x1[i3] + num37 * Math.Cos(num36);
                                        y2[i1] = y1[i3] + num37 * Math.Sin(num36);
                                    }
                                }
                            }
                        }
                    }
                }
                k2 = i1;
                double num39 = x1[k1] - x1[0];
                double num40 = y1[k1] - y1[0];
                if (Math.Sqrt(num39 * num39 + num40 * num40) >= 0.1)
                    return;
                double x1_2 = x2[0];
                double y1_2 = y2[0];
                double x2_2 = x2[1];
                double y2_2 = y2[1];
                double x3_1 = x2[i1];
                double y3_1 = y2[i1];
                double x4_1 = x2[i1 - 1];
                double y4_1 = y2[i1 - 1];
                ip = 0;
                TwoLine(x1_2, y1_2, x3_1, y3_1, x2_2, y2_2, x4_1, y4_1, out xm, out ym, ref ip);
                x2[0] = xm;
                y2[0] = ym;
                x2[i1] = xm;
                y2[i1] = ym;
            }
        }

        public static void ParallelArcCircle(
          int k1,
          ref double[] x1,
          ref double[] y1,
          ref double rd1,
          ref double xrd1,
          ref double yrd1,
          out int k2,
          ref double[] x2,
          ref double[] y2,
          out double rd2,
          out double xrd2,
          out double yrd2,
          ref double[] xd,
          ref double[] yd)
        {
            double num1 = 3.1415926;
            k2 = 0;
            rd2 = xrd2 = yrd2 = 0.0;
            int num2;
            int num3 = num2 = 0;
            double num4;
            double num5 = num4 = 0.0;
            double num6;
            double num7 = num6 = 0.0;
            double ym;
            double xm = ym = 0.0;
            int kArray1 = 999999;
            doubleArray(x1, ref kArray1);
            doubleArray(y1, ref kArray1);
            if (k1 > kArray1)
            {
                int num8 = (int)MessageBox.Show("Индекс массива ParallelArcCircle");
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(x2, ref kArray2);
                doubleArray(y2, ref kArray2);
                doubleArray(xd, ref kArray2);
                doubleArray(yd, ref kArray2);
                double num9 = x1[0] - x1[k1];
                double num10 = y1[0] - y1[k1];
                if (Math.Sqrt(num9 * num9 + num10 * num10) < 0.1)
                    num3 = 1;
                num2 = in_out(k1, ref x1, ref y1, xrd1, yrd1);
                rd2 = rd1;
                xrd2 = xrd1;
                yrd2 = yrd1;
                if (num3 > 0)
                {
                    Circle_Rad(rd2, xrd2, yrd2, out k2, ref x2, ref y2, ref xd, ref yd);
                }
                else
                {
                    Cursor.Current = Cursors.WaitCursor;
                    double x3 = x1[0] - xrd1;
                    double y3 = y1[0] - yrd1;
                    double num11 = Math.Atan2(y3, x3);
                    num5 = Math.Sqrt(x3 * x3 + y3 * y3);
                    if (num11 < 0.0)
                        num11 += 2.0 * num1;
                    double num12 = xrd2 + rd2 * Math.Cos(num11);
                    double num13 = yrd2 + rd2 * Math.Sin(num11);
                    double x4 = x1[k1] - xrd1;
                    double y4 = y1[k1] - yrd1;
                    double num14 = Math.Atan2(y4, x4);
                    num5 = Math.Sqrt(x4 * x4 + y4 * y4);
                    if (num14 < 0.0)
                        num14 += 2.0 * num1;
                    double num15 = xrd2 + rd2 * Math.Cos(num14);
                    double num16 = yrd2 + rd2 * Math.Sin(num14);
                    int iLong = in_out(k1, ref x1, ref y1, xrd2, yrd2);
                    double num17 = num14 - num1 / 180.0;
                    if (num17 < 0.0)
                        num17 += 2.0 * num1;
                    double x3_1 = xrd2 + 2.0 * rd2 * Math.Cos(num17);
                    double y3_1 = yrd2 + 2.0 * rd2 * Math.Sin(num17);
                    int ip = 1;
                    TwoLine(num12, num13, x3_1, y3_1, num15, num16, xrd2, yrd2, out xm, out ym, ref ip);
                    if (xm == 0.0 && ym == 0.0)
                    {
                        double num18 = num12;
                        double num19 = num13;
                        num12 = num15;
                        num13 = num16;
                        num15 = num18;
                        num16 = num19;
                    }
                    Arc_2Pnt(num12, num13, num15, num16, rd2, ref xrd2, ref yrd2, out k2, ref x2, ref y2, ref iLong, ref xd, ref yd);
                    if (k2 < 2)
                    {
                        int num20 = (int)MessageBox.Show("Индекс массива ParallelArcCircle");
                    }
                    else
                    {
                        if (iLong <= 0 || in_out(k2, ref x2, ref y2, xrd1, yrd1) != 0)
                            return;
                        Arc_2Pnt(num15, num16, num12, num13, rd2, ref xrd2, ref yrd2, out k2, ref x2, ref y2, ref iLong, ref xd, ref yd);
                        if (k2 >= 2)
                            return;
                        int num21 = (int)MessageBox.Show("Индекс массива ParallelArcCircle");
                    }
                }
            }
        }

        public static void ContourText(
          PaintEventArgs e,
          string tText,
          int x,
          int y,
          int hText,
          int angle,
          SolidBrush iColor,
          int iParam,
          int iFont)
        {
            double num1 = 3.1415926;
            Graphics graphics = e.Graphics;
            graphics.TextRenderingHint = TextRenderingHint.AntiAliasGridFit;
            Font font1 = new Font("Verdana", (float)hText, FontStyle.Bold);
            Font font2 = new Font("Arial", (float)hText, FontStyle.Regular);
            Point point = new Point(x, y);
            double num2 = (double)angle * num1 / 180.0;
            int x1 = x - Convert.ToInt32(0.5 * (double)tText.Length * (double)hText * Math.Cos(num2));
            int y1 = y - Convert.ToInt32(0.5 * (double)tText.Length * (double)hText * Math.Sin(num2));
            int x2 = x + Convert.ToInt32(0.5 * (double)tText.Length * (double)hText * Math.Cos(num2));
            int y2 = y + Convert.ToInt32(0.5 * (double)tText.Length * (double)hText * Math.Sin(num2));
            Point pt1 = new Point(x1, y1);
            Point pt2 = new Point(x2, y2);
            graphics.DrawLine(new Pen(Brushes.White)
            {
                Width = (float)(hText / 2)
            }, pt1, pt2);
            graphics.TranslateTransform((float)point.X, (float)point.Y);
            graphics.RotateTransform((float)angle);
            if (iParam < 2)
            {
                StringFormat format = new StringFormat(StringFormatFlags.NoClip);
                if (iParam == 0)
                    format.Alignment = StringAlignment.Near;
                if (iParam == 1)
                    format.Alignment = StringAlignment.Center;
                format.LineAlignment = StringAlignment.Center;
                if (iFont == 1)
                    graphics.DrawString(tText, font1, (Brush)iColor, 0.0f, 0.0f, format);
                if (iFont == 2)
                    graphics.DrawString(tText, font2, (Brush)iColor, 0.0f, 0.0f, format);
            }
            graphics.RotateTransform((float)-angle);
            graphics.TranslateTransform((float)-point.X, (float)-point.Y);
        }

        public static int RadGrad(double rdn)
        {
            int num1 = 0;
            if (double.IsNaN(rdn))
            {
                int num2 = (int)MessageBox.Show("Проблема данных RadGrad");
                return num1;
            }
            double num3 = 3.1415926;
            int num4 = 1;
            if (rdn < 0.0)
                num4 = -1;
            double num5 = Math.Abs(rdn) * 10800.0 / num3;
            int int32 = Convert.ToInt32(num5);
            if (num5 - (double)int32 * 1.0 > 0.5)
                ++int32;
            return num4 * int32 / 60;
        }

        public static void RotText(
          PaintEventArgs e,
          string tText,
          int x,
          int y,
          int hText,
          int angle,
          SolidBrush iColor,
          int iParam)
        {
            double num1 = 3.1415926;
            Graphics graphics = e.Graphics;
            graphics.TextRenderingHint = TextRenderingHint.AntiAliasGridFit;
            Font font = new Font("Arial", (float)hText, FontStyle.Regular);
            Point point = new Point(x, y);
            if (angle > 90 && angle < 180)
                angle += 180;
            if (angle >= 180 && angle < 270)
                angle -= 180;
            double num2 = (double)angle * num1 / 180.0;
            int x1 = x - Convert.ToInt32(0.5 * (double)tText.Length * (double)hText * Math.Cos(num2));
            int y1 = y - Convert.ToInt32(0.5 * (double)tText.Length * (double)hText * Math.Sin(num2));
            int x2 = x + Convert.ToInt32(0.5 * (double)tText.Length * (double)hText * Math.Cos(num2));
            int y2 = y + Convert.ToInt32(0.5 * (double)tText.Length * (double)hText * Math.Sin(num2));
            Point pt1 = new Point(x1, y1);
            Point pt2 = new Point(x2, y2);
            graphics.DrawLine(new Pen(Brushes.White)
            {
                Width = (float)(hText / 2)
            }, pt1, pt2);
            graphics.TranslateTransform((float)point.X, (float)point.Y);
            graphics.RotateTransform((float)angle);
            if (iParam < 2)
            {
                StringFormat format = new StringFormat(StringFormatFlags.NoClip);
                if (iParam == 0)
                    format.Alignment = StringAlignment.Near;
                if (iParam == 1)
                    format.Alignment = StringAlignment.Center;
                format.LineAlignment = StringAlignment.Center;
                graphics.DrawString(tText, font, (Brush)iColor, 0.0f, 0.0f, format);
            }
            graphics.RotateTransform((float)-angle);
            graphics.TranslateTransform((float)-point.X, (float)-point.Y);
        }

        public static void ContourDraw(
          PaintEventArgs e,
          string fCurContour,
          double[] xDop,
          double[] yDop,
          double[] xOut,
          double[] yOut,
          double scaleWin,
          double xBeg,
          double yBeg,
          int xWin,
          int yWin)
        {
            Graphics graphics = e.Graphics;
            double num1;
            double num2 = num1 = 0.0;
            int num3;
            int yWin1 = num3 = 0;
            int xWin1 = num3;
            int yWin2 = num3;
            int xWin2 = num3;
            if (!File.Exists(fCurContour))
                return;
            Cursor.Current = Cursors.WaitCursor;
            Pen pen = new Pen(Color.Gray);
            FileStream input = new FileStream(fCurContour, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            try
            {
                binaryReader.ReadDouble();
                int num4 = binaryReader.ReadInt32();
                for (int i1 = 1; i1 <= num4; ++i1)
                {
                    int num5 = binaryReader.ReadInt32();
                    for (int i2 = 0; i2 <= num5; ++i2)
                    {
                        xDop[i2] = binaryReader.ReadDouble();
                        yDop[i2] = binaryReader.ReadDouble();
                    }
                    double num6 = binaryReader.ReadDouble();
                    double rdn = binaryReader.ReadDouble();
                    double xCur = binaryReader.ReadDouble();
                    double yCur = binaryReader.ReadDouble();
                    binaryReader.ReadInt32();
                    binaryReader.ReadInt32();
                    int num7 = binaryReader.ReadInt32();
                    for (int i3 = 0; i3 <= num7; ++i3)
                    {
                        xOut[i3] = binaryReader.ReadDouble();
                        yOut[i3] = binaryReader.ReadDouble();
                    }
                    for (int i4 = 1; i4 <= num7; ++i4)
                    {
                        XYtoWIN(xOut[i4 - 1], yOut[i4 - 1], scaleWin, xBeg, yBeg, xWin, yWin, out xWin2, out yWin2);
                        if (xWin2 != 0 || yWin2 != 0)
                        {
                            XYtoWIN(xOut[i4], yOut[i4], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                            if (xWin1 != 0 || yWin1 != 0)
                                graphics.DrawLine(pen, xWin2, yWin2, xWin1, yWin1);
                        }
                    }
                    if (xCur != 0.0 && yCur != 0.0)
                    {
                        SolidBrush iColor = new SolidBrush(Color.Sienna);
                        XYtoWIN(xCur, yCur, scaleWin, xBeg, yBeg, xWin, yWin, out xWin2, out yWin2);
                        if (xWin2 != 0 || yWin2 != 0)
                        {
                            int angle = 360 - RadGrad(rdn);
                            string tText = string.Format("{0}", (object)Convert.ToInt32(num6));
                            ContourText(e, tText, xWin2, yWin2, 7, angle, iColor, 1, 2);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            finally
            {
                binaryReader.Close();
                input.Close();
            }
        }

        public static void LabelDraw(
          PaintEventArgs e,
          int kPol,
          string[] namePol,
          double[] xLab,
          double[] yLab,
          int[] iHorVer,
          double scaleWin,
          double xBeg,
          double yBeg,
          int xWin,
          int yWin,
          SolidBrush[] brColor,
          int iParam)
        {
            Graphics graphics = e.Graphics;
            int num1 = 4;
            int num2 = 7;
            int xWin1 = 0;
            int yWin1 = 0;
            SolidBrush iColor = brColor[iParam];
            int kArray = 999999;
            stringArray(namePol, ref kArray);
            intArray(iHorVer, ref kArray);
            doubleArray(xLab, ref kArray);
            doubleArray(yLab, ref kArray);
            if (kPol > kArray)
            {
                int num3 = (int)MessageBox.Show("Индекс массива LabelDraw");
            }
            else
            {
                for (int i = 1; i <= kPol; ++i)
                {
                    XYtoWIN(xLab[i], yLab[i], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                    if (xWin1 != 0 || yWin1 != 0)
                    {
                        if (iHorVer[i] == 0)
                            graphics.DrawString(namePol[i], new Font("Bold", (float)num2), (Brush)iColor, (float)(xWin1 + num2 / 2), (float)(yWin1 - num2));
                        if (iHorVer[i] > 0)
                            RotText(e, namePol[i], xWin1, yWin1 - num2 / 2, num2, 270, iColor, 0);
                        if (iParam != 3)
                            graphics.FillRectangle((Brush)iColor, xWin1 - num1 / 2, yWin1 - num1 / 2, num1, num1);
                        if (iParam == 3)
                        {
                            Point[] points1 = new Point[2];
                            points1[0].X = xWin1 - 3;
                            points1[0].Y = yWin1 - 3;
                            points1[1].X = xWin1 + 3;
                            points1[1].Y = yWin1 + 3;
                            graphics.DrawLines(new Pen(Color.DarkGreen, 2f), points1);
                            Point[] points2 = new Point[2];
                            points2[0].X = xWin1 + 3;
                            points2[0].Y = yWin1 - 3;
                            points2[1].X = xWin1 - 3;
                            points2[1].Y = yWin1 + 3;
                            graphics.DrawLines(new Pen(Color.DarkGreen, 2f), points2);
                        }
                    }
                }
            }
        }

        public static void AddInscrDraw(
          PaintEventArgs e,
          int kAddInscr,
          string[] txtInscr,
          double[] xInscr,
          double[] yInscr,
          int[] nHorVer,
          int[] nInsCol,
          SolidBrush[] brBrush,
          double scaleWin,
          double xBeg,
          double yBeg,
          int xWin,
          int yWin)
        {
            Graphics graphics = e.Graphics;
            int num1 = 9;
            int kArray = 999999;
            stringArray(txtInscr, ref kArray);
            doubleArray(xInscr, ref kArray);
            doubleArray(yInscr, ref kArray);
            intArray(nHorVer, ref kArray);
            intArray(nInsCol, ref kArray);
            if (kAddInscr > kArray)
            {
                int num2 = (int)MessageBox.Show("Индекс массива AddInscrDraw");
            }
            else
            {
                for (int i1 = 1; i1 <= kAddInscr; ++i1)
                {
                    int i2 = nInsCol[i1];
                    SolidBrush dBrush = brBrush[i2];
                    string str = txtInscr[i1];
                    int num3 = 6 * str.Length / 2;
                    int num4 = nHorVer[i1];
                    int xWin1;
                    int yWin1;
                    XYtoWIN(xInscr[i1], yInscr[i1], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                    if (xWin1 != 0 || yWin1 != 0)
                    {
                        if (num4 == 0)
                            graphics.DrawString(str, new Font("Bold", (float)num1), (Brush)dBrush, (float)(xWin1 - num3), (float)(yWin1 - num1));
                        if (num4 > 0)
                            DrawVertical(e, str, xWin1 - num1 / 2, yWin1 - num3, num1, dBrush);
                    }
                }
            }
        }

        public static void SelSymbPnt(
          string fsymbPnt,
          int nCodePnt,
          int kSymbPnt,
          int[] numRec,
          int[] numUser,
          out int iLong,
          out int iWid,
          out int iHei,
          out string sDscr,
          out int kPix,
          int[] ixSqu,
          int[] iySqu,
          int[] nColor,
          out string sTxt,
          out int mClr)
        {
            sDscr = "";
            int num1 = 0;
            iLong = 0;
            iWid = 0;
            iHei = 0;
            kPix = 0;
            mClr = 0;
            sTxt = "";
            if (nCodePnt == 0)
                return;
            if (kSymbPnt > 0)
            {
                for (int i = 1; i <= kSymbPnt; ++i)
                {
                    if (numUser[i] == nCodePnt)
                    {
                        num1 = i;
                        break;
                    }
                }
            }
            if (num1 == 0 || !File.Exists(fsymbPnt))
                return;
            FileStream input = new FileStream(fsymbPnt, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            try
            {
                for (int i1 = 1; i1 <= kSymbPnt; ++i1)
                {
                    int int32 = Convert.ToInt32(binaryReader.ReadString());
                    iLong = binaryReader.ReadInt32();
                    if (iLong == 0)
                    {
                        binaryReader.ReadInt32();
                        sDscr = binaryReader.ReadString();
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        iWid = binaryReader.ReadInt32();
                        iHei = binaryReader.ReadInt32();
                        int num2 = binaryReader.ReadInt32();
                        if (num2 > 0)
                        {
                            for (int i2 = 1; i2 <= num2; ++i2)
                            {
                                binaryReader.ReadDouble();
                                binaryReader.ReadDouble();
                                binaryReader.ReadInt32();
                            }
                        }
                        kPix = binaryReader.ReadInt32();
                        if (kPix > 0)
                        {
                            for (int i3 = 1; i3 <= kPix; ++i3)
                            {
                                ixSqu[i3] = binaryReader.ReadInt32();
                                iySqu[i3] = binaryReader.ReadInt32();
                                nColor[i3] = binaryReader.ReadInt32();
                            }
                        }
                    }
                    if (iLong > 0)
                    {
                        binaryReader.ReadInt32();
                        mClr = binaryReader.ReadInt32();
                        sTxt = binaryReader.ReadString();
                        binaryReader.ReadInt32();
                        sDscr = binaryReader.ReadString();
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        iWid = binaryReader.ReadInt32();
                        iHei = binaryReader.ReadInt32();
                    }
                    if (num1 == int32)
                        break;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            binaryReader.Close();
            input.Close();
        }

        public static void PointsDraw(
     PaintEventArgs e,
     string fsymbPnt,
     int iParam,
     int kPnt,
     string[] namePnt,
     double[] xPnt,
     double[] yPnt,
     double[] zPnt,
     double[] xPntInscr,
     double[] yPntInscr,
     int[] iHorVerPnt,
     double scaleWin,
     double xBeg,
     double yBeg,
     int xWin,
     int yWin,
     int[] nCode1,
     int[] nCode2,
     int kSymbPnt,
     int[] numRec,
     int[] numbUser,
     int[] ixSqu,
     int[] iySqu,
     int[] nColor,
     SolidBrush[] brCol,
     Pen[] pnCol)
        {
            Graphics graphics = e.Graphics;
            string sDscr = "";
            int xWin1 = 0;
            int yWin1 = 0;
            int num1 = 8;
            string sTxt = "";
            int num2;
            int iLong = num2 = 0;
            int iHei = num2;
            int iWid = num2;
            if (kPnt <= 0)
                return;
            SolidBrush iColor = new SolidBrush(Color.Black);
            SolidBrush solidBrush = new SolidBrush(Color.Black);
            new Pen(Color.Black).Width = 1f;
            switch (iParam)
            {
                case -2:
                    break;
                case -1:
                    for (int index = 0; index <= kPnt; ++index)
                    {
                        DllClass1.XYtoWIN(xPnt[index], yPnt[index], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                        if (xWin1 != 0 || yWin1 != 0)
                        {
                            graphics.FillRectangle((Brush)iColor, xWin1 - 1, yWin1 - 1, 2, 2);
                            int nCodePnt = 0;
                            if (nCode1[index] > 0)
                                nCodePnt = nCode1[index];
                            if (nCodePnt > 0)
                            {
                                int kPix;
                                int mClr;
                                DllClass1.SelSymbPnt(fsymbPnt, nCodePnt, kSymbPnt, numRec, numbUser, out iLong, out iWid, out iHei, out sDscr, out kPix, ixSqu, iySqu, nColor, out sTxt, out mClr);
                                int ixh = xWin1 - iWid / 2;
                                int iyh = yWin1 - iHei / 2;
                                if (iLong == 0)
                                    DllClass1.SignDraw(e, ixh, iyh, kPix, ixSqu, iySqu, nColor, brCol);
                                if (iLong > 0)
                                    DllClass1.DrawText(e, sTxt, iHei, ixh, iyh, mClr, brCol);
                            }
                        }
                    }
                    break;
                default:
                    for (int index = 0; index <= kPnt; ++index)
                    {
                        DllClass1.XYtoWIN(xPnt[index], yPnt[index], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                        if (xWin1 != 0 || yWin1 != 0)
                        {
                            graphics.FillRectangle((Brush)iColor, xWin1 - 2, yWin1 - 2, 3, 3);
                            int nCodePnt = 0;
                            if (nCode1[index] > 0)
                                nCodePnt = nCode1[index];
                            if (nCodePnt > 0)
                            {
                                int kPix;
                                int mClr;
                                DllClass1.SelSymbPnt(fsymbPnt, nCodePnt, kSymbPnt, numRec, numbUser, out iLong, out iWid, out iHei, out sDscr, out kPix, ixSqu, iySqu, nColor, out sTxt, out mClr);
                                int ixh = xWin1 - iWid / 2;
                                int iyh = yWin1 - iHei / 2;
                                if (iLong == 0)
                                    DllClass1.SignDraw(e, ixh, iyh, kPix, ixSqu, iySqu, nColor, brCol);
                                if (iLong > 0)
                                    DllClass1.DrawText(e, sTxt, iHei, ixh, iyh, mClr, brCol);
                            }
                            if (iParam == 0)
                            {
                                DllClass1.XYtoWIN(xPntInscr[index], yPntInscr[index], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                                if (xWin1 != 0 || yWin1 != 0)
                                {
                                    if (nCodePnt > 0)
                                    {
                                        if (iHorVerPnt[index] == 0 && iLong == 0)
                                            graphics.DrawString(namePnt[index], new Font("Bold", (float)num1), (Brush)iColor, (float)(xWin1 + iWid / 2), (float)(yWin1 - iHei / 2));
                                        if (iHorVerPnt[index] > 0 || iLong > 0)
                                            DllClass1.RotText(e, namePnt[index], xWin1, yWin1 - 3, num1, 270, iColor, 0);
                                    }
                                    if (nCodePnt == 0)
                                    {
                                        if (iHorVerPnt[index] == 0)
                                            graphics.DrawString(namePnt[index], new Font("Bold", (float)num1), (Brush)iColor, (float)(xWin1 + num1 / 2), (float)(yWin1 - num1 + 2));
                                        if (iHorVerPnt[index] > 0)
                                            DllClass1.RotText(e, namePnt[index], xWin1, yWin1 - num1 / 2, num1, 270, iColor, 0);
                                    }
                                }
                                else
                                    continue;
                            }
                            if (iParam > 0)
                            {
                                DllClass1.XYtoWIN(xPntInscr[index], yPntInscr[index], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                                if (xWin1 != 0 || yWin1 != 0)
                                {
                                    string str = string.Format("{0:F2}", (object)zPnt[index]);
                                    if (nCodePnt > 0 && zPnt[index] != 0.0)
                                    {
                                        if (iHorVerPnt[index] == 0 && iLong == 0)
                                            graphics.DrawString(str, new Font("Bold", (float)num1), (Brush)iColor, (float)(xWin1 + iWid / 2), (float)(yWin1 - num1 + 2));
                                        if (iHorVerPnt[index] > 0 || iLong > 0)
                                            DllClass1.RotText(e, str, xWin1, yWin1 - 3, num1, 270, iColor, 0);
                                    }
                                    if (nCodePnt == 0 && zPnt[index] != 0.0)
                                    {
                                        if (iHorVerPnt[index] == 0)
                                            graphics.DrawString(str, new Font("Bold", (float)num1), (Brush)iColor, (float)(xWin1 + num1 / 2), (float)(yWin1 - num1 + 2));
                                        if (iHorVerPnt[index] > 0)
                                            DllClass1.RotText(e, str, xWin1, yWin1 - num1 / 2, num1, 270, iColor, 0);
                                    }
                                }
                            }
                        }
                    }
                    break;
            }
        }

        public static void DrawSelLine(
          PaintEventArgs e,
          int kSel,
          ref double[] xLin,
          ref double[] yLin,
          double scaleWin,
          double xBeg,
          double yBeg,
          int xWin,
          int yWin)
        {
            Graphics graphics = e.Graphics;
            int yWin1;
            int xWin1 = yWin1 = 0;
            if (kSel < 1)
                return;
            int kArray = 999999;
            DllClass1.doubleArray(xLin, ref kArray);
            doubleArray(yLin, ref kArray);
            if (kSel > kArray)
            {
                int num = (int)MessageBox.Show("Индекс массива DrawSelLine");
            }
            else
            {
                Point[] points = new Point[kSel + 1];
                for (int i = 0; i <= kSel; ++i)
                {
                    XYtoWIN(xLin[i], yLin[i], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                    if (xWin1 != 0 || yWin1 != 0)
                    {
                        points[i].X = xWin1;
                        points[i].Y = yWin1;
                    }
                }
                graphics.DrawLines(new Pen(Color.Chocolate, 1f), points);
            }
        }

        public static void CoordItems(
          int kPnt,
          double[] xPnt,
          double[] yPnt,
          int iStyle,
          int iWid,
          double rad,
          int nit,
          int k,
          double[] x,
          double[] y,
          out int kit,
          ref double[] xit,
          ref double[] yit,
          ref double[] az,
          int[] ind)
        {
            double num1 = 0.0;
            double num2 = 0.0;
            double num3 = 0.0;
            double num4 = 3.1415926;
            kit = 0;
            if (nit == 0)
                return;
            int kArray = 999999;
            doubleArray(xPnt, ref kArray);
            doubleArray(yPnt, ref kArray);
            if (kPnt > kArray)
            {
                int num5 = (int)MessageBox.Show("Индекс массива CoordItems");
            }
            else
            {
                kArray = 999999;
                doubleArray(x, ref kArray);
                doubleArray(y, ref kArray);
                if (k > kArray)
                {
                    int num6 = (int)MessageBox.Show("Индекс массива CoordItems");
                }
                else
                {
                    kArray = 999999;
                    doubleArray(xit, ref kArray);
                    doubleArray(yit, ref kArray);
                    doubleArray(az, ref kArray);
                    intArray(ind, ref kArray);
                    if (iStyle < 8 || iStyle > 14)
                        return;
                    if (iStyle == 10)
                    {
                        num3 = 0.0;
                        num1 = 8.0;
                        num2 = 1.1;
                    }
                    if (iStyle == 11)
                    {
                        num3 = 0.0;
                        num1 = 4.0;
                        num2 = 0.7;
                    }
                    if (iStyle == 12)
                    {
                        num1 = 8.0;
                        num2 = 1.0;
                        num3 = 4.0;
                    }
                    if (iStyle == 13)
                    {
                        num1 = 8.0;
                        num2 = 1.0;
                        num3 = 0.3;
                    }
                    if (iStyle == 8 || iStyle == 9 || iStyle == 14)
                    {
                        num3 = 0.0;
                        num1 = 8.0;
                        num2 = 0.0;
                    }
                    double num7;
                    double num8 = num7 = 0.0;
                    double yp = num7;
                    double xp = num7;
                    double num9;
                    double num10 = num9 = 0.0;
                    double num11;
                    double num12 = num11 = 0.0;
                    if (rad == 1.0)
                    {
                        if (k < 11)
                            return;
                        if (nit == 1 || nit == 9 || nit == 10)
                        {
                            int i1 = 1;
                            ind[i1] = 0;
                            double dist;
                            for (int i2 = 1; i2 <= k; ++i2)
                            {
                                dist = 9999999.9;
                                int num13 = 0;
                                for (int i3 = 0; i3 <= kPnt; ++i3)
                                {
                                    double num14 = x[i2] - xPnt[i3];
                                    double num15 = y[i2] - yPnt[i3];
                                    if (Math.Sqrt(num14 * num14 + num15 * num15) < 0.005)
                                    {
                                        num13 = i2;
                                        break;
                                    }
                                }
                                if (num13 > 0)
                                {
                                    ++i1;
                                    ind[i1] = num13;
                                }
                            }
                            int num16 = 12;
                            for (int i4 = 2; i4 <= i1; ++i4)
                            {
                                int num17 = ind[i4 - 1] + num16 + 1;
                                int num18 = ind[i4];
                                if (num18 - num17 > 2 * num16)
                                {
                                    int i5 = 0;
                                    double num19 = 9999999.9;
                                    for (int i6 = num17; i6 <= num18; ++i6)
                                    {
                                        int i7 = i6 - num16;
                                        int i8 = i6 + num16;
                                        if (i8 < num18)
                                        {
                                            int ip;
                                            DistPnt(x[i6], y[i6], x[i7], y[i7], x[i8], y[i8], out dist, out ip, out xp, out yp);
                                            if (ip > 0 && dist < num19)
                                            {
                                                num19 = dist;
                                                i5 = i6;
                                                double x1 = x[i8] - x[i7];
                                                num9 = Math.Atan2(y[i8] - y[i7], x1);
                                                if (num9 < 0.0)
                                                    num9 += 2.0 * num4;
                                            }
                                        }
                                        else
                                            break;
                                    }
                                    if (i5 != 0)
                                    {
                                        ++kit;
                                        if (kit > kArray)
                                        {
                                            int num20 = (int)MessageBox.Show("Индекс массива CoordItems");
                                            kit = 0;
                                            break;
                                        }
                                        xit[kit] = x[i5];
                                        yit[kit] = y[i5];
                                        az[kit] = num9;
                                    }
                                }
                            }
                            return;
                        }
                    }
                    if (rad > 1.0)
                    {
                        if (nit == 1 || nit == 9 || nit == 10)
                        {
                            int num21 = 150;
                            int i9 = -num21 + 1;
                            for (int i10 = 1; i10 < k; ++i10)
                            {
                                i9 += num21;
                                int i11 = i9 + num21;
                                if (i11 >= k)
                                    break;
                                double x2 = x[i11] - x[i9];
                                double num22 = Math.Atan2(y[i11] - y[i9], x2);
                                if (num22 < 0.0)
                                    num22 += 2.0 * num4;
                                int i12 = (i9 + i11) / 2;
                                ++kit;
                                if (kit > kArray)
                                {
                                    int num23 = (int)MessageBox.Show("Индекс массива CoordItems");
                                    kit = 0;
                                    break;
                                }
                                xit[kit] = x[i12];
                                yit[kit] = y[i12];
                                az[kit] = num22;
                            }
                            return;
                        }
                        if (iStyle == 8 || iStyle == 9)
                        {
                            int num24 = 25;
                            int i13 = 0;
                            int i14 = num24;
                            for (int i15 = 1; i15 <= k; ++i15)
                            {
                                double num25 = x[i13];
                                double num26 = y[i13];
                                double num27 = x[i14];
                                double num28 = y[i14];
                                double x3 = num27 - num25;
                                double num29 = Math.Atan2(num28 - num26, x3);
                                if (num29 < 0.0)
                                    num29 += 2.0 * num4;
                                int i16 = (i13 + i14) / 2;
                                ++kit;
                                if (kit > kArray)
                                {
                                    int num30 = (int)MessageBox.Show("Индекс массива CoordItems");
                                    kit = 0;
                                    return;
                                }
                                xit[kit] = x[i16];
                                yit[kit] = y[i16];
                                az[kit] = num29;
                                i13 += num24;
                                i14 += num24;
                                if (i13 < k && i14 > k)
                                    i14 = k;
                                if (i13 > k && i14 > k)
                                    break;
                            }
                        }
                        if (iStyle == 10 || iStyle == 11 || iStyle == 14)
                        {
                            int num31 = 20;
                            int num32 = 5;
                            if (iStyle == 11)
                            {
                                num31 = 10;
                                num32 = 3;
                            }
                            int i17 = 0;
                            int i18 = num31;
                            for (int i19 = 1; i19 <= k; ++i19)
                            {
                                double num33 = x[i17];
                                double num34 = y[i17];
                                double num35 = x[i18];
                                double num36 = y[i18];
                                double x4 = num35 - num33;
                                double num37 = Math.Atan2(num36 - num34, x4);
                                if (num37 < 0.0)
                                    num37 += 2.0 * num4;
                                int i20 = (i17 + i18) / 2;
                                ++kit;
                                if (kit > kArray)
                                {
                                    int num38 = (int)MessageBox.Show("Индекс массива CoordItems");
                                    kit = 0;
                                    return;
                                }
                                xit[kit] = x[i20];
                                yit[kit] = y[i20];
                                az[kit] = num37;
                                i17 = i18 + num32;
                                i18 = i17 + num31;
                                if (i17 < k && i18 > k)
                                    i18 = k;
                                if (i17 > k && i18 > k)
                                    break;
                            }
                        }
                        if (iStyle == 12)
                        {
                            int num39 = 20;
                            int num40 = 4;
                            int num41 = 20;
                            int i21 = 0;
                            int i22 = num39;
                            for (int i23 = 0; i23 <= k; ++i23)
                            {
                                double num42 = x[i21];
                                double num43 = y[i21];
                                double num44 = x[i22];
                                double num45 = y[i22];
                                double x5 = num44 - num42;
                                double num46 = Math.Atan2(num45 - num43, x5);
                                if (num46 < 0.0)
                                    num46 += 2.0 * num4;
                                int i24 = (i21 + i22) / 2;
                                ++kit;
                                if (kit > kArray)
                                {
                                    int num47 = (int)MessageBox.Show("Индекс массива CoordItems");
                                    kit = 0;
                                    return;
                                }
                                xit[kit] = x[i24];
                                yit[kit] = y[i24];
                                az[kit] = num46;
                                if (num41 == 20)
                                    num39 = 10;
                                if (num41 == 10)
                                    num39 = 20;
                                i21 = i22 + num40;
                                i22 = i21 + num39;
                                num41 = num39;
                                if (i21 < k && i22 > k)
                                    i22 = k;
                                if (i21 > k && i22 > k)
                                    break;
                            }
                        }
                        if (iStyle == 13)
                        {
                            int num48 = 20;
                            int num49 = 4;
                            int i25 = 0;
                            int i26 = num48;
                            for (int i27 = 0; i27 <= k; ++i27)
                            {
                                double num50 = x[i25];
                                double num51 = y[i25];
                                double num52 = x[i26];
                                double num53 = y[i26];
                                double x6 = num52 - num50;
                                double num54 = Math.Atan2(num53 - num51, x6);
                                if (num54 < 0.0)
                                    num54 += 2.0 * num4;
                                int i28 = (i25 + i26) / 2;
                                ++kit;
                                if (kit > kArray)
                                {
                                    int num55 = (int)MessageBox.Show("Индекс массива CoordItems");
                                    kit = 0;
                                    return;
                                }
                                xit[kit] = x[i28];
                                yit[kit] = y[i28];
                                az[kit] = num54;
                                i25 = i26 + num49 + num49;
                                i26 = i25 + num48;
                                if (i25 < k && i26 > k)
                                    i26 = k;
                                if (i25 > k && i26 > k)
                                    break;
                            }
                        }
                    }
                    if (rad > 0.0)
                        return;
                    if (nit == 1 || nit == 9 || nit == 10)
                    {
                        for (int i = 1; i <= k; ++i)
                        {
                            double x7 = x[i] - x[i - 1];
                            double y1 = y[i] - y[i - 1];
                            num10 = Math.Sqrt(x7 * x7 + y1 * y1);
                            double num56 = Math.Atan2(y1, x7);
                            if (num56 < 0.0)
                                num56 += 2.0 * num4;
                            ++kit;
                            if (kit > kArray)
                            {
                                int num57 = (int)MessageBox.Show("Индекс массива CoordItems");
                                kit = 0;
                                break;
                            }
                            xit[kit] = (x[i - 1] + x[i]) / 2.0;
                            yit[kit] = (y[i - 1] + y[i]) / 2.0;
                            az[kit] = num56;
                        }
                    }
                    else
                    {
                        for (int i = 1; i <= k; ++i)
                        {
                            double x8 = x[i] - x[i - 1];
                            double y2 = y[i] - y[i - 1];
                            double num58 = Math.Sqrt(x8 * x8 + y2 * y2);
                            double num59 = Math.Atan2(y2, x8);
                            if (num59 < 0.0)
                                num59 += 2.0 * num4;
                            if (iStyle == 8 || iStyle == 9 || iStyle == 14)
                            {
                                double num60 = x[i - 1];
                                double num61 = y[i - 1];
                                double num62 = 0.0;
                                if (num58 <= num1)
                                {
                                    num12 = x[i];
                                    num11 = y[i];
                                    ++kit;
                                    if (kit > kArray)
                                    {
                                        int num63 = (int)MessageBox.Show("Индекс массива CoordItems");
                                        kit = 0;
                                        break;
                                    }
                                    xit[kit] = 0.5 * (num60 + num12);
                                    yit[kit] = 0.5 * (num61 + num11);
                                    az[kit] = num59;
                                    continue;
                                }
                                do
                                {
                                    double num64 = num62 + num1;
                                    if (num64 < num58)
                                    {
                                        num12 = num60 + num1 * Math.Cos(num59);
                                        num11 = num61 + num1 * Math.Sin(num59);
                                    }
                                    if (num64 >= num58)
                                    {
                                        num12 = x[i];
                                        num11 = y[i];
                                    }
                                    ++kit;
                                    if (kit > kArray)
                                    {
                                        int num65 = (int)MessageBox.Show("Индекс массива CoordItems");
                                        kit = 0;
                                        return;
                                    }
                                    xit[kit] = 0.5 * (num60 + num12);
                                    yit[kit] = 0.5 * (num61 + num11);
                                    az[kit] = num59;
                                    num60 = num12 + num2 * Math.Cos(num59);
                                    num61 = num11 + num2 * Math.Sin(num59);
                                    num62 = num64 + num2;
                                }
                                while (num62 < num58);
                            }
                            if (iStyle == 10 || iStyle == 11)
                            {
                                double num66 = x[i - 1];
                                double num67 = y[i - 1];
                                double num68 = 0.0;
                                if (num58 <= num1)
                                {
                                    num12 = x[i];
                                    num11 = y[i];
                                    ++kit;
                                    if (kit > kArray)
                                    {
                                        int num69 = (int)MessageBox.Show("Индекс массива CoordItems");
                                        kit = 0;
                                        break;
                                    }
                                    xit[kit] = 0.5 * (num66 + num12);
                                    yit[kit] = 0.5 * (num67 + num11);
                                    az[kit] = num59;
                                    continue;
                                }
                                do
                                {
                                    double num70 = num68 + num1;
                                    if (num70 < num58)
                                    {
                                        num12 = num66 + num1 * Math.Cos(num59);
                                        num11 = num67 + num1 * Math.Sin(num59);
                                    }
                                    if (num70 >= num58)
                                    {
                                        num12 = x[i];
                                        num11 = y[i];
                                    }
                                    ++kit;
                                    if (kit > kArray)
                                    {
                                        int num71 = (int)MessageBox.Show("Индекс массива CoordItems");
                                        kit = 0;
                                        return;
                                    }
                                    xit[kit] = 0.5 * (num66 + num12);
                                    yit[kit] = 0.5 * (num67 + num11);
                                    az[kit] = num59;
                                    num66 = num12 + num2 * Math.Cos(num59);
                                    num67 = num11 + num2 * Math.Sin(num59);
                                    num68 = num70 + num2;
                                }
                                while (num68 < num58);
                            }
                            if (iStyle == 12 || iStyle == 13)
                            {
                                double num72 = x[i - 1];
                                double num73 = y[i - 1];
                                double num74 = 0.0;
                                if (num58 <= num1)
                                {
                                    num12 = x[i];
                                    num11 = y[i];
                                    ++kit;
                                    if (kit > kArray)
                                    {
                                        int num75 = (int)MessageBox.Show("Индекс массива CoordItems");
                                        kit = 0;
                                        break;
                                    }
                                    xit[kit] = 0.5 * (num72 + num12);
                                    yit[kit] = 0.5 * (num73 + num11);
                                    az[kit] = num59;
                                }
                                else
                                {
                                    do
                                    {
                                        double num76 = num74 + num1;
                                        if (num76 < num58)
                                        {
                                            num12 = num72 + num1 * Math.Cos(num59);
                                            num11 = num73 + num1 * Math.Sin(num59);
                                        }
                                        if (num76 >= num58)
                                        {
                                            num12 = x[i];
                                            num11 = y[i];
                                        }
                                        ++kit;
                                        if (kit > kArray)
                                        {
                                            int num77 = (int)MessageBox.Show("Индекс массива CoordItems");
                                            kit = 0;
                                            return;
                                        }
                                        xit[kit] = 0.5 * (num72 + num12);
                                        yit[kit] = 0.5 * (num73 + num11);
                                        az[kit] = num59;
                                        num72 = num12 + num2 * Math.Cos(num59);
                                        num73 = num11 + num2 * Math.Sin(num59);
                                        double num78 = num76 + num2;
                                        if (num78 < num58)
                                        {
                                            num74 = num78 + num3;
                                            if (num74 < num58)
                                            {
                                                num12 = num72 + num3 * Math.Cos(num59);
                                                num11 = num73 + num3 * Math.Sin(num59);
                                                num72 = num12 + num2 * Math.Cos(num59);
                                                num73 = num11 + num2 * Math.Sin(num59);
                                                num74 += num2;
                                            }
                                        }
                                        else
                                            break;
                                    }
                                    while (num74 < num58);
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void GetCentre(
          int k,
          ref double[] x,
          ref double[] y,
          double rad,
          out double xrad,
          out double yrad)
        {
            double num1;
            double num2 = num1 = 0.0;
            double num3;
            double num4 = num3 = 0.0;
            double num5;
            double num6 = num5 = 0.0;
            double num7;
            double num8 = num7 = 0.0;
            double num9 = 3.1415926;
            double num10 = 2.0 * num9;
            xrad = 0.0;
            yrad = 0.0;
            if (k < 2)
                return;
            int kArray = 999999;
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            if (k > kArray)
            {
                int num11 = (int)MessageBox.Show("Индекс массива GetCentre");
            }
            else
            {
                double num12 = x[0];
                double num13 = y[0];
                double num14 = x[k];
                double num15 = y[k];
                double x1 = num14 - num12;
                double y1 = num15 - num13;
                double num16 = Math.Sqrt(x1 * x1 + y1 * y1);
                if (num16 < 0.1)
                    return;
                double num17 = 0.5 * (num12 + num14);
                double num18 = 0.5 * (num13 + num15);
                if (Math.Abs(num16 - 2.0 * rad) < 0.002)
                {
                    xrad = num17;
                    yrad = num18;
                }
                else
                {
                    double num19 = Math.Atan2(y1, x1);
                    if (num19 < 0.0)
                        num19 += num10;
                    double num20 = num19 + 0.5 * num9;
                    if (num20 >= num10)
                        num20 -= num10;
                    double num21 = 0.5 * num16;
                    double num22 = Math.Sqrt(rad * rad - num21 * num21);
                    if (num22 < 0.002)
                    {
                        xrad = num17;
                        yrad = num18;
                    }
                    else
                    {
                        double num23 = num17 + num22 * Math.Cos(num20);
                        double num24 = num18 + num22 * Math.Sin(num20);
                        double num25 = x[k / 2] - num23;
                        double num26 = y[k / 2] - num24;
                        if (Math.Abs(Math.Sqrt(num25 * num25 + num26 * num26) - rad) < 0.002)
                        {
                            xrad = num23;
                            yrad = num24;
                        }
                        else
                        {
                            double num27 = num17 - num22 * Math.Cos(num20);
                            double num28 = num18 - num22 * Math.Sin(num20);
                            xrad = num27;
                            yrad = num28;
                        }
                    }
                }
            }
        }

        public static void CoorWin(
          double x1,
          double y1,
          double x2,
          double y2,
          int iWidth,
          int iHeight,
          out double scaleToWin,
          out double scaleToGeo,
          out double xBegX,
          out double yBegY,
          out double xEndX,
          out double yEndY,
          out int xBegWin,
          out int yBegWin,
          out int xEndWin,
          out int yEndWin,
          out int iCond)
        {
            scaleToWin = 0.0;
            scaleToGeo = 0.0;
            xBegX = yBegY = xEndX = yEndY = 0.0;
            xBegWin = yBegWin = 0;
            xEndWin = yEndWin = 0;
            iCond = 0;
            if (double.IsNaN(x1) || double.IsNaN(y1) || double.IsNaN(x2) || double.IsNaN(y2))
            {
                int num = (int)MessageBox.Show("CoorWin-Problem of data");
                iCond = -99;
            }
            else
            {
                xBegX = x1;
                yBegY = y1;
                xEndX = x2;
                yEndY = y2;
                int int32_1 = Convert.ToInt32(0.8 * (double)iWidth);
                int int32_2 = Convert.ToInt32(0.8 * (double)iHeight);
                int int32_3 = Convert.ToInt32(0.07 * (double)int32_1);
                int int32_4 = Convert.ToInt32(0.075 * (double)int32_2);
                double num1 = (double)int32_1 / (x2 - x1);
                double num2 = (double)int32_2 / (y2 - y1);
                if (num1 >= num2)
                    scaleToWin = num2;
                if (num2 > num1)
                    scaleToWin = num1;
                int int32_5 = Convert.ToInt32((double)int32_3 + scaleToWin * (x2 - x1));
                int int32_6 = Convert.ToInt32((double)int32_4 + scaleToWin * (y2 - y1));
                double num3 = (x2 - x1) / (double)(int32_5 - int32_3);
                double num4 = (y2 - y1) / (double)(int32_6 - int32_4);
                if (num3 >= num4)
                    scaleToGeo = num4;
                if (num4 > num3)
                    scaleToGeo = num3;
                xBegWin = int32_3 + Convert.ToInt32(((double)int32_1 - (x2 - x1) * scaleToWin) / 2.0);
                yBegWin = int32_4 + int32_2 - Convert.ToInt32(((double)int32_2 - (y2 - y1) * scaleToWin) / 2.0);
                xEndWin = int32_5;
                yEndWin = int32_4;
            }
        }

        private static int ToInt32b(double value)
        {
            int result = value >= Int32.MaxValue ?  2
             : value <= Int32.MinValue ? - 2
              : Convert.ToInt32(value);
            Console.WriteLine("ToInt32: value={0}, result={1}", value, result);
            return result;
        }
        public static void XYtoWIN(
          double xCur,
          double yCur,
          double scaleToWin,
          double xBegX,
          double yBegY,
          int xBegWin,
          int yBegWin,
          out int xWin,
          out int yWin)
        {
            xWin = yWin = 0;
            if (double.IsNaN(xCur) || double.IsNaN(yCur))
            {
                int num = (int)MessageBox.Show("Проблема с данными");
            }
            else
            {
                xWin = DllClass1.ToInt32b((double)xBegWin + (xCur - xBegX) * scaleToWin);

                yWin = DllClass1.ToInt32b((double)yBegWin - (yCur - yBegY) * scaleToWin);
            }
        }

        public static void WINtoXY(
          int xWin,
          int yWin,
          double scaleToGeo,
          double xBegX,
          double yBegY,
          int xBegWin,
          int yBegWin,
          out double xCur,
          out double yCur)
        {
            xCur = yCur = 0.0;
            if (double.IsNaN(scaleToGeo))
            {
                int num = (int)MessageBox.Show("Problem of data");
            }
            else
            {
                xCur = xBegX + (double)(xWin - xBegWin) * scaleToGeo;
                yCur = yBegY + (double)(yBegWin - yWin) * scaleToGeo;
            }
        }

        public static void CircleRad(
          double rad,
          double xo,
          double yo,
          double shag,
          int kPxy,
          double[] x1Pix,
          double[] y1Pix,
          double[] x2Pix,
          double[] y2Pix,
          out int kCell,
          double[] xCell,
          double[] yCell,
          out int ke,
          double[] xe,
          double[] ye,
          double[] xr,
          double[] yr,
          out int iCond)
        {
            double num1 = 3.1415926;
            iCond = 0;
            kCell = 0;
            int kArray = 999999;
            doubleArray(xe, ref kArray);
            doubleArray(ye, ref kArray);
            int num2 = kArray - 2;
            int int32 = Convert.ToInt32(2.0 * num1 * rad / shag);
            double num3 = 2.0 * num1 / (double)int32;
            double num4 = 0.0;
            ke = 0;
            xe[0] = xo + rad;
            ye[0] = yo;
            for (int i = 1; i <= int32; ++i)
            {
                if (ke > num2)
                {
                    int num5 = (int)MessageBox.Show("Индекс массива CircleRad");
                    return;
                }
                num4 += num3;
                ++ke;
                xe[ke] = xo + rad * Math.Cos(num4);
                ye[ke] = yo + rad * Math.Sin(num4);
            }
            int kCell1 = 0;
            for (int i1 = 1; i1 <= ke; ++i1)
            {
                double num6 = xe[i1 - 1];
                double num7 = ye[i1 - 1];
                double num8 = xe[i1];
                double num9 = ye[i1];
                if (double.IsNaN(num6) || double.IsNaN(num7) || double.IsNaN(num8) || double.IsNaN(num9))
                {
                    iCond = -99;
                }
                else
                {
                    GridLine(kPxy, x1Pix, y1Pix, x2Pix, y2Pix, num6, num7, num8, num9, out kCell1, xr, yr, out iCond);
                    if (kCell1 > 0)
                    {
                        for (int i2 = 1; i2 <= kCell1; ++i2)
                        {
                            ++kCell;
                            xCell[kCell] = xr[i2];
                            yCell[kCell] = yr[i2];
                        }
                    }
                }
            }
        }

        public static void DistPnt(
          double xx,
          double yy,
          double x1,
          double y1,
          double x2,
          double y2,
          out double dist,
          out int ip,
          out double xp,
          out double yp)
        {
            double[] x3 = new double[6];
            double[] y3 = new double[6];
            int k = 4;
            xp = yp = 0.0;
            double num1;
            double num2 = num1 = 0.0;
            double ym = num1;
            double xm = num1;
            double num3;
            double num4 = num3 = 0.0;
            double num5 = 3.1415926;
            double num6 = 6.2831852;
            dist = 0.0;
            ip = 0;
            double num7 = x1 - xx;
            double num8 = y1 - yy;
            double num9 = Math.Sqrt(num7 * num7 + num8 * num8);
            double num10 = x2 - xx;
            double num11 = y2 - yy;
            double num12 = Math.Sqrt(num10 * num10 + num11 * num11);
            if (num9 >= num12)
                num4 = num9;
            if (num12 > num9)
                num4 = num12;
            double x4 = x2 - x1;
            double y4 = y2 - y1;
            if (Math.Abs(x4) < 0.001 && Math.Abs(y4) < 0.001)
                return;
            double num13 = Math.Atan2(y4, x4);
            if (num13 < 0.0)
                num13 += num6;
            double num14 = num13 + 0.5 * num5;
            if (num14 >= num6)
                num14 -= num6;
            double x3_1 = xx - num4 * Math.Cos(num14);
            double y3_1 = yy - num4 * Math.Sin(num14);
            double x4_1 = xx + num4 * Math.Cos(num14);
            double y4_1 = yy + num4 * Math.Sin(num14);
            int ip1 = 1;
            TwoLine(x1, y1, x3_1, y3_1, x2, y2, x4_1, y4_1, out xm, out ym, ref ip1);
            xp = xm;
            yp = ym;
            x3[0] = x1;
            y3[0] = y1;
            x3[1] = x3_1;
            y3[1] = y3_1;
            x3[2] = x2;
            y3[2] = y2;
            x3[3] = x4_1;
            y3[3] = y4_1;
            x3[4] = x1;
            y3[4] = y1;
            if (in_out(k, ref x3, ref y3, xm, ym) == 0)
                return;
            double num15 = xm - xx;
            double num16 = ym - yy;
            dist = Math.Sqrt(num15 * num15 + num16 * num16);
            ip = 1;
        }

        public static void DrawItemList(
          PaintEventArgs e,
          string fitemLine,
          int kItemLine,
          int[] hItemLine,
          SolidBrush[] brColor)
        {
            Graphics graphics = e.Graphics;
            int x1 = 20;
            int num1 = 75;
            SolidBrush solidBrush1 = new SolidBrush(Color.Black);
            Pen pen = new Pen(Color.Black, 1f);
            Font font1 = new Font("Arial", 8f);
            Font font2 = new Font("Arial", 8f, FontStyle.Bold);
            SolidBrush solidBrush2 = new SolidBrush(Color.Black);
            if (kItemLine <= 0)
                return;
            FileStream input = new FileStream(fitemLine, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            try
            {
                for (int i1 = 1; i1 <= kItemLine; ++i1)
                {
                    string s = binaryReader.ReadString();
                    int num2 = binaryReader.ReadInt32();
                    int y1 = hItemLine[i1];
                    if (num2 == 0)
                    {
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        binaryReader.ReadInt32();
                        binaryReader.ReadInt32();
                        int num3 = binaryReader.ReadInt32();
                        if (num3 > 0)
                        {
                            graphics.DrawString(s, font1, (Brush)solidBrush2, (float)x1, (float)y1);
                            for (int i2 = 1; i2 <= num3; ++i2)
                            {
                                int num4 = binaryReader.ReadInt32();
                                int num5 = binaryReader.ReadInt32();
                                int i3 = binaryReader.ReadInt32();
                                SolidBrush solidBrush3 = brColor[i3];
                                int x2 = num1 + num4;
                                int y2 = y1 + num5;
                                graphics.FillRectangle((Brush)solidBrush3, x2, y2, 1, 1);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            binaryReader.Close();
            input.Close();
        }

        public static void CoordLineItem(
          int nDensity,
          int kAngle,
          double[] xAng,
          double[] yAng,
          int nBase,
          out int kit,
          double[] xit,
          double[] yit)
        {
            double num1 = 0.0;
            double num2 = 0.0;
            double num3 = 0.0;
            kit = 0;
            int kArray = 999999;
            doubleArray(xit, ref kArray);
            doubleArray(yit, ref kArray);
            int num4 = kArray - 3;
            if (nBase == 1 || nBase == 2 || nBase == 3 || nBase == 7)
            {
                num1 = 28.0;
                num3 = 12.0;
            }
            if (nBase == 4)
            {
                num1 = 32.0;
                num3 = 7.0;
            }
            if (nBase == 5)
            {
                num1 = 42.0;
                num3 = 12.0;
            }
            if (nBase == 6)
            {
                num1 = 33.0;
                num3 = 13.0;
            }
            if (nBase == 8)
            {
                num1 = 32.0;
                num3 = 7.0;
            }
            for (int i = 1; i <= kAngle; ++i)
            {
                double num5 = xAng[i] - xAng[i - 1];
                double num6 = yAng[i] - yAng[i - 1];
                double num7 = Math.Sqrt(num5 * num5 + num6 * num6);
                if (num1 < num7)
                {
                    if (kit > num4)
                    {
                        int num8 = (int)MessageBox.Show("Индекс массива CoordLineItem");
                        break;
                    }
                    double num9 = num3;
                    ++kit;
                    xit[kit] = xAng[i - 1] + num9 * Math.Cos(num2);
                    yit[kit] = yAng[i - 1] + num9 * Math.Sin(num2);
                    do
                    {
                        num9 += num1;
                        if (num9 < num7)
                        {
                            ++kit;
                            xit[kit] = xAng[i - 1] + num9 * Math.Cos(num2);
                            yit[kit] = yAng[i - 1] + num9 * Math.Sin(num2);
                        }
                        else
                            break;
                    }
                    while (num9 < num7);
                }
            }
        }

        public static void LineSymbolStyle(
          PaintEventArgs e,
          Pen jColor,
          int iStyle,
          int k,
          double[] x,
          double[] y,
          int iWid)
        {
            Graphics graphics = e.Graphics;
            int num1 = 0;
            int num2 = 0;
            int num3 = 0;
            int kArray = 999999;
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            int num4 = kArray - 3;
            if (k > num4)
            {
                int num5 = (int)MessageBox.Show("Индекс массива LineStyleSymbol");
            }
            else
            {
                jColor.DashStyle = DashStyle.Solid;
                if (iStyle == 3)
                {
                    num3 = 0;
                    num1 = 24;
                    num2 = 4;
                }
                if (iStyle == 4)
                {
                    num3 = 0;
                    num1 = 12;
                    num2 = 4;
                }
                if (iStyle == 5)
                {
                    num1 = 24;
                    num2 = 4;
                    num3 = 10;
                }
                if (iStyle == 6)
                {
                    num1 = 24;
                    num2 = 4;
                    num3 = 2;
                    if (iWid == 1)
                        num3 = 1;
                }
                if (iStyle == 1 || iStyle == 2 || iStyle == 7)
                {
                    num3 = 0;
                    num1 = 30;
                    num2 = 0;
                }
                int num6;
                int num7 = num6 = 0;
                double num8;
                double num9 = num8 = 0.0;
                int num10;
                int num11 = num10 = 0;
                int num12 = num1 + num2 + num3;
                jColor.Width = (float)iWid;
                for (int i1 = 1; i1 <= k; ++i1)
                {
                    double num13 = x[i1] - x[i1 - 1];
                    double num14 = y[i1] - y[i1 - 1];
                    int int32_1 = Convert.ToInt32(Math.Sqrt(num13 * num13 + num14 * num14));
                    if (num12 > 0)
                    {
                        int int32_2 = Convert.ToInt32(int32_1 / num12);
                        if (Convert.ToInt32(int32_1 - int32_2 * num12) > 0)
                            ++int32_2;
                        int x1_1 = Convert.ToInt32(x[i1 - 1]);
                        int y1_1 = Convert.ToInt32(y[i1 - 1]);
                        int num15 = 0;
                        if (iStyle == 3 || iStyle == 4)
                        {
                            for (int i2 = 1; i2 <= int32_2; ++i2)
                            {
                                double num16 = x[i1] - (double)x1_1;
                                double num17 = y[i1] - (double)y1_1;
                                if (Convert.ToInt32(Math.Sqrt(num16 * num16 + num17 * num17)) > 2 && num15 < int32_1)
                                {
                                    if (i2 == int32_2)
                                    {
                                        int int32_3 = Convert.ToInt32(x[i1]);
                                        int int32_4 = Convert.ToInt32(y[i1]);
                                        graphics.DrawLine(jColor, x1_1, y1_1, int32_3, int32_4);
                                        break;
                                    }
                                    num15 += num1;
                                    if (num15 >= int32_1)
                                    {
                                        double num18 = x[i1] - (double)x1_1;
                                        double num19 = y[i1] - (double)y1_1;
                                        if (Convert.ToInt32(Math.Sqrt(num18 * num18 + num19 * num19)) > 2)
                                        {
                                            int int32_5 = Convert.ToInt32(x[i1]);
                                            int int32_6 = Convert.ToInt32(y[i1]);
                                            graphics.DrawLine(jColor, x1_1, y1_1, int32_5, int32_6);
                                            break;
                                        }
                                        break;
                                    }
                                    int x2 = x1_1 + Convert.ToInt32((double)num1 * Math.Cos(num9));
                                    int y2 = y1_1 + Convert.ToInt32((double)num1 * Math.Sin(num9));
                                    graphics.DrawLine(jColor, x1_1, y1_1, x2, y2);
                                    num15 += num2;
                                    if (num15 < int32_1 && Math.Abs(int32_1 - num15) > num2)
                                    {
                                        x1_1 = x2 + Convert.ToInt32((double)num2 * Math.Cos(num9));
                                        y1_1 = y2 + Convert.ToInt32((double)num2 * Math.Sin(num9));
                                    }
                                    else
                                        break;
                                }
                                else
                                    break;
                            }
                        }
                        if (iStyle == 5 || iStyle == 6)
                        {
                            for (int i3 = 1; i3 <= int32_2; ++i3)
                            {
                                double num20 = x[i1] - (double)x1_1;
                                double num21 = y[i1] - (double)y1_1;
                                if (Convert.ToInt32(Math.Sqrt(num20 * num20 + num21 * num21)) > 2)
                                {
                                    if (i3 == int32_2)
                                    {
                                        int int32_7 = Convert.ToInt32(x[i1]);
                                        int int32_8 = Convert.ToInt32(y[i1]);
                                        graphics.DrawLine(jColor, x1_1, y1_1, int32_7, int32_8);
                                        break;
                                    }
                                    num15 += num1;
                                    if (num15 >= int32_1)
                                    {
                                        double num22 = x[i1] - (double)x1_1;
                                        double num23 = y[i1] - (double)y1_1;
                                        if (Convert.ToInt32(Math.Sqrt(num22 * num22 + num23 * num23)) > 2)
                                        {
                                            int int32_9 = Convert.ToInt32(x[i1]);
                                            int int32_10 = Convert.ToInt32(y[i1]);
                                            graphics.DrawLine(jColor, x1_1, y1_1, int32_9, int32_10);
                                            break;
                                        }
                                        break;
                                    }
                                    int x2_1 = x1_1 + Convert.ToInt32((double)num1 * Math.Cos(num9));
                                    int y2_1 = y1_1 + Convert.ToInt32((double)num1 * Math.Sin(num9));
                                    graphics.DrawLine(jColor, x1_1, y1_1, x2_1, y2_1);
                                    num15 += num2;
                                    if (num15 < int32_1)
                                    {
                                        int x1_2 = x2_1 + Convert.ToInt32((double)num2 * Math.Cos(num9));
                                        int y1_2 = y2_1 + Convert.ToInt32((double)num2 * Math.Sin(num9));
                                        num15 += num3;
                                        if (num15 >= int32_1)
                                        {
                                            int int32_11 = Convert.ToInt32(x[i1]);
                                            int int32_12 = Convert.ToInt32(y[i1]);
                                            graphics.DrawLine(jColor, x1_2, y1_2, int32_11, int32_12);
                                            break;
                                        }
                                        int x2_2 = x1_2 + Convert.ToInt32((double)num3 * Math.Cos(num9));
                                        int y2_2 = y1_2 + Convert.ToInt32((double)num3 * Math.Sin(num9));
                                        num15 += num2;
                                        if (num15 < int32_1)
                                        {
                                            graphics.DrawLine(jColor, x1_2, y1_2, x2_2, y2_2);
                                            x1_1 = x2_2 + Convert.ToInt32((double)num2 * Math.Cos(num9));
                                            y1_1 = y2_2 + Convert.ToInt32((double)num2 * Math.Sin(num9));
                                        }
                                        else
                                            break;
                                    }
                                    else
                                        break;
                                }
                                else
                                    break;
                            }
                        }
                        if (iStyle == 1 || iStyle == 2 || iStyle == 7)
                        {
                            int x1_3 = Convert.ToInt32(x[i1 - 1]);
                            int y1_3 = Convert.ToInt32(y[i1 - 1]);
                            int int32_13 = Convert.ToInt32(x[i1]);
                            int int32_14 = Convert.ToInt32(y[i1]);
                            if (iStyle == 1 || iStyle == 2)
                                graphics.DrawLine(jColor, x1_3, y1_3, int32_13, int32_14);
                            if (iStyle == 7)
                            {
                                jColor.Width = 2f;
                                jColor.DashPattern = new float[4]
                                {
                                      1f,
                                      2f,
                                      1f,
                                      2f
                                };
                                graphics.DrawLine(jColor, x1_3, y1_3, int32_13, int32_14);
                            }
                            for (int i4 = 1; i4 <= int32_2; ++i4)
                            {
                                double num24 = x[i1] - (double)x1_3;
                                double num25 = y[i1] - (double)y1_3;
                                num11 = Convert.ToInt32(Math.Sqrt(num24 * num24 + num25 * num25));
                                if (num15 < int32_1)
                                {
                                    if (i4 == int32_2)
                                    {
                                        num7 = Convert.ToInt32(x[i1]);
                                        num6 = Convert.ToInt32(y[i1]);
                                        break;
                                    }
                                    int num26 = num15 + num1;
                                    if (num26 >= int32_1)
                                    {
                                        double num27 = x[i1] - (double)x1_3;
                                        double num28 = y[i1] - (double)y1_3;
                                        if (Convert.ToInt32(Math.Sqrt(num27 * num27 + num28 * num28)) > 2)
                                        {
                                            num7 = Convert.ToInt32(x[i1]);
                                            num6 = Convert.ToInt32(y[i1]);
                                            break;
                                        }
                                        break;
                                    }
                                    int num29 = x1_3 + Convert.ToInt32((double)num1 * Math.Cos(num9));
                                    int num30 = y1_3 + Convert.ToInt32((double)num1 * Math.Sin(num9));
                                    num15 = num26 + num1;
                                    x1_3 = num29 + Convert.ToInt32((double)num1 * Math.Cos(num9));
                                    y1_3 = num30 + Convert.ToInt32((double)num1 * Math.Sin(num9));
                                    if (int32_1 - num15 < 0)
                                        break;
                                }
                                else
                                    break;
                            }
                        }
                    }
                }
            }
        }

        public static void GridCircle(
          double x1,
          double y1,
          double x2,
          double y2,
          double shag,
          int kPxy,
          double[] x1Pix,
          double[] y1Pix,
          double[] x2Pix,
          double[] y2Pix,
          out int kCell,
          double[] xCell,
          double[] yCell,
          out int ke,
          double[] xe,
          double[] ye,
          double[] xr,
          double[] yr,
          out int iCond)
        {
            iCond = 0;
            ke = 0;
            kCell = 0;
            int kArray = 999999;
            doubleArray(xCell, ref kArray);
            doubleArray(yCell, ref kArray);
            doubleArray(xe, ref kArray);
            doubleArray(ye, ref kArray);
            int num1 = kArray - 10;
            double num2 = x2 - x1;
            double num3 = y2 - y1;
            if (num2 > num3)
                x2 = x1 + num3;
            if (num3 > num2)
                y2 = y1 + num2;
            double num4 = 0.5 * (x2 - x1);
            double num5 = 0.5 * (x1 + x2);
            double num6 = 0.5 * (y1 + y2);
            int int32 = Convert.ToInt32(num4 / shag);
            xr[0] = x1;
            yr[0] = num6;
            int i1 = 0;
            for (int i2 = 1; i2 <= int32; ++i2)
            {
                double num7 = (double)i2 * shag - num4;
                double num8 = Math.Sqrt(num4 * num4 - num7 * num7);
                ++i1;
                xr[i1] = num5 + num7;
                yr[i1] = num6 + num8;
            }
            int i3 = i1 + 1;
            for (int i4 = 0; i4 <= i1; ++i4)
            {
                --i3;
                xe[i4] = xr[i3];
                ye[i4] = yr[i3];
            }
            ke = i1;
            for (int i5 = 1; i5 <= int32; ++i5)
            {
                double num9 = (double)i5 * shag - num4;
                double num10 = Math.Sqrt(num4 * num4 - num9 * num9);
                ++ke;
                if (ke > num1)
                {
                    int num11 = (int)MessageBox.Show("Индекс массива GridCircle");
                    return;
                }
                xe[ke] = num5 + num9;
                ye[ke] = num6 - num10;
            }
            int i6 = -1;
            for (int i7 = 0; i7 <= ke; ++i7)
            {
                if (xe[i7] <= num5)
                {
                    ++i6;
                    xe[i6] = xe[i7];
                    ye[i6] = ye[i7];
                }
            }
            ke = i6;
            double num12 = xe[ke];
            xr[0] = x2;
            yr[0] = num6;
            int i8 = 0;
            for (int i9 = 1; i9 <= int32; ++i9)
            {
                double num13 = num4 - (double)i9 * shag;
                double num14 = Math.Sqrt(num4 * num4 - num13 * num13);
                ++i8;
                xr[i8] = num5 + num13;
                yr[i8] = num6 - num14;
            }
            int i10 = i8 + 1;
            for (int i11 = 0; i11 <= i8; ++i11)
            {
                --i10;
                if (xr[i10] > num12)
                {
                    ++ke;
                    if (ke > num1)
                    {
                        int num15 = (int)MessageBox.Show("Индекс массива GridCircle");
                        return;
                    }
                    xe[ke] = xr[i10];
                    ye[ke] = yr[i10];
                }
            }
            for (int i12 = 1; i12 <= int32; ++i12)
            {
                double num16 = num4 - (double)i12 * shag;
                double num17 = Math.Sqrt(num4 * num4 - num16 * num16);
                ++ke;
                if (ke > num1)
                {
                    int num18 = (int)MessageBox.Show("Индекс массива GridCircle");
                    return;
                }
                xe[ke] = num5 + num16;
                ye[ke] = num6 + num17;
            }
            int kCell1 = 0;
            for (int i13 = 1; i13 <= ke; ++i13)
            {
                double num19 = xe[i13 - 1];
                double num20 = ye[i13 - 1];
                double num21 = xe[i13];
                double num22 = ye[i13];
                if (double.IsNaN(num19) || double.IsNaN(num20) || double.IsNaN(num21) || double.IsNaN(num22))
                {
                    iCond = -99;
                }
                else
                {
                    GridLine(kPxy, x1Pix, y1Pix, x2Pix, y2Pix, num19, num20, num21, num22, out kCell1, xr, yr, out iCond);
                    if (kCell1 > 0)
                    {
                        for (int i14 = 1; i14 <= kCell1; ++i14)
                        {
                            ++kCell;
                            if (kCell > num1)
                            {
                                int num23 = (int)MessageBox.Show("Индекс массива GridArc");
                                return;
                            }
                            xCell[kCell] = xr[i14];
                            yCell[kCell] = yr[i14];
                        }
                    }
                }
            }
        }

        public static void DownItem(int kRect, double[] yRect, out int iCond)
        {
            int num1 = 1;
            int num2 = 0;
            iCond = 99;
            int int32_1 = Convert.ToInt32(yRect[1]);
            for (int i = 2; i <= kRect; ++i)
            {
                int int32_2 = Convert.ToInt32(yRect[i]);
                if (int32_1 == int32_2)
                {
                    ++num1;
                }
                else
                {
                    if (int32_1 > int32_2)
                        num2 = int32_1 - int32_2;
                    if (int32_2 > int32_1)
                        num2 = int32_2 - int32_1;
                    if (num2 <= 2)
                        ++num1;
                    else
                        break;
                }
            }
            int num3 = Convert.ToInt32(yRect[num1 + 1]) - int32_1;
            int num4 = kRect / num1;
            if (kRect - num4 * num1 > 0)
                ++num4;
            if (Convert.ToInt32(yRect[1]) >= 230)
            {
                iCond = 0;
            }
            else
            {
                int num5 = num1;
                int i1 = -num1 + 1;
                for (int i2 = 1; i2 <= num4; ++i2)
                {
                    i1 += num1;
                    int i3 = i1;
                    yRect[i1] = yRect[i1] + 1.0 * (double)num3;
                    if (i1 == kRect)
                        break;
                    for (int i4 = 1; i4 <= num5; ++i4)
                    {
                        ++i3;
                        yRect[i3] = yRect[i3] + 1.0 * (double)num3;
                        if (i3 != kRect)
                        {
                            int num6 = i3 / num1;
                            if (i3 - num6 * num1 == 0)
                                break;
                        }
                        else
                            break;
                    }
                }
            }
        }

        public static void ConcentricCircle(
          int kx,
          int[] ixPix,
          int ky,
          int[] iyPix,
          int kPxy,
          double[] x1Pix,
          double[] y1Pix,
          double[] x2Pix,
          double[] y2Pix,
          out int kCell,
          double[] xCell,
          double[] yCell,
          out int ke,
          double[] xe,
          double[] ye,
          double[] xr,
          double[] yr,
          double[] xd,
          double[] yd,
          out int iCond)
        {
            int iCond1 = 0;
            int kCell1 = 0;
            iCond = 0;
            ke = 0;
            kCell = 0;
            int kArray = 999999;
            doubleArray(xCell, ref kArray);
            doubleArray(yCell, ref kArray);
            doubleArray(xe, ref kArray);
            doubleArray(ye, ref kArray);
            int num1 = kArray - 10;
            double x1 = 0.5 * (double)(ixPix[1] + ixPix[2]);
            double y1 = 0.5 * (double)(iyPix[1] + iyPix[2]);
            double x2 = 0.5 * (double)(ixPix[kx - 1] + ixPix[kx]);
            double y2 = 0.5 * (double)(iyPix[ky - 1] + iyPix[ky]);
            double shag = 1.0 * (double)(ixPix[2] - ixPix[1]);
            double num2 = x2 - x1;
            double num3 = y2 - y1;
            if (num2 > num3)
                x2 = x1 + num3;
            if (num3 > num2)
                y2 = y1 + num2;
            double num4 = 0.5 * (x1 + x2);
            double num5 = 0.5 * (y1 + y2);
            GridCircle(x1, y1, x2, y2, shag, kPxy, x1Pix, y1Pix, x2Pix, y2Pix, out kCell, xCell, yCell, out ke, xe, ye, xr, yr, out iCond1);
            if (iCond1 < 0)
                iCond = -99;
            GridCircle(0.5 * ((double)ixPix[1] + num4), 0.5 * ((double)iyPix[1] + num5), 0.5 * ((double)ixPix[kx] + num4), 0.5 * ((double)iyPix[ky] + num5), shag, kPxy, x1Pix, y1Pix, x2Pix, y2Pix, out kCell1, xd, yd, out ke, xe, ye, xr, yr, out iCond1);
            if (iCond1 < 0)
                iCond = -99;
            if (kCell1 <= 0)
                return;
            for (int i = 1; i <= kCell1; ++i)
            {
                ++kCell;
                if (kCell > num1)
                {
                    int num6 = (int)MessageBox.Show("Индекс массива ConcentricCircle");
                    break;
                }
                xCell[kCell] = xd[i];
                yCell[kCell] = yd[i];
            }
        }

        public static void TriangleCircle(
          int kx,
          int[] ixPix,
          int ky,
          int[] iyPix,
          int kPxy,
          double[] x1Pix,
          double[] y1Pix,
          double[] x2Pix,
          double[] y2Pix,
          out int kCell,
          double[] xCell,
          double[] yCell,
          out int ke,
          double[] xe,
          double[] ye,
          double[] xr,
          double[] yr,
          double[] xDat,
          double[] yDat,
          out int iCond)
        {
            double[] numArray1 = new double[10];
            double[] numArray2 = new double[10];
            iCond = 0;
            ke = 0;
            kCell = 0;
            double num1 = 0.5 * (double)(ixPix[1] + ixPix[2]);
            double num2 = 0.5 * (double)(iyPix[1] + iyPix[2]);
            double num3 = 0.5 * (double)(ixPix[kx - 1] + ixPix[kx]);
            double num4 = 0.5 * (double)(iyPix[ky - 1] + iyPix[ky]);
            double shag = 1.0 * (double)(ixPix[2] - ixPix[1]);
            int num5 = 3;
            numArray1[0] = num1;
            numArray2[0] = num4;
            numArray1[1] = 0.5 * (num1 + num3);
            numArray2[1] = num2;
            numArray1[2] = num3;
            numArray2[2] = num4;
            numArray1[3] = num1;
            numArray2[3] = num4;
            double num6 = 0.5 * (num1 + num3);
            double num7 = num4;
            double num8 = 0.0;
            double xx = num6;
            double yy = num7;
            for (int i = 1; i < ky; ++i)
            {
                yy -= shag;
                num8 += shag;
                double dist;
                int ip;
                DistPnt(xx, yy, numArray1[0], numArray2[0], numArray1[1], numArray2[1], out dist, out ip, out double _, out double _);
                if (ip > 0 && num8 > dist)
                    break;
            }
            double rad = num8 - shag;
            double xo = xx;
            double yo = yy + 0.5 * shag;
            int kCell1 = 0;
            for (int i1 = 1; i1 <= num5; ++i1)
            {
                double x1Line = numArray1[i1 - 1];
                double y1Line = numArray2[i1 - 1];
                double x2Line = numArray1[i1];
                double y2Line = numArray2[i1];
                GridLine(kPxy, x1Pix, y1Pix, x2Pix, y2Pix, x1Line, y1Line, x2Line, y2Line, out kCell1, xr, yr, out iCond);
                if (iCond < 0)
                    return;
                if (kCell1 > 0)
                {
                    for (int i2 = 1; i2 <= kCell1; ++i2)
                    {
                        ++kCell;
                        xCell[kCell] = xr[i2];
                        yCell[kCell] = yr[i2];
                    }
                }
            }
            CircleRad(rad, xo, yo, shag, kPxy, x1Pix, y1Pix, x2Pix, y2Pix, out kCell1, xr, yr, out ke, xe, ye, xDat, yDat, out iCond);
            if (iCond < 0 || kCell1 <= 0)
                return;
            for (int i = 1; i <= kCell1; ++i)
            {
                ++kCell;
                xCell[kCell] = xr[i];
                yCell[kCell] = yr[i];
            }
        }

        public static void UpSign(int kRect, double[] yRect, int pixHei, out int iCond)
        {
            int num1 = 1;
            int num2 = 0;
            iCond = 99;
            int int32_1 = Convert.ToInt32(yRect[1]);
            for (int i = 2; i <= kRect; ++i)
            {
                int int32_2 = Convert.ToInt32(yRect[i]);
                if (int32_1 == int32_2)
                {
                    ++num1;
                }
                else
                {
                    if (int32_1 > int32_2)
                        num2 = int32_1 - int32_2;
                    if (int32_2 > int32_1)
                        num2 = int32_2 - int32_1;
                    if (num2 <= 2)
                        ++num1;
                    else
                        break;
                }
            }
            int num3 = Convert.ToInt32(yRect[num1 + 1]) - int32_1;
            int num4 = kRect / num1;
            if (kRect - num4 * num1 > 0)
                ++num4;
            int i1 = -num1 + 1;
            for (int i2 = 1; i2 <= num4; ++i2)
                i1 += num1;
            if (Convert.ToInt32(yRect[i1]) < pixHei - num3)
            {
                iCond = 0;
            }
            else
            {
                int num5 = num1;
                int i3 = -num1 + 1;
                for (int i4 = 1; i4 <= num4; ++i4)
                {
                    i3 += num1;
                    int i5 = i3;
                    yRect[i3] = yRect[i3] - 1.0 * (double)num3;
                    if (i3 == kRect)
                        break;
                    for (int i6 = 1; i6 <= num5; ++i6)
                    {
                        ++i5;
                        yRect[i5] = yRect[i5] - 1.0 * (double)num3;
                        if (i5 != kRect)
                        {
                            int num6 = i5 / num1;
                            if (i5 - num6 * num1 == 0)
                                break;
                        }
                        else
                            break;
                    }
                }
            }
        }

        public static void DownSign(int kRect, double[] yRect, out int iCond)
        {
            int num1 = 1;
            int num2 = 0;
            iCond = 99;
            int int32_1 = Convert.ToInt32(yRect[1]);
            for (int i = 2; i <= kRect; ++i)
            {
                int int32_2 = Convert.ToInt32(yRect[i]);
                if (int32_1 == int32_2)
                {
                    ++num1;
                }
                else
                {
                    if (int32_1 > int32_2)
                        num2 = int32_1 - int32_2;
                    if (int32_2 > int32_1)
                        num2 = int32_2 - int32_1;
                    if (num2 <= 2)
                        ++num1;
                    else
                        break;
                }
            }
            int num3 = Convert.ToInt32(yRect[num1 + 1]) - int32_1;
            int num4 = kRect / num1;
            if (kRect - num4 * num1 > 0)
                ++num4;
            if (Convert.ToInt32(yRect[1]) >= 5)
            {
                iCond = 0;
            }
            else
            {
                int num5 = num1;
                int i1 = -num1 + 1;
                for (int i2 = 1; i2 <= num4; ++i2)
                {
                    i1 += num1;
                    int i3 = i1;
                    yRect[i1] = yRect[i1] + 1.0 * (double)num3;
                    if (i1 == kRect)
                        break;
                    for (int i4 = 1; i4 <= num5; ++i4)
                    {
                        ++i3;
                        yRect[i3] = yRect[i3] + 1.0 * (double)num3;
                        if (i3 != kRect)
                        {
                            int num6 = i3 / num1;
                            if (i3 - num6 * num1 == 0)
                                break;
                        }
                        else
                            break;
                    }
                }
            }
        }

        public static void SelItemPoly(
          string fitemPoly,
          int nSelect,
          out int iLong,
          out int iWid,
          out int iHei,
          out int kPix,
          int[] ixSqu,
          int[] iySqu,
          int[] nColor,
          out string sTxt,
          out int mClr)
        {
            iLong = 0;
            iWid = 0;
            iHei = 0;
            kPix = 0;
            mClr = 0;
            sTxt = "";
            if (nSelect == 0 || !File.Exists(fitemPoly))
                return;
            FileStream input = new FileStream(fitemPoly, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            try
            {
                for (int i1 = 1; i1 <= nSelect; ++i1)
                {
                    binaryReader.ReadString();
                    iLong = binaryReader.ReadInt32();
                    if (iLong == 0)
                    {
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        iWid = binaryReader.ReadInt32();
                        iHei = binaryReader.ReadInt32();
                        kPix = binaryReader.ReadInt32();
                        if (kPix > 0)
                        {
                            for (int i2 = 1; i2 <= kPix; ++i2)
                            {
                                ixSqu[i2] = binaryReader.ReadInt32();
                                iySqu[i2] = binaryReader.ReadInt32();
                                nColor[i2] = binaryReader.ReadInt32();
                            }
                        }
                    }
                    if (iLong > 0)
                    {
                        binaryReader.ReadInt32();
                        mClr = binaryReader.ReadInt32();
                        sTxt = binaryReader.ReadString();
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        iWid = binaryReader.ReadInt32();
                        iHei = binaryReader.ReadInt32();
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            binaryReader.Close();
            input.Close();
        }

        public static void RectSelect(
          double xSel,
          double ySel,
          int kRect,
          int[] nRect,
          double[] xRect,
          double[] yRect,
          int idx,
          int idy,
          out int numRect)
        {
            double[] x = new double[6];
            double[] y = new double[6];
            numRect = 0;
            for (int i = 1; i <= kRect; ++i)
            {
                x[0] = xRect[i];
                y[0] = yRect[i];
                x[1] = xRect[i] + 1.0 * (double)idx;
                y[1] = yRect[i];
                x[2] = x[1];
                y[2] = y[1] + 1.0 * (double)idy;
                x[3] = xRect[i];
                y[3] = y[2];
                x[4] = xRect[i];
                y[4] = yRect[i];
                if (in_out(4, ref x, ref y, xSel, ySel) != 0)
                {
                    numRect = nRect[i];
                    break;
                }
            }
        }

        public static void DrawText(
          PaintEventArgs e,
          string sText,
          int hText,
          int ixh,
          int iyh,
          int mColor,
          SolidBrush[] brColor)
        {
            if (sText == "")
                return;
            if (mColor == 0)
                mColor = 1;
            if (hText < 5)
                hText = 5;
            Graphics graphics = e.Graphics;
            Font font = new Font("Arial", (float)hText, FontStyle.Bold);
            SolidBrush solidBrush = brColor[mColor];
            graphics.DrawString(sText, font, (Brush)solidBrush, (float)ixh, (float)iyh);
        }

        public static int in_out(int k, ref double[] x, ref double[] y, double xt, double yt)
        {
            int num1 = 0;
            double num2 = 3.1415926;
            double num3 = 2.0 * num2;
            int kArray = 999999;
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            if (k > kArray)
            {
                int num4 = (int)MessageBox.Show("Индекс массива in_out");
                return num1;
            }
            double num5 = x[0] - x[k];
            double num6 = y[0] - y[k];
            if (Math.Sqrt(num5 * num5 + num6 * num6) > 0.01)
            {
                ++k;
                x[k] = x[0];
                y[k] = y[0];
            }
            int num7 = k - 1;
            double y1 = y[0] - yt;
            double x1 = x[0] - xt;
            double y2 = y[k] - yt;
            double x2 = x[k] - xt;
            if (Math.Abs(y1) < 0.001 && Math.Abs(x1) < 0.001 || Math.Abs(y2) < 0.001 && Math.Abs(x2) < 0.001)
                return 0;
            double num8 = Math.Atan2(y1, x1);
            if (num8 < 0.0)
                num8 += num3;
            double num9 = Math.Atan2(y2, x2);
            if (num9 < 0.0)
                num9 += num3;
            double num10 = num8 - num9;
            for (int i = 0; i <= num7; ++i)
            {
                double y3 = y[i + 1] - yt;
                double x3 = x[i + 1] - xt;
                double y4 = y[i] - yt;
                double x4 = x[i] - xt;
                if (Math.Abs(y3) < 0.001 && Math.Abs(x3) < 0.001 || Math.Abs(y4) < 0.001 && Math.Abs(x4) < 0.001)
                    return 0;
                double num11 = Math.Atan2(y3, x3);
                if (num11 < 0.0)
                    num11 += num3;
                double num12 = Math.Atan2(y4, x4);
                if (num12 < 0.0)
                    num12 += num3;
                double num13 = num11 - num12;
                if (Math.Abs(num13) > num2)
                    num13 -= num3 * Math.Abs(num13) / num13;
                num10 += num13;
            }
            if (Math.Abs(num10) > 6.2831)
                num1 = 1;
            return num1;
        }

        public static void GridLine(
          int kPxy,
          double[] x1Pix,
          double[] y1Pix,
          double[] x2Pix,
          double[] y2Pix,
          double x1Line,
          double y1Line,
          double x2Line,
          double y2Line,
          out int kCell,
          double[] xCell,
          double[] yCell,
          out int iCondish)
        {
            double[] numArray1 = new double[10];
            double[] numArray2 = new double[10];
            iCondish = 0;
            kCell = 0;
            int kArray = 999999;
            doubleArray(xCell, ref kArray);
            doubleArray(yCell, ref kArray);
            int num1 = kArray - 10;
            double ym;
            double xm = ym = 0.0;
            double x1 = x1Line;
            double y1 = y1Line;
            double x2 = x2Line;
            double y2 = y2Line;
            double num2 = x2 - x1;
            double num3 = y2 - y1;
            if (Math.Sqrt(num2 * num2 + num3 * num3) < 0.1)
                return;
            for (int i1 = 1; i1 <= kPxy; ++i1)
            {
                int num4 = 0;
                int num5 = 4;
                numArray1[0] = x1Pix[i1];
                numArray2[0] = y1Pix[i1];
                numArray1[1] = x1Pix[i1];
                numArray2[1] = y2Pix[i1];
                numArray1[2] = x2Pix[i1];
                numArray2[2] = y2Pix[i1];
                numArray1[3] = x2Pix[i1];
                numArray2[3] = y1Pix[i1];
                numArray1[4] = x1Pix[i1];
                numArray2[4] = y1Pix[i1];
                for (int i2 = 1; i2 <= num5; ++i2)
                {
                    double x3 = numArray1[i2 - 1];
                    double y3 = numArray2[i2 - 1];
                    double x4 = numArray1[i2];
                    double y4 = numArray2[i2];
                    int ip = 1;
                    TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out xm, out ym, ref ip);
                    if (ip < 0)
                        iCondish = -99;
                    else if (xm != 0.0 && ym != 0.0)
                        ++num4;
                }
                if (num4 > 0)
                {
                    for (int i3 = 0; i3 <= num5; ++i3)
                    {
                        ++kCell;
                        if (kCell > num1)
                        {
                            int num6 = (int)MessageBox.Show("Индекс массива GridLine");
                            return;
                        }
                        xCell[kCell] = numArray1[i3];
                        yCell[kCell] = numArray2[i3];
                    }
                }
            }
        }

        public static void GridRectangle(
          int iParam,
          int kx,
          int[] ixPix,
          int ky,
          int[] iyPix,
          out int kCell,
          double[] xCell,
          double[] yCell)
        {
            kCell = 0;
            int kArray = 999999;
            doubleArray(xCell, ref kArray);
            doubleArray(yCell, ref kArray);
            int num1 = kArray - 10;
            int num2;
            int num3 = num2 = 0;
            int num4 = num2;
            int num5 = num2;
            int num6 = num2;
            if (iParam == 1)
            {
                for (int i1 = 1; i1 <= 2; ++i1)
                {
                    if (i1 == 1)
                    {
                        num6 = iyPix[1];
                        num5 = iyPix[2];
                    }
                    if (i1 == 2)
                    {
                        num6 = iyPix[ky - 1];
                        num5 = iyPix[ky];
                    }
                    for (int i2 = 2; i2 <= kx; ++i2)
                    {
                        num4 = ixPix[i2 - 1];
                        num3 = ixPix[i2];
                        ++kCell;
                        if (kCell > num1)
                        {
                            int num7 = (int)MessageBox.Show("Индекс массива GridRectangle");
                            return;
                        }
                        xCell[kCell] = 1.0 * (double)num4;
                        yCell[kCell] = 1.0 * (double)num6;
                        ++kCell;
                        xCell[kCell] = 1.0 * (double)num4;
                        yCell[kCell] = 1.0 * (double)num5;
                        ++kCell;
                        xCell[kCell] = 1.0 * (double)num3;
                        yCell[kCell] = 1.0 * (double)num5;
                        ++kCell;
                        xCell[kCell] = 1.0 * (double)num3;
                        yCell[kCell] = 1.0 * (double)num6;
                        ++kCell;
                        xCell[kCell] = 1.0 * (double)num4;
                        yCell[kCell] = 1.0 * (double)num6;
                    }
                }
                for (int i3 = 1; i3 <= 2; ++i3)
                {
                    if (i3 == 1)
                    {
                        num4 = ixPix[1];
                        num3 = ixPix[2];
                    }
                    if (i3 == 2)
                    {
                        num4 = ixPix[kx - 1];
                        num3 = ixPix[kx];
                    }
                    for (int i4 = 2; i4 <= ky; ++i4)
                    {
                        int num8 = iyPix[i4 - 1];
                        int num9 = iyPix[i4];
                        ++kCell;
                        if (kCell > num1)
                        {
                            int num10 = (int)MessageBox.Show("Индекс массива GridRectangle");
                            return;
                        }
                        xCell[kCell] = 1.0 * (double)num4;
                        yCell[kCell] = 1.0 * (double)num8;
                        ++kCell;
                        xCell[kCell] = 1.0 * (double)num4;
                        yCell[kCell] = 1.0 * (double)num9;
                        ++kCell;
                        xCell[kCell] = 1.0 * (double)num3;
                        yCell[kCell] = 1.0 * (double)num9;
                        ++kCell;
                        xCell[kCell] = 1.0 * (double)num3;
                        yCell[kCell] = 1.0 * (double)num8;
                        ++kCell;
                        xCell[kCell] = 1.0 * (double)num4;
                        yCell[kCell] = 1.0 * (double)num8;
                    }
                }
            }
            if (iParam != 2)
                return;
            for (int i5 = 2; i5 <= ky; ++i5)
            {
                int num11 = iyPix[i5 - 1];
                int num12 = iyPix[i5];
                for (int i6 = 2; i6 <= kx; ++i6)
                {
                    int num13 = ixPix[i6 - 1];
                    int num14 = ixPix[i6];
                    ++kCell;
                    xCell[kCell] = 1.0 * (double)num13;
                    yCell[kCell] = 1.0 * (double)num11;
                    ++kCell;
                    xCell[kCell] = 1.0 * (double)num13;
                    yCell[kCell] = 1.0 * (double)num12;
                    ++kCell;
                    xCell[kCell] = 1.0 * (double)num14;
                    yCell[kCell] = 1.0 * (double)num12;
                    ++kCell;
                    xCell[kCell] = 1.0 * (double)num14;
                    yCell[kCell] = 1.0 * (double)num11;
                    ++kCell;
                    xCell[kCell] = 1.0 * (double)num13;
                    yCell[kCell] = 1.0 * (double)num11;
                }
            }
        }

        public static void GridEllipse(
          int iParam,
          int kx,
          int[] ixPix,
          int ky,
          int[] iyPix,
          int kPxy,
          double[] x1Pix,
          double[] y1Pix,
          double[] x2Pix,
          double[] y2Pix,
          out int kCell,
          double[] xCell,
          double[] yCell,
          out int ke,
          double[] xe,
          double[] ye,
          double[] xr,
          double[] yr,
          out int iCond)
        {
            double[] numArray1 = new double[10];
            double[] numArray2 = new double[10];
            iCond = 0;
            ke = 0;
            kCell = 0;
            int kArray = 999999;
            doubleArray(xCell, ref kArray);
            doubleArray(yCell, ref kArray);
            doubleArray(xe, ref kArray);
            doubleArray(ye, ref kArray);
            int num1 = kArray - 10;
            double num2 = 0.5 * (double)(ixPix[1] + ixPix[2]);
            double num3 = 0.5 * (double)(iyPix[1] + iyPix[2]);
            double num4 = 0.5 * (double)(ixPix[kx - 1] + ixPix[kx]);
            double num5 = 0.5 * (double)(iyPix[ky - 1] + iyPix[ky]);
            xe[0] = num2;
            ye[0] = 0.5 * (double)(iyPix[1] + iyPix[ky]);
            ke = 0;
            double num6 = 0.5 * (num4 - num2);
            double num7 = 0.5 * (num5 - num3);
            double num8 = 0.5 * (num2 + num4);
            double num9 = 0.5 * (num3 + num5);
            double num10 = 1.0 * (double)(ixPix[2] - ixPix[1]);
            int int32 = Convert.ToInt32(2.0 * num6 / num10);
            for (int i = 1; i <= int32; ++i)
            {
                double num11 = (double)i * num10 - num6;
                double num12 = Math.Sqrt((num6 * num6 * num7 * num7 - num7 * num7 * num11 * num11) / (num6 * num6));
                ++ke;
                if (ke > num1)
                {
                    int num13 = (int)MessageBox.Show("Индекс массива GridEllipse");
                    return;
                }
                xe[ke] = num8 + num11;
                ye[ke] = num9 - num12;
            }
            for (int i = 1; i <= int32; ++i)
            {
                double num14 = num6 - (double)i * num10;
                double num15 = Math.Sqrt((num6 * num6 * num7 * num7 - num7 * num7 * num14 * num14) / (num6 * num6));
                ++ke;
                if (ke > num1)
                {
                    int num16 = (int)MessageBox.Show("Индекс массива GridEllipse");
                    return;
                }
                xe[ke] = num8 + num14;
                ye[ke] = num9 + num15;
            }
            int kCell1 = 0;
            for (int i1 = 1; i1 <= ke; ++i1)
            {
                double x1Line = xe[i1 - 1];
                double y1Line = ye[i1 - 1];
                double x2Line = xe[i1];
                double y2Line = ye[i1];
                GridLine(kPxy, x1Pix, y1Pix, x2Pix, y2Pix, x1Line, y1Line, x2Line, y2Line, out kCell1, xr, yr, out iCond);
                if (iCond < 0)
                    return;
                if (kCell1 > 0)
                {
                    for (int i2 = 1; i2 <= kCell1; ++i2)
                    {
                        ++kCell;
                        if (kCell > num1)
                        {
                            int num17 = (int)MessageBox.Show("Индекс массива GridEllipse");
                            return;
                        }
                        xCell[kCell] = xr[i2];
                        yCell[kCell] = yr[i2];
                    }
                }
            }
            if (iParam != 2)
                return;
            for (int i3 = 1; i3 <= kPxy; ++i3)
            {
                int num18 = 4;
                numArray1[0] = x1Pix[i3];
                numArray2[0] = y1Pix[i3];
                numArray1[1] = x1Pix[i3];
                numArray2[1] = y2Pix[i3];
                numArray1[2] = x2Pix[i3];
                numArray2[2] = y2Pix[i3];
                numArray1[3] = x2Pix[i3];
                numArray2[3] = y1Pix[i3];
                numArray1[4] = numArray1[0];
                numArray2[4] = numArray2[0];
                int num19 = 0;
                for (int i4 = 0; i4 < num18; ++i4)
                {
                    if (in_out(ke, ref xe, ref ye, numArray1[i4], numArray2[i4]) > 0)
                        ++num19;
                }
                if (num19 == 4)
                {
                    for (int i5 = 0; i5 <= num18; ++i5)
                    {
                        ++kCell;
                        if (kCell > num1)
                        {
                            int num20 = (int)MessageBox.Show("Индекс массива GridEllipse");
                            return;
                        }
                        xCell[kCell] = numArray1[i5];
                        yCell[kCell] = numArray2[i5];
                    }
                }
            }
        }

        public static void GridArc(
          int iParam,
          int kx,
          int[] ixPix,
          int ky,
          int[] iyPix,
          int kPxy,
          double[] x1Pix,
          double[] y1Pix,
          double[] x2Pix,
          double[] y2Pix,
          out int kCell,
          double[] xCell,
          double[] yCell,
          out int ke,
          double[] xe,
          double[] ye,
          double[] xr,
          double[] yr,
          out int iCond)
        {
            iCond = 0;
            ke = 0;
            kCell = 0;
            int kArray = 999999;
            doubleArray(xCell, ref kArray);
            doubleArray(yCell, ref kArray);
            doubleArray(xe, ref kArray);
            doubleArray(ye, ref kArray);
            int num1 = kArray - 10;
            double num2 = 0.5 * (double)(ixPix[1] + ixPix[2]);
            double num3 = 0.5 * (double)(iyPix[1] + iyPix[2]);
            double num4 = 0.5 * (double)(ixPix[kx - 1] + ixPix[kx]);
            double num5 = 0.5 * (double)(iyPix[ky - 1] + iyPix[ky]);
            double num6 = num4 - num2;
            double num7 = 0.5 * (num4 - num2);
            double num8 = 0.5 * (num5 - num3);
            double num9 = 0.5 * (num2 + num4);
            double num10 = 0.5 * (num3 + num5);
            double num11 = 1.0 * (double)(ixPix[2] - ixPix[1]);
            Convert.ToInt32(num7 / num11);
            if (iParam == 1)
            {
                double num12 = num8;
                double num13 = num2 + num12;
                int int32 = Convert.ToInt32(num12 / num11);
                xr[0] = num2;
                yr[0] = num10;
                int i1 = 0;
                for (int i2 = 1; i2 <= int32; ++i2)
                {
                    double num14 = (double)i2 * num11 - num12;
                    double num15 = Math.Sqrt(num12 * num12 - num14 * num14);
                    if (num13 + num14 <= num4)
                    {
                        ++i1;
                        xr[i1] = num13 + num14;
                        yr[i1] = num10 + num15;
                    }
                    else
                        break;
                }
                int i3 = i1 + 1;
                for (int i4 = 0; i4 <= i1; ++i4)
                {
                    --i3;
                    xe[i4] = xr[i3];
                    ye[i4] = yr[i3];
                }
                ke = i1;
                for (int i5 = 1; i5 <= int32; ++i5)
                {
                    double num16 = (double)i5 * num11 - num12;
                    double num17 = Math.Sqrt(num12 * num12 - num16 * num16);
                    if (num13 + num16 <= num4)
                    {
                        ++ke;
                        if (ke > num1)
                        {
                            int num18 = (int)MessageBox.Show("Индекс массива GridArc");
                            return;
                        }
                        xe[ke] = num13 + num16;
                        ye[ke] = num10 - num17;
                    }
                    else
                        break;
                }
            }
            if (iParam == 2)
            {
                double num19 = num8;
                int int32 = Convert.ToInt32(num19 / num11);
                double num20 = num4 - num19;
                xr[0] = num4;
                yr[0] = num10;
                int i6 = 0;
                for (int i7 = 1; i7 <= int32; ++i7)
                {
                    double num21 = num19 - (double)i7 * num11;
                    double num22 = Math.Sqrt(num19 * num19 - num21 * num21);
                    if (num20 + num21 >= num2)
                    {
                        ++i6;
                        xr[i6] = num20 + num21;
                        yr[i6] = num10 - num22;
                    }
                    else
                        break;
                }
                int i8 = i6 + 1;
                for (int i9 = 0; i9 <= i6; ++i9)
                {
                    --i8;
                    xe[i9] = xr[i8];
                    ye[i9] = yr[i8];
                }
                ke = i6;
                for (int i10 = 1; i10 <= int32; ++i10)
                {
                    double num23 = num19 - (double)i10 * num11;
                    double num24 = Math.Sqrt(num19 * num19 - num23 * num23);
                    if (num20 + num23 >= num2)
                    {
                        ++ke;
                        if (ke > num1)
                        {
                            int num25 = (int)MessageBox.Show("Индекс массива GridArc");
                            return;
                        }
                        xe[ke] = num20 + num23;
                        ye[ke] = num10 + num24;
                    }
                    else
                        break;
                }
            }
            if (iParam == 3)
            {
                double num26 = num7;
                double num27 = num3 + num26;
                int int32 = Convert.ToInt32(num26 / num11);
                xe[0] = num2;
                ye[0] = num27;
                ke = 0;
                for (int i = 1; i <= int32; ++i)
                {
                    double num28 = (double)i * num11 - num26;
                    double num29 = Math.Sqrt(num26 * num26 - num28 * num28);
                    ++ke;
                    xe[ke] = num9 + num28;
                    ye[ke] = num27 - num29;
                }
                double num30 = xe[ke];
                xr[0] = num4;
                yr[0] = num27;
                int i11 = 0;
                for (int i12 = 1; i12 <= int32; ++i12)
                {
                    double num31 = num26 - (double)i12 * num11;
                    double num32 = Math.Sqrt(num26 * num26 - num31 * num31);
                    ++i11;
                    xr[i11] = num9 + num31;
                    yr[i11] = num27 - num32;
                }
                int i13 = i11 + 1;
                for (int i14 = 0; i14 <= i11; ++i14)
                {
                    --i13;
                    if (xr[i13] > num30)
                    {
                        ++ke;
                        if (ke > num1)
                        {
                            int num33 = (int)MessageBox.Show("Индекс массива GridArc");
                            return;
                        }
                        xe[ke] = xr[i13];
                        ye[ke] = yr[i13];
                    }
                }
                int i15 = -1;
                for (int i16 = 0; i16 <= ke; ++i16)
                {
                    if (ye[i16] <= num5)
                    {
                        ++i15;
                        xe[i15] = xe[i16];
                        ye[i15] = ye[i16];
                    }
                }
                ke = i15;
            }
            if (iParam == 4)
            {
                double num34 = num7;
                double num35 = num5 - num34;
                int int32 = Convert.ToInt32(num34 / num11);
                xe[0] = num2;
                ye[0] = num35;
                ke = 0;
                for (int i = 1; i <= int32; ++i)
                {
                    double num36 = (double)i * num11 - num34;
                    double num37 = Math.Sqrt(num34 * num34 - num36 * num36);
                    ++ke;
                    if (ke > num1)
                    {
                        int num38 = (int)MessageBox.Show("Индекс массива GridArc");
                        return;
                    }
                    xe[ke] = num9 + num36;
                    ye[ke] = num35 + num37;
                }
                double num39 = xe[ke];
                xr[0] = num4;
                yr[0] = num35;
                int i17 = 0;
                for (int i18 = 1; i18 <= int32; ++i18)
                {
                    double num40 = num34 - (double)i18 * num11;
                    double num41 = Math.Sqrt(num34 * num34 - num40 * num40);
                    ++i17;
                    xr[i17] = num9 + num40;
                    yr[i17] = num35 + num41;
                }
                int i19 = i17 + 1;
                for (int i20 = 0; i20 <= i17; ++i20)
                {
                    --i19;
                    if (xr[i19] > num39)
                    {
                        ++ke;
                        if (ke > num1)
                        {
                            int num42 = (int)MessageBox.Show("Индекс массива GridArc");
                            return;
                        }
                        xe[ke] = xr[i19];
                        ye[ke] = yr[i19];
                    }
                }
                int i21 = -1;
                for (int i22 = 0; i22 <= ke; ++i22)
                {
                    if (ye[i22] >= num3)
                    {
                        ++i21;
                        xe[i21] = xe[i22];
                        ye[i21] = ye[i22];
                    }
                }
                ke = i21;
            }
            int kCell1 = 0;
            for (int i23 = 1; i23 <= ke; ++i23)
            {
                double num43 = xe[i23 - 1];
                double num44 = ye[i23 - 1];
                double num45 = xe[i23];
                double num46 = ye[i23];
                if (!double.IsNaN(num43) && !double.IsNaN(num44) && !double.IsNaN(num45) && !double.IsNaN(num46))
                {
                    GridLine(kPxy, x1Pix, y1Pix, x2Pix, y2Pix, num43, num44, num45, num46, out kCell1, xr, yr, out iCond);
                    if (iCond < 0)
                        break;
                    if (kCell1 > 0)
                    {
                        for (int i24 = 1; i24 <= kCell1; ++i24)
                        {
                            ++kCell;
                            if (kCell > num1)
                            {
                                int num47 = (int)MessageBox.Show("Индекс массива GridArc");
                                return;
                            }
                            xCell[kCell] = xr[i24];
                            yCell[kCell] = yr[i24];
                        }
                    }
                }
            }
        }

        public static void GridTriangle(
          int iParam,
          int kx,
          int[] ixPix,
          int ky,
          int[] iyPix,
          int kPxy,
          double[] x1Pix,
          double[] y1Pix,
          double[] x2Pix,
          double[] y2Pix,
          out int kCell,
          double[] xCell,
          double[] yCell,
          out int ke,
          double[] xe,
          double[] ye,
          double[] xr,
          double[] yr,
          out int iCond)
        {
            double[] numArray1 = new double[10];
            double[] numArray2 = new double[10];
            iCond = 0;
            ke = 0;
            kCell = 0;
            int kArray = 999999;
            doubleArray(xCell, ref kArray);
            doubleArray(yCell, ref kArray);
            doubleArray(xe, ref kArray);
            doubleArray(ye, ref kArray);
            int num1 = kArray - 10;
            double num2 = 0.5 * (double)(ixPix[1] + ixPix[2]);
            double num3 = 0.5 * (double)(iyPix[1] + iyPix[2]);
            double num4 = 0.5 * (double)(ixPix[kx - 1] + ixPix[kx]);
            double num5 = 0.5 * (double)(iyPix[ky - 1] + iyPix[ky]);
            if (iParam == 1 || iParam == 2)
            {
                ke = 3;
                xe[0] = num2;
                ye[0] = num3;
                xe[1] = num4;
                ye[1] = 0.5 * (num3 + num5);
                xe[2] = num2;
                ye[2] = num5;
                xe[3] = num2;
                ye[3] = num3;
            }
            if (iParam == 3 || iParam == 4)
            {
                ke = 3;
                xe[0] = num2;
                ye[0] = 0.5 * (num3 + num5);
                xe[1] = num4;
                ye[1] = num3;
                xe[2] = num4;
                ye[2] = num5;
                xe[3] = num2;
                ye[3] = 0.5 * (num3 + num5);
            }
            if (iParam == 5 || iParam == 6)
            {
                ke = 3;
                xe[0] = num2;
                ye[0] = num3;
                xe[1] = num4;
                ye[1] = num3;
                xe[2] = 0.5 * (num2 + num4);
                ye[2] = num5;
                xe[3] = num2;
                ye[3] = num3;
            }
            if (iParam == 7 || iParam == 8)
            {
                ke = 3;
                xe[0] = num2;
                ye[0] = num5;
                xe[1] = 0.5 * (num2 + num4);
                ye[1] = num3;
                xe[2] = num4;
                ye[2] = num5;
                xe[3] = num2;
                ye[3] = num5;
            }
            int kCell1 = 0;
            for (int i1 = 1; i1 <= ke; ++i1)
            {
                double x1Line = xe[i1 - 1];
                double y1Line = ye[i1 - 1];
                double x2Line = xe[i1];
                double y2Line = ye[i1];
                GridLine(kPxy, x1Pix, y1Pix, x2Pix, y2Pix, x1Line, y1Line, x2Line, y2Line, out kCell1, xr, yr, out iCond);
                if (iCond < 0)
                    return;
                if (kCell1 > 0)
                {
                    for (int i2 = 1; i2 <= kCell1; ++i2)
                    {
                        ++kCell;
                        if (kCell > num1)
                        {
                            int num6 = (int)MessageBox.Show("Индекс массива GridTriangle");
                            return;
                        }
                        xCell[kCell] = xr[i2];
                        yCell[kCell] = yr[i2];
                    }
                }
            }
            if (iParam != 2 && iParam != 4 && iParam != 6 && iParam != 8)
                return;
            for (int i3 = 1; i3 <= kPxy; ++i3)
            {
                int num7 = 4;
                numArray1[0] = x1Pix[i3];
                numArray2[0] = y1Pix[i3];
                numArray1[1] = x1Pix[i3];
                numArray2[1] = y2Pix[i3];
                numArray1[2] = x2Pix[i3];
                numArray2[2] = y2Pix[i3];
                numArray1[3] = x2Pix[i3];
                numArray2[3] = y1Pix[i3];
                numArray1[4] = numArray1[0];
                numArray2[4] = numArray2[0];
                int num8 = 0;
                for (int i4 = 0; i4 < num7; ++i4)
                {
                    if (in_out(ke, ref xe, ref ye, numArray1[i4], numArray2[i4]) > 0)
                        ++num8;
                }
                if (num8 == 4)
                {
                    for (int i5 = 0; i5 <= num7; ++i5)
                    {
                        ++kCell;
                        if (kCell > num1)
                        {
                            int num9 = (int)MessageBox.Show("Индекс массива GridTriangle");
                            return;
                        }
                        xCell[kCell] = numArray1[i5];
                        yCell[kCell] = numArray2[i5];
                    }
                }
            }
        }

        public static void GridHexagon(
          int iParam,
          int kx,
          int[] ixPix,
          int ky,
          int[] iyPix,
          int kPxy,
          double[] x1Pix,
          double[] y1Pix,
          double[] x2Pix,
          double[] y2Pix,
          out int kCell,
          double[] xCell,
          double[] yCell,
          out int ke,
          double[] xe,
          double[] ye,
          double[] xr,
          double[] yr,
          out int iCond)
        {
            double[] numArray1 = new double[10];
            double[] numArray2 = new double[10];
            iCond = 0;
            ke = 0;
            kCell = 0;
            int kArray = 999999;
            doubleArray(xCell, ref kArray);
            doubleArray(yCell, ref kArray);
            doubleArray(xe, ref kArray);
            doubleArray(ye, ref kArray);
            int num1 = kArray - 10;
            double x1 = 0.5 * (double)(ixPix[1] + ixPix[2]);
            double y1 = 0.5 * (double)(iyPix[1] + iyPix[2]);
            double x2 = 0.5 * (double)(ixPix[kx - 1] + ixPix[kx]);
            double y2 = 0.5 * (double)(iyPix[ky - 1] + iyPix[ky]);
            double num2 = x2 - x1;
            double num3 = y2 - y1;
            if (num2 > num3)
                x2 = x1 + num3;
            if (num3 > num2)
                y2 = y1 + num2;
            double shag = 1.0 * (double)(ixPix[2] - ixPix[1]);
            Hexagon(x1, y1, x2, y2, shag, out ke, xe, ye);
            int kCell1 = 0;
            for (int i1 = 1; i1 <= ke; ++i1)
            {
                double x1Line = xe[i1 - 1];
                double y1Line = ye[i1 - 1];
                double x2Line = xe[i1];
                double y2Line = ye[i1];
                GridLine(kPxy, x1Pix, y1Pix, x2Pix, y2Pix, x1Line, y1Line, x2Line, y2Line, out kCell1, xr, yr, out iCond);
                if (iCond < 0)
                    return;
                if (kCell1 > 0)
                {
                    for (int i2 = 1; i2 <= kCell1; ++i2)
                    {
                        ++kCell;
                        if (kCell > num1)
                        {
                            int num4 = (int)MessageBox.Show("Индекс массива GridHexagon");
                            return;
                        }
                        xCell[kCell] = xr[i2];
                        yCell[kCell] = yr[i2];
                    }
                }
            }
            if (iParam != 2)
                return;
            for (int i3 = 1; i3 <= kPxy; ++i3)
            {
                int num5 = 4;
                numArray1[0] = x1Pix[i3];
                numArray2[0] = y1Pix[i3];
                numArray1[1] = x1Pix[i3];
                numArray2[1] = y2Pix[i3];
                numArray1[2] = x2Pix[i3];
                numArray2[2] = y2Pix[i3];
                numArray1[3] = x2Pix[i3];
                numArray2[3] = y1Pix[i3];
                numArray1[4] = numArray1[0];
                numArray2[4] = numArray2[0];
                int num6 = 0;
                for (int i4 = 0; i4 < num5; ++i4)
                {
                    if (in_out(ke, ref xe, ref ye, numArray1[i4], numArray2[i4]) > 0)
                        ++num6;
                }
                if (num6 == 4)
                {
                    for (int i5 = 0; i5 <= num5; ++i5)
                    {
                        ++kCell;
                        if (kCell > num1)
                        {
                            int num7 = (int)MessageBox.Show("Индекс массива GridHexagon");
                            return;
                        }
                        xCell[kCell] = numArray1[i5];
                        yCell[kCell] = numArray2[i5];
                    }
                }
            }
        }

        public static void Hexagon(
          double x1,
          double y1,
          double x2,
          double y2,
          double shag,
          out int ke,
          double[] xe,
          double[] ye)
        {
            ke = 0;
            int kArray = 999999;
            doubleArray(xe, ref kArray);
            doubleArray(ye, ref kArray);
            int num1 = kArray - 10;
            double num2 = 0.5 * (x2 - x1) - shag;
            double num3 = 0.5 * (x2 - x1 - num2);
            xe[0] = x1 + num3;
            ye[0] = y2;
            ++ke;
            if (ke > num1)
            {
                int num4 = (int)MessageBox.Show("Индекс массива Hexagon");
            }
            else
            {
                xe[ke] = xe[0] + num2;
                ye[ke] = y2;
                ++ke;
                xe[ke] = x2;
                ye[ke] = 0.5 * (y1 + y2);
                double num5 = xe[0];
                double num6 = y1;
                double num7 = num5 + num2;
                double num8 = y1;
                ++ke;
                xe[ke] = num7;
                ye[ke] = num8;
                ++ke;
                xe[ke] = num5;
                ye[ke] = num6;
                ++ke;
                xe[ke] = x1;
                ye[ke] = 0.5 * (y1 + y2);
                ++ke;
                xe[ke] = xe[0];
                ye[ke] = ye[0];
            }
        }

        public static void GridChange(
          ref int kSqu,
          ref double[] xSqu,
          ref double[] ySqu,
          ref int[] numCol,
          double xDown,
          double yDown,
          int[] ind,
          out int iCond)
        {
            double[] x = new double[10];
            double[] y = new double[10];
            iCond = 0;
            int num1 = kSqu / 5;
            int i1 = -4;
            int i2 = 0;
            for (int i3 = 1; i3 <= num1; ++i3)
            {
                i1 += 5;
                x[0] = xSqu[i1];
                y[0] = ySqu[i1];
                x[1] = xSqu[i1 + 1];
                y[1] = ySqu[i1 + 1];
                x[2] = xSqu[i1 + 2];
                y[2] = ySqu[i1 + 2];
                x[3] = xSqu[i1 + 3];
                y[3] = ySqu[i1 + 3];
                x[4] = xSqu[i1 + 4];
                y[4] = ySqu[i1 + 4];
                if (in_out(4, ref x, ref y, xDown, yDown) > 0)
                {
                    int i4 = i2 + 1;
                    ind[i4] = i1;
                    int i5 = i4 + 1;
                    ind[i5] = i1 + 1;
                    int i6 = i5 + 1;
                    ind[i6] = i1 + 2;
                    int i7 = i6 + 1;
                    ind[i7] = i1 + 3;
                    i2 = i7 + 1;
                    ind[i2] = i1 + 4;
                    ++iCond;
                }
            }
            int i8 = 0;
            if (i2 <= 0)
                return;
            for (int i9 = 1; i9 <= kSqu; ++i9)
            {
                int num2 = 0;
                for (int i10 = 1; i10 <= i2; ++i10)
                {
                    if (ind[i10] == i9)
                    {
                        ++num2;
                        break;
                    }
                }
                if (num2 <= 0)
                {
                    ++i8;
                    xSqu[i8] = xSqu[i9];
                    ySqu[i8] = ySqu[i9];
                    numCol[i8] = numCol[i9];
                }
            }
            kSqu = i8;
        }

        public static void GridPoint(
          int kPxy,
          double[] x1Pix,
          double[] y1Pix,
          double[] x2Pix,
          double[] y2Pix,
          double xt,
          double yt,
          out int kCell,
          double[] xCell,
          double[] yCell)
        {
            double[] x = new double[10];
            double[] y = new double[10];
            kCell = 0;
            int kArray = 999999;
            doubleArray(xCell, ref kArray);
            doubleArray(yCell, ref kArray);
            int num1 = kArray - 10;
            for (int i1 = 1; i1 <= kPxy; ++i1)
            {
                int k = 4;
                x[0] = x1Pix[i1];
                y[0] = y1Pix[i1];
                x[1] = x1Pix[i1];
                y[1] = y2Pix[i1];
                x[2] = x2Pix[i1];
                y[2] = y2Pix[i1];
                x[3] = x2Pix[i1];
                y[3] = y1Pix[i1];
                x[4] = x1Pix[i1];
                y[4] = y1Pix[i1];
                if (in_out(k, ref x, ref y, xt, yt) > 0)
                {
                    for (int i2 = 0; i2 <= k; ++i2)
                    {
                        ++kCell;
                        if (kCell > num1)
                        {
                            int num2 = (int)MessageBox.Show("Индекс массива GridLine");
                            break;
                        }
                        xCell[kCell] = x[i2];
                        yCell[kCell] = y[i2];
                    }
                    break;
                }
            }
        }

        public static void GridCreate(
          int iParam,
          int iWidth,
          int iHeight,
          double wSign,
          double hSign,
          double sPixel,
          out int kx,
          int[] ixPix,
          out int ky,
          int[] iyPix,
          out int kPxy,
          double[] x1Pix,
          double[] y1Pix,
          double[] x2Pix,
          double[] y2Pix,
          out int ix1Grid,
          out int iy1Grid,
          out int ix2Grid,
          out int iy2Grid,
          int pixWid,
          int pixHei)
        {
            kPxy = 0;
            kx = 0;
            ky = 0;
            ix1Grid = 999999;
            iy1Grid = 999999;
            ix2Grid = -999999;
            iy2Grid = -999999;
            int num1 = 15;
            int num2 = 15;
            int int32_1 = Convert.ToInt32(wSign / sPixel);
            int int32_2 = Convert.ToInt32(hSign / sPixel);
            if (int32_1 > 90 || int32_2 > 90)
            {
                int num3 = (int)MessageBox.Show("Уменьшить размер символа", "Создание сетки", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }
            else if (int32_1 * int32_2 > 3600)
            {
                int num4 = (int)MessageBox.Show("Уменьшить размер символа", "Создание сетки", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }
            else
            {
                int num5 = iWidth / 3;
                int num6 = iHeight / 3;
                for (int i = 1; i <= 10; ++i)
                {
                    num1 -= 2;
                    if (num1 == 5 || num5 > int32_1 * num1)
                        break;
                }
                for (int i = 1; i <= 10; ++i)
                {
                    num2 -= 2;
                    if (num2 == 5 || num6 > int32_2 * num2)
                        break;
                }
                if (num1 < num2)
                    num2 = num1;
                if (num2 < num1)
                    num1 = num2;
                kx = int32_1 + 1;
                int num7 = pixWid - (kx + 1) * num1 - 10;
                if (iParam == 2)
                    num7 = pixWid - (kx + 1) * num1;
                if (iParam == 3)
                    num7 = pixWid - (kx + 1) * num1;
                if (iParam == 4)
                    num7 = pixWid - (kx + 1) * num1;
                ixPix[1] = num7;
                for (int i = 2; i <= kx; ++i)
                {
                    num7 += num1;
                    ixPix[i] = num7;
                }
                ky = int32_2 + 1;
                int num8 = 20;
                iyPix[1] = num8;
                for (int i = 2; i <= ky; ++i)
                {
                    num8 += num2;
                    iyPix[i] = num8;
                }
                for (int i = 1; i <= kx; ++i)
                {
                    if (ixPix[i] < ix1Grid)
                        ix1Grid = ixPix[i];
                    if (ixPix[i] > ix2Grid)
                        ix2Grid = ixPix[i];
                }
                for (int i = 1; i <= ky; ++i)
                {
                    if (iyPix[i] < iy1Grid)
                        iy1Grid = iyPix[i];
                    if (iyPix[i] > iy2Grid)
                        iy2Grid = iyPix[i];
                }
                for (int i1 = 2; i1 <= ky; ++i1)
                {
                    double num9 = 1.0 * (double)iyPix[i1 - 1];
                    double num10 = 1.0 * (double)iyPix[i1];
                    for (int i2 = 2; i2 <= kx; ++i2)
                    {
                        double num11 = 1.0 * (double)ixPix[i2 - 1];
                        double num12 = 1.0 * (double)ixPix[i2];
                        ++kPxy;
                        x1Pix[kPxy] = num11;
                        y1Pix[kPxy] = num9;
                        x2Pix[kPxy] = num12;
                        y2Pix[kPxy] = num10;
                    }
                }
            }
        }

        public static void GridDraw(PaintEventArgs e, int kx, int[] ixPix, int ky, int[] iyPix)
        {
            Graphics graphics = e.Graphics;
            Pen pen = new Pen(Color.Gray, 1f);
            int y1_1 = iyPix[1];
            int y2_1 = iyPix[ky];
            for (int i = 1; i <= kx; ++i)
            {
                int x1 = ixPix[i];
                int x2 = ixPix[i];
                graphics.DrawLine(pen, x1, y1_1, x2, y2_1);
            }
            int x1_1 = ixPix[1];
            int x2_1 = ixPix[kx];
            for (int i = 1; i <= ky; ++i)
            {
                int y1_2 = iyPix[i];
                int y2_2 = iyPix[i];
                graphics.DrawLine(pen, x1_1, y1_2, x2_1, y2_2);
            }
        }

        public static void intArray(int[] nArray, ref int kArray)
        {
            if (nArray.Length >= kArray)
                return;
            kArray = nArray.Length;
        }

        public static void stringArray(string[] sArray, ref int kArray)
        {
            if (sArray.Length >= kArray)
                return;
            kArray = sArray.Length;
        }

        public static void doubleArray(double[] dArray, ref int kArray)
        {
            if (dArray.Length >= kArray)
                return;
            kArray = dArray.Length;
        }

        //public static void DriveList(out int kDrive, out string[] sDrive)
        //{
        //    kDrive = 0;
        //    sDrive = new string[10]
        //    {
        //"",
        //"",
        //"",
        //"",
        //"",
        //"",
        //"",
        //"",
        //"",
        //""
        //    };
        //    foreach (DriveInfo drive in DriveInfo.GetDrives())
        //    {
        //        if (drive.Name[0] != 'A' && drive.Name[0] != 'a' && drive.Name[0] != 'B' && drive.Name[0] != 'b' && drive.IsReady && !(drive.DriveFormat == "CDUDF"))
        //        {
        //            ++kDrive;
        //            sDrive[kDrive] = drive.Name;
        //        }
        //    }
        //}

        public static void ShareString(
          string sLine,
          int kPart,
          char[] seps,
          out int k,
          out string[] sPart)
        {
            k = 0;
            sPart = new string[kPart];
            if (kPart < 1)
            {
                int num = (int)MessageBox.Show("Индекс массива ShareString");
            }
            else
            {
                string[] strArray = new string[kPart];
                sLine = sLine.Trim();
                foreach (string str in sLine.Split(seps))
                {
                    if (str.Length != 0 && !(str == ""))
                    {
                        ++k;
                        sPart[k] = str;
                    }
                }
            }
        }

        public static void SetColour(SolidBrush[] brColor, Pen[] pnColor)
        {
            brColor[0] = new SolidBrush(Color.Black);
            pnColor[0] = new Pen(Color.Black);
            brColor[1] = new SolidBrush(Color.Black);
            pnColor[1] = new Pen(Color.Black);
            brColor[2] = new SolidBrush(Color.Red);
            pnColor[2] = new Pen(Color.Red);
            brColor[3] = new SolidBrush(Color.Green);
            pnColor[3] = new Pen(Color.Green);
            brColor[4] = new SolidBrush(Color.Blue);
            pnColor[4] = new Pen(Color.Blue);
            brColor[5] = new SolidBrush(Color.Magenta);
            pnColor[5] = new Pen(Color.Magenta);
            brColor[6] = new SolidBrush(Color.Cyan);
            pnColor[6] = new Pen(Color.Cyan);
            brColor[7] = new SolidBrush(Color.Yellow);
            pnColor[7] = new Pen(Color.Yellow);
            brColor[8] = new SolidBrush(Color.Brown);
            pnColor[8] = new Pen(Color.Brown);
            brColor[9] = new SolidBrush(Color.Gray);
            pnColor[9] = new Pen(Color.Gray);
            brColor[10] = new SolidBrush(Color.Orange);
            pnColor[10] = new Pen(Color.Orange);
            brColor[11] = new SolidBrush(Color.Pink);
            pnColor[11] = new Pen(Color.Pink);
            brColor[12] = new SolidBrush(Color.Sienna);
            pnColor[12] = new Pen(Color.Sienna);
            brColor[13] = new SolidBrush(Color.Violet);
            pnColor[13] = new Pen(Color.Violet);
            brColor[14] = new SolidBrush(Color.Gold);
            pnColor[14] = new Pen(Color.Gold);
            brColor[15] = new SolidBrush(Color.Olive);
            pnColor[15] = new Pen(Color.Olive);
        }

        public static void CheckText(string sText, out double tText, out int iCond)
        {
            char ch1 = '.';
            char ch2 = '-';
            char ch3 = '+';
            tText = 0.0;
            iCond = 0;
            for (int i = 0; i < sText.Length; ++i)
            {
                if ((i != 0 || (int)sText[i] != (int)ch2 && (int)sText[i] != (int)ch3) && !char.IsDigit(sText[i]) && (int)sText[i] != (int)ch1)
                {
                    iCond = -99;
                    break;
                }
            }
            if (iCond != 0)
                return;
            tText = Convert.ToDouble(sText);
        }

        public static void TwoLine(
          double x1,
          double y1,
          double x3,
          double y3,
          double x2,
          double y2,
          double x4,
          double y4,
          out double xm,
          out double ym,
          ref int ip)
        {
            xm = ym = 0.0;
            if (double.IsNaN(x1) || double.IsNaN(y1) || double.IsNaN(x2) || double.IsNaN(y2) || double.IsNaN(x3) || double.IsNaN(y3) || double.IsNaN(x4) || double.IsNaN(y4))
            {
                ip = -99;
            }
            else
            {
                double num1;
                double num2 = num1 = 0.0;
                double num3;
                double num4 = num3 = 0.0;
                double num5 = num3;
                double num6 = num3;
                double num7 = num3;
                double num8 = 3.1415926;
                double num9 = x3 - x1;
                double num10 = y3 - y1;
                double num11 = Math.Sqrt(num9 * num9 + num10 * num10);
                double num12 = x4 - x1;
                double num13 = y4 - y1;
                double num14 = Math.Sqrt(num12 * num12 + num13 * num13);
                double num15 = x3 - x2;
                double num16 = y3 - y2;
                double num17 = Math.Sqrt(num15 * num15 + num16 * num16);
                double num18 = x4 - x2;
                double num19 = y4 - y2;
                double num20 = Math.Sqrt(num18 * num18 + num19 * num19);
                int num21 = 0;
                if (num11 < 0.003)
                    ++num21;
                if (num14 < 0.003)
                    ++num21;
                if (num17 < 0.003)
                    ++num21;
                if (num20 < 0.003)
                    ++num21;
                if (num21 > 1)
                {
                    xm = 0.0;
                    ym = 0.0;
                }
                else
                {
                    double num22 = x1 + x2 + x3 + x4;
                    double num23 = y1 + y2 + y3 + y4;
                    double num24 = num22 / 4.0;
                    double num25 = num23 / 4.0;
                    x1 -= num24;
                    x2 -= num24;
                    x3 -= num24;
                    x4 -= num24;
                    y1 -= num25;
                    y2 -= num25;
                    y3 -= num25;
                    y4 -= num25;
                    double num26 = x3 - x4;
                    double num27 = x2 - x1;
                    double num28 = y3 - y4;
                    double num29 = y2 - y1;
                    double num30 = y1 * x2 - x1 * y2;
                    double num31 = x3 * y4 - x4 * y3;
                    double num32 = num26 * num30 - num27 * num31;
                    double num33 = num27 * num28 - num26 * num29;
                    if (Math.Abs(num33) < 0.0001)
                        num33 = 0.0001;
                    double num34 = num32 / num33;
                    double num35 = (num28 * num30 - num29 * num31) / num33;
                    if (ip == 0)
                    {
                        double num36 = num34 + num24;
                        double num37 = num35 + num25;
                        xm = num36;
                        ym = num37;
                        x1 += num24;
                        x2 += num24;
                        x3 += num24;
                        x4 += num24;
                        y1 += num25;
                        y2 += num25;
                        y3 += num25;
                        y4 += num25;
                    }
                    else if (x1 == x2 && y1 == y2)
                    {
                        double num38 = 0.0;
                        double num39 = 0.0;
                        xm = num38;
                        ym = num39;
                        x1 += num24;
                        x2 += num24;
                        x3 += num24;
                        x4 += num24;
                        y1 += num25;
                        y2 += num25;
                        y3 += num25;
                        y4 += num25;
                    }
                    else if (x3 == x4 && y3 == y4)
                    {
                        double num40 = 0.0;
                        double num41 = 0.0;
                        xm = num40;
                        ym = num41;
                        x1 += num24;
                        x2 += num24;
                        x3 += num24;
                        x4 += num24;
                        y1 += num25;
                        y2 += num25;
                        y3 += num25;
                        y4 += num25;
                    }
                    else
                    {
                        double x5 = x2 - x1;
                        double num42 = Math.Atan2(y2 - y1, x5);
                        if (num42 < 0.0)
                            num42 += 2.0 * num8;
                        double x6 = x4 - x3;
                        double num43 = Math.Atan2(y4 - y3, x6);
                        if (num43 < 0.0)
                            num43 += 2.0 * num8;
                        if (num42 > num43)
                        {
                            num42 -= num8;
                            if (num42 == num43)
                            {
                                double num44 = 0.0;
                                double num45 = 0.0;
                                xm = num44;
                                ym = num45;
                                x1 += num24;
                                x2 += num24;
                                x3 += num24;
                                x4 += num24;
                                y1 += num25;
                                y2 += num25;
                                y3 += num25;
                                y4 += num25;
                                return;
                            }
                        }
                        if (num43 > num42)
                        {
                            double num46 = num43 - num8;
                            if (num42 == num46)
                            {
                                double num47 = 0.0;
                                double num48 = 0.0;
                                xm = num47;
                                ym = num48;
                                x1 += num24;
                                x2 += num24;
                                x3 += num24;
                                x4 += num24;
                                y1 += num25;
                                y2 += num25;
                                y3 += num25;
                                y4 += num25;
                                return;
                            }
                        }
                        if (x2 != x1)
                        {
                            if (x2 > x1)
                            {
                                num7 = x1;
                                num6 = x2;
                            }
                            if (x2 < x1)
                            {
                                num7 = x2;
                                num6 = x1;
                            }
                            if (num34 < num7 || num34 > num6)
                            {
                                double num49 = 0.0;
                                double num50 = 0.0;
                                xm = num49;
                                ym = num50;
                                x1 += num24;
                                x2 += num24;
                                x3 += num24;
                                x4 += num24;
                                y1 += num25;
                                y2 += num25;
                                y3 += num25;
                                y4 += num25;
                                return;
                            }
                        }
                        if (x4 != x3)
                        {
                            if (x4 > x3)
                            {
                                num7 = x3;
                                num6 = x4;
                            }
                            if (x4 < x3)
                            {
                                num7 = x4;
                                num6 = x3;
                            }
                            if (num34 < num7 || num34 > num6)
                            {
                                double num51 = 0.0;
                                double num52 = 0.0;
                                xm = num51;
                                ym = num52;
                                x1 += num24;
                                x2 += num24;
                                x3 += num24;
                                x4 += num24;
                                y1 += num25;
                                y2 += num25;
                                y3 += num25;
                                y4 += num25;
                                return;
                            }
                        }
                        if (x2 == x1)
                        {
                            if (y2 > y1)
                            {
                                num5 = y1;
                                num4 = y2;
                            }
                            if (y2 < y1)
                            {
                                num5 = y2;
                                num4 = y1;
                            }
                            if (num35 < num5 || num35 > num4)
                            {
                                double num53 = 0.0;
                                double num54 = 0.0;
                                xm = num53;
                                ym = num54;
                                x1 += num24;
                                x2 += num24;
                                x3 += num24;
                                x4 += num24;
                                y1 += num25;
                                y2 += num25;
                                y3 += num25;
                                y4 += num25;
                                return;
                            }
                        }
                        if (x4 == x3)
                        {
                            if (y4 > y3)
                            {
                                num5 = y3;
                                num4 = y4;
                            }
                            if (y4 < y3)
                            {
                                num5 = y4;
                                num4 = y3;
                            }
                            if (num35 < num5 || num35 > num4)
                            {
                                double num55 = 0.0;
                                double num56 = 0.0;
                                xm = num55;
                                ym = num56;
                                x1 += num24;
                                x2 += num24;
                                x3 += num24;
                                x4 += num24;
                                y1 += num25;
                                y2 += num25;
                                y3 += num25;
                                y4 += num25;
                                return;
                            }
                        }
                        if (y2 != y1)
                        {
                            if (y2 > y1)
                            {
                                num5 = y1;
                                num4 = y2;
                            }
                            if (y2 < y1)
                            {
                                num5 = y2;
                                num4 = y1;
                            }
                            if (num35 < num5 || num35 > num4)
                            {
                                double num57 = 0.0;
                                double num58 = 0.0;
                                xm = num57;
                                ym = num58;
                                x1 += num24;
                                x2 += num24;
                                x3 += num24;
                                x4 += num24;
                                y1 += num25;
                                y2 += num25;
                                y3 += num25;
                                y4 += num25;
                                return;
                            }
                        }
                        if (y4 != y3)
                        {
                            if (y4 > y3)
                            {
                                num5 = y3;
                                num4 = y4;
                            }
                            if (y4 < y3)
                            {
                                num5 = y4;
                                num4 = y3;
                            }
                            if (num35 < num5 || num35 > num4)
                            {
                                double num59 = 0.0;
                                double num60 = 0.0;
                                xm = num59;
                                ym = num60;
                                x1 += num24;
                                x2 += num24;
                                x3 += num24;
                                x4 += num24;
                                y1 += num25;
                                y2 += num25;
                                y3 += num25;
                                y4 += num25;
                                return;
                            }
                        }
                        if (y2 == y1)
                        {
                            if (x2 > x1)
                            {
                                num7 = x1;
                                num6 = x2;
                            }
                            if (x2 < x1)
                            {
                                num7 = x2;
                                num6 = x1;
                            }
                            if (num34 < num7 || num34 > num6)
                            {
                                double num61 = 0.0;
                                double num62 = 0.0;
                                xm = num61;
                                ym = num62;
                                x1 += num24;
                                x2 += num24;
                                x3 += num24;
                                x4 += num24;
                                y1 += num25;
                                y2 += num25;
                                y3 += num25;
                                y4 += num25;
                                return;
                            }
                        }
                        if (y4 == y3)
                        {
                            if (x4 > x3)
                            {
                                num7 = x3;
                                num6 = x4;
                            }
                            if (x4 < x3)
                            {
                                num7 = x4;
                                num6 = x3;
                            }
                            if (num34 < num7 || num34 > num6)
                            {
                                double num63 = 0.0;
                                double num64 = 0.0;
                                xm = num63;
                                ym = num64;
                                x1 += num24;
                                x2 += num24;
                                x3 += num24;
                                x4 += num24;
                                y1 += num25;
                                y2 += num25;
                                y3 += num25;
                                y4 += num25;
                                return;
                            }
                        }
                        double num65 = num34 + num24;
                        double num66 = num35 + num25;
                        x1 += num24;
                        x2 += num24;
                        x3 += num24;
                        x4 += num24;
                        y1 += num25;
                        y2 += num25;
                        y3 += num25;
                        y4 += num25;
                        xm = num65;
                        ym = num66;
                    }
                }
            }
        }

        public static void DrawGrid(
          PaintEventArgs e,
          int kSqu,
          double[] xSqu,
          double[] ySqu,
          int[] numCol,
          SolidBrush[] brColor)
        {
            Graphics graphics = e.Graphics;
            int int32_1 = Convert.ToInt32(xSqu[4] - xSqu[1]);
            int int32_2 = Convert.ToInt32(ySqu[2] - ySqu[1]);
            int num = kSqu / 5;
            int i1 = -4;
            for (int i2 = 1; i2 <= num; ++i2)
            {
                i1 += 5;
                int int32_3 = Convert.ToInt32(xSqu[i1]);
                int int32_4 = Convert.ToInt32(ySqu[i1]);
                int i3 = numCol[i1];
                SolidBrush solidBrush = brColor[i3];
                graphics.FillRectangle((Brush)solidBrush, int32_3, int32_4, int32_1, int32_2);
            }
        }

        public static void GridPixel(
          int kSqu,
          double[] xSqu,
          double[] ySqu,
          int[] numCol,
          out int kPixel,
          int[] ixSqu,
          int[] iySqu,
          int[] nColor,
          int ix1Grid,
          int iy1Grid)
        {
            kPixel = 0;
            int kArray = 999999;
            intArray(ixSqu, ref kArray);
            intArray(iySqu, ref kArray);
            int num1 = kArray - 10;
            int int32_1 = Convert.ToInt32(xSqu[4] - xSqu[1]);
            int int32_2 = Convert.ToInt32(ySqu[2] - ySqu[1]);
            int num2 = ix1Grid + int32_1 / 2;
            int num3 = iy1Grid + int32_2 / 2;
            int num4 = kSqu / 5;
            int i1 = -4;
            int num5;
            int num6 = num5 = 0;
            for (int i2 = 1; i2 <= num4; ++i2)
            {
                i1 += 5;
                int num7 = Convert.ToInt32(0.5 * (xSqu[i1] + xSqu[i1 + 2])) - num2;
                int num8 = Convert.ToInt32(0.5 * (ySqu[i1] + ySqu[i1 + 2])) - num3;
                int num9 = num7 / int32_1;
                if (num7 - int32_1 * num9 > int32_1 / 2)
                    ++num9;
                int num10 = num8 / int32_2;
                if (num8 - int32_2 * num10 > int32_2 / 2)
                    ++num10;
                ++kPixel;
                if (kPixel > num1)
                {
                    int num11 = (int)MessageBox.Show("Индекс массива GridPixel");
                    break;
                }
                ixSqu[kPixel] = num9;
                iySqu[kPixel] = num10;
                nColor[kPixel] = numCol[i1];
            }
        }

        public static void SignDraw(
          PaintEventArgs e,
          int ixh,
          int iyh,
          int kPixel,
          int[] ixSqu,
          int[] iySqu,
          int[] nColor,
          SolidBrush[] brColor)
        {
            Graphics graphics = e.Graphics;
            int num1;
            int num2 = num1 = 0;
            for (int i = 1; i <= kPixel; ++i)
            {
                if (ixSqu[i] > num2)
                    num2 = ixSqu[i];
                if (iySqu[i] > num1)
                    num1 = iySqu[i];
            }
            graphics.FillRectangle((Brush)new SolidBrush(Color.White), ixh - 1, iyh - 1, num2 + 1, num1 + 1);
            for (int i1 = 1; i1 <= kPixel; ++i1)
            {
                int x = ixh + ixSqu[i1];
                int y = iyh + iySqu[i1];
                int i2 = nColor[i1];
                SolidBrush solidBrush = brColor[i2];
                graphics.FillRectangle((Brush)solidBrush, x, y, 1, 1);
            }
        }

        public static void LineFinal(
          int kLine1,
          int[] iCod1,
          int[] iLong1,
          double[] sWid1,
          double[] sDist1,
          double[] Rad1,
          double[] xRad1,
          double[] yRad1,
          int[] k11,
          int[] k12,
          double[] xLin1,
          double[] yLin1,
          int kLine2,
          double[] Rad2,
          int[] k21,
          int[] k22,
          double[] xLin2,
          double[] yLin2,
          out int kLine,
          int[] iCod,
          int[] iLong,
          double[] sWid,
          double[] sDist,
          double[] Rad,
          double[] xRad,
          double[] yRad,
          int[] k1,
          int[] k2,
          double[] xLin,
          double[] yLin,
          int[] kt,
          double[] xd,
          double[] yd,
          double tol)
        {
            kLine = 0;
            if (tol < 0.003)
                tol = 0.003;
            Cursor.Current = Cursors.WaitCursor;
            int kArray = 999999;
            doubleArray(xLin, ref kArray);
            doubleArray(yLin, ref kArray);
            int num1;
            int i1 = num1 = 0;
            int num2;
            int num3 = num2 = 0;
            double num4;
            double yp = num4 = 0.0;
            double xp = num4;
            double dist = num4;
            double num5;
            double num6 = num5 = 0.0;
            for (int i2 = 1; i2 <= kLine2; ++i2)
            {
                int i3 = k21[i2];
                int i4 = k22[i2];
                double xx = 0.5 * (xLin2[i3] + xLin2[i4]);
                double yy = 0.5 * (yLin2[i3] + yLin2[i4]);
                double num7 = 9999999.9;
                int i5 = 0;
                for (int i6 = 1; i6 <= kLine1; ++i6)
                {
                    int num8 = k11[i6];
                    int num9 = k12[i6];
                    if (Rad1[i6] == 0.0)
                    {
                        int ip = i4 - i3;
                        if (ip <= 1)
                        {
                            for (int i7 = num8 + 1; i7 <= num9; ++i7)
                            {
                                DistPnt(xx, yy, xLin1[i7 - 1], yLin1[i7 - 1], xLin1[i7], yLin1[i7], out dist, out ip, out xp, out yp);
                                if (ip > 0 && dist < num7 && dist < tol)
                                {
                                    num7 = dist;
                                    i5 = i6;
                                }
                            }
                        }
                    }
                }
                if (i5 > 0)
                {
                    int num10 = 0;
                    for (int i8 = i3; i8 <= i4; ++i8)
                    {
                        ++num10;
                        ++i1;
                        if (i1 > kArray)
                        {
                            int num11 = (int)MessageBox.Show("Индекс массива LineFinal");
                            kLine = 0;
                            return;
                        }
                        xLin[i1] = xLin2[i8];
                        yLin[i1] = yLin2[i8];
                    }
                    ++kLine;
                    kt[kLine] = num10;
                    iCod[kLine] = iCod1[i5];
                    iLong[kLine] = 0;
                    sWid[kLine] = sWid1[i5];
                    sDist[kLine] = sDist1[i5];
                    Rad[kLine] = 0.0;
                    xRad[kLine] = xRad1[i5];
                    yRad[kLine] = yRad1[i5];
                }
                else
                {
                    double num12 = 9999999.9;
                    int i9 = 0;
                    int num13 = i4 - i3;
                    double num14 = xLin2[i3];
                    double num15 = yLin2[i3];
                    if (num13 > 1)
                    {
                        int i10 = (i3 + i4) / 2;
                        num14 = xLin2[i10];
                        num15 = yLin2[i10];
                    }
                    for (int i11 = 1; i11 <= kLine1; ++i11)
                    {
                        int num16 = k11[i11];
                        int num17 = k12[i11];
                        if (Rad1[i11] > 0.0)
                        {
                            for (int i12 = num16; i12 <= num17; ++i12)
                            {
                                double num18 = xLin1[i12] - num14;
                                double num19 = yLin1[i12] - num15;
                                double num20 = Math.Sqrt(num18 * num18 + num19 * num19);
                                if (num20 < num12 && num20 < tol)
                                {
                                    num12 = num20;
                                    i9 = i11;
                                }
                            }
                        }
                    }
                    if (i9 > 0)
                    {
                        int num21 = 0;
                        int k = -1;
                        for (int i13 = i3; i13 <= i4; ++i13)
                        {
                            ++num21;
                            ++i1;
                            if (i1 > kArray)
                            {
                                int num22 = (int)MessageBox.Show("Индекс массива LineFinal");
                                kLine = 0;
                                return;
                            }
                            xLin[i1] = xLin2[i13];
                            yLin[i1] = yLin2[i13];
                            ++k;
                            xd[k] = xLin2[i13];
                            yd[k] = yLin2[i13];
                        }
                        ++kLine;
                        kt[kLine] = num21;
                        iCod[kLine] = iCod1[i9];
                        iLong[kLine] = 0;
                        sWid[kLine] = sWid1[i9];
                        sDist[kLine] = sDist1[i9];
                        Rad[kLine] = Rad1[i9];
                        xRad[kLine] = xRad1[i9];
                        yRad[kLine] = yRad1[i9];
                        if (in_out(k, ref xd, ref yd, xRad[kLine], yRad[kLine]) > 0)
                            iLong[kLine] = 1;
                    }
                    else
                    {
                        if (Rad2[i2] == 0.0)
                        {
                            int num23 = 0;
                            for (int i14 = i3; i14 <= i4; ++i14)
                            {
                                ++num23;
                                ++i1;
                                if (i1 > kArray)
                                {
                                    int num24 = (int)MessageBox.Show("Индекс массива LineFinal");
                                    kLine = 0;
                                    return;
                                }
                                xLin[i1] = xLin2[i14];
                                yLin[i1] = yLin2[i14];
                            }
                            ++kLine;
                            kt[kLine] = num23;
                            iCod[kLine] = 1;
                            iLong[kLine] = 0;
                            sWid[kLine] = 0.0;
                            sDist[kLine] = 0.0;
                            Rad[kLine] = 0.0;
                            xRad[kLine] = 0.0;
                            yRad[kLine] = 0.0;
                        }
                        if (Rad2[i2] > 0.0)
                        {
                            int num25 = 0;
                            int k = -1;
                            for (int i15 = i3; i15 <= i4; ++i15)
                            {
                                ++num25;
                                ++i1;
                                if (i1 > kArray)
                                {
                                    int num26 = (int)MessageBox.Show("Индекс массива LineFinal");
                                    kLine = 0;
                                    return;
                                }
                                xLin[i1] = xLin2[i15];
                                yLin[i1] = yLin2[i15];
                                ++k;
                                xd[k] = xLin2[i15];
                                yd[k] = yLin2[i15];
                            }
                            ++kLine;
                            kt[kLine] = num25;
                            iCod[kLine] = 1;
                            iLong[kLine] = 0;
                            sWid[kLine] = 0.0;
                            sDist[kLine] = 0.0;
                            Rad[kLine] = Rad2[i2];
                            xRad[kLine] = 0.0;
                            yRad[kLine] = 0.0;
                            if (k > 2)
                                GetCentre(k, ref xd, ref yd, Rad[kLine], out xRad[kLine], out yRad[kLine]);
                            if (in_out(k, ref xd, ref yd, xRad[kLine], yRad[kLine]) > 0)
                                iLong[kLine] = 1;
                        }
                    }
                }
            }
            if (kLine <= 0)
                return;
            k1[1] = 1;
            k2[1] = kt[1];
            if (kLine <= 1)
                return;
            for (int i16 = 2; i16 <= kLine; ++i16)
            {
                k1[i16] = k2[i16 - 1] + 1;
                k2[i16] = k2[i16 - 1] + kt[i16];
            }
        }

        public static void PolyFinal(
          int kPol,
          string[] namePol,
          double[] xLab,
          double[] yLab,
          double[] aCalc,
          double[] aLeg,
          int[] kPol1,
          int[] kPol2,
          double[] xPol,
          double[] yPol,
          out int kPolFin,
          string[] nameFin,
          double[] xCentr,
          double[] yCentr,
          double[] arCalc,
          double[] arLeg,
          int[] nSymb,
          int[] kFin1,
          int[] kFin2,
          double[] xFin,
          double[] yFin)
        {
            kPolFin = 0;
            Cursor.Current = Cursors.WaitCursor;
            int kArray = 999999;
            int num1 = kPol2[kPol];
            doubleArray(xPol, ref kArray);
            doubleArray(yPol, ref kArray);
            doubleArray(xFin, ref kArray);
            doubleArray(yFin, ref kArray);
            if (num1 > kArray)
            {
                int num2 = (int)MessageBox.Show("Индекс массива PolyFinal");
            }
            else
            {
                kPolFin = kPol;
                for (int i1 = 1; i1 <= kPol; ++i1)
                {
                    nameFin[i1] = namePol[i1];
                    xCentr[i1] = xLab[i1];
                    yCentr[i1] = yLab[i1];
                    arCalc[i1] = aCalc[i1];
                    arLeg[i1] = aLeg[i1];
                    nSymb[i1] = 0;
                    kFin1[i1] = kPol1[i1];
                    kFin2[i1] = kPol2[i1];
                    int num3 = kPol1[i1];
                    int num4 = kPol2[i1];
                    for (int i2 = num3; i2 <= num4; ++i2)
                    {
                        xFin[i2] = xPol[i2];
                        yFin[i2] = yPol[i2];
                    }
                }
            }
        }

        public static void LineItemCoor(
          string fitemLine,
          int[] nColItem,
          int[] ixq,
          int[] iyq,
          int kLine,
          double[] rRadLine,
          int[] k1,
          int[] k2,
          double[] xLin,
          double[] yLin,
          int[] nSymb,
          int kSymbLine,
          int[] nItem,
          int[] n1Sign,
          int[] n2Sign,
          int[] iDensity,
          out int kItem,
          int[] numSign,
          int[] numItem,
          double[] xItem,
          double[] yItem,
          double[] az,
          double[] xr,
          double[] yr,
          double[] x,
          double[] y,
          double scaleWin,
          double xBeg,
          double yBeg,
          int xWin,
          int yWin,
          double scaleGeo)
        {
            double num1 = 3.1415926;
            kItem = 0;
            if (kLine == 0)
                return;
            int kArray = 999999;
            intArray(numSign, ref kArray);
            intArray(numItem, ref kArray);
            doubleArray(xItem, ref kArray);
            doubleArray(yItem, ref kArray);
            doubleArray(az, ref kArray);
            kArray -= 3;
            for (int i1 = 1; i1 <= kLine; ++i1)
            {
                string sTxt = "";
                int iLong = 0;
                int i2 = 0;
                for (int i3 = 1; i3 <= kSymbLine; ++i3)
                {
                    if (n2Sign[i3] > 0 && n2Sign[i3] == nSymb[i1])
                    {
                        i2 = n1Sign[i3];
                        break;
                    }
                }
                if (i2 == 0)
                {
                    for (int i4 = 1; i4 <= kSymbLine; ++i4)
                    {
                        if (n1Sign[i4] > 0 && n1Sign[i4] == nSymb[i1])
                        {
                            i2 = n1Sign[i4];
                            break;
                        }
                    }
                }
                string text = string.Format("{0}", (object)nSymb[i1]);
                if (i2 == 0)
                {
                    int num2 = (int)MessageBox.Show(text, "User's code line error", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                    break;
                }
                int nSelect = nItem[i2];
                int num3 = iDensity[i2];
                if (nSelect != 0)
                {
                    int iWid;
                    SelItemLine(fitemLine, nSelect, out iLong, out iWid, out int _, out int _, ixq, iyq, nColItem, out sTxt, out int _);
                    if (iLong <= 0)
                    {
                        int num4 = k1[i1];
                        int num5 = k2[i1];
                        int i5 = -1;
                        int i6 = -1;
                        int xWin1;
                        int yWin1;
                        for (int i7 = num4; i7 <= num5; ++i7)
                        {
                            ++i6;
                            xr[i6] = xLin[i7];
                            yr[i6] = yLin[i7];
                            XYtoWIN(xLin[i7], yLin[i7], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                            ++i5;
                            x[i5] = (double)xWin1;
                            y[i5] = (double)yWin1;
                        }
                        int num6 = 0;
                        if (num3 == 1)
                            num6 = 5 * iWid;
                        if (num3 == 2)
                            num6 = 4 * iWid;
                        if (num3 == 3)
                            num6 = 3 * iWid;
                        if (num3 == 4)
                            num6 = 2 * iWid;
                        if (num3 == 5)
                            num6 = iWid;
                        double num7 = 0.0;
                        for (int i8 = 1; i8 <= i5; ++i8)
                        {
                            double num8 = x[i8] - x[i8 - 1];
                            double num9 = y[i8] - y[i8 - 1];
                            double num10 = Math.Sqrt(num8 * num8 + num9 * num9);
                            num7 += num10;
                        }
                        int num11 = Convert.ToInt32(num7 / (double)num6) + 1;
                        double yCur;
                        double xCur = yCur = 0.0;
                        double num12 = (double)(-num6 + iWid / 2);
                        for (int i9 = 1; i9 <= num11; ++i9)
                        {
                            num12 += (double)num6;
                            double num13 = 0.0;
                            int num14 = 0;
                            for (int i10 = 1; i10 <= i5; ++i10)
                            {
                                double x1 = x[i10] - x[i10 - 1];
                                double y1 = y[i10] - y[i10 - 1];
                                double num15 = Math.Sqrt(x1 * x1 + y1 * y1);
                                num13 += num15;
                                if (rRadLine[i1] > 0.0)
                                {
                                    int num16 = i10;
                                    int num17 = i5 - i10;
                                    if (num16 > 2 && num17 > 2)
                                    {
                                        x1 = x[i10 + 2] - x[i10 - 2];
                                        y1 = y[i10 + 2] - y[i10 - 2];
                                    }
                                    if (num16 == 2 && num17 > 2)
                                    {
                                        x1 = x[i10 + 2] - x[i10 - 1];
                                        y1 = y[i10 + 2] - y[i10 - 1];
                                    }
                                    if (num16 > 2 && num17 == 2)
                                    {
                                        x1 = x[i10 + 1] - x[i10 - 2];
                                        y1 = y[i10 + 1] - y[i10 - 2];
                                    }
                                }
                                double num18 = Math.Atan2(y1, x1);
                                if (num18 < 0.0)
                                    num18 += 2.0 * num1;
                                if (num12 <= num13)
                                {
                                    double num19 = num15 - (num13 - num12);
                                    xWin1 = Convert.ToInt32(x[i10 - 1] + num19 * Math.Cos(num18));
                                    yWin1 = Convert.ToInt32(y[i10 - 1] + num19 * Math.Sin(num18));
                                    WINtoXY(xWin1, yWin1, scaleGeo, xBeg, yBeg, xWin, yWin, out xCur, out yCur);
                                    int num20 = num14 + 1;
                                    ++kItem;
                                    numSign[kItem] = i2;
                                    numItem[kItem] = nSelect;
                                    xItem[kItem] = xCur;
                                    yItem[kItem] = yCur;
                                    az[kItem] = num18;
                                    if (kItem > kArray)
                                    {
                                        int num21 = (int)MessageBox.Show("Индекс массива LineItemCoor");
                                        return;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void LineItemOut(
          ref int kItemCoord,
          int[] numSign,
          int[] numItem,
          double[] xItem,
          double[] yItem,
          double[] azItem,
          int kPolyFinal,
          int[] kt1Fin,
          int[] kt2Fin,
          double[] xPolFin,
          double[] yPolFin,
          double[] xWork,
          double[] yWork)
        {
            if (kItemCoord <= 0)
                return;
            for (int i1 = 1; i1 <= kPolyFinal; ++i1)
            {
                int num1 = kt1Fin[i1];
                int num2 = kt2Fin[i1];
                int k = -1;
                for (int i2 = num1; i2 <= num2; ++i2)
                {
                    ++k;
                    xWork[k] = xPolFin[i2];
                    yWork[k] = yPolFin[i2];
                }
                for (int i3 = 1; i3 <= kItemCoord; ++i3)
                {
                    if ((xItem[i3] != 0.0 || yItem[i3] != 0.0) && in_out(k, ref xWork, ref yWork, xItem[i3], yItem[i3]) > 0)
                    {
                        int num3 = 0;
                        for (int i4 = 1; i4 <= k; ++i4)
                        {
                            double x1 = xWork[i4 - 1];
                            double y1 = yWork[i4 - 1];
                            double x2 = xWork[i4];
                            double y2 = yWork[i4];
                            double dist;
                            int ip;
                            DistPnt(xItem[i3], yItem[i3], x1, y1, x2, y2, out dist, out ip, out double _, out double _);
                            if (ip > 0 && dist < 0.3)
                            {
                                ++num3;
                                break;
                            }
                        }
                        if (num3 <= 0)
                        {
                            xItem[i3] = 0.0;
                            yItem[i3] = 0.0;
                        }
                    }
                }
            }
            int i5 = 0;
            for (int i6 = 1; i6 <= kItemCoord; ++i6)
            {
                if (xItem[i6] != 0.0 || yItem[i6] != 0.0)
                {
                    ++i5;
                    numSign[i5] = numSign[i6];
                    numItem[i5] = numItem[i6];
                    xItem[i5] = xItem[i6];
                    yItem[i5] = yItem[i6];
                    azItem[i5] = azItem[i6];
                }
            }
            kItemCoord = i5;
        }

        public static void SymbolTrans(
          int kLineInput,
          int[] nLineCode,
          double[] rRadLine,
          int[] k1,
          int[] k2,
          double[] xLin,
          double[] yLin,
          int kLineTopo,
          int[] nTopoCode,
          double[] radLine,
          int[] kl1,
          int[] kl2,
          double[] xTopo,
          double[] yTopo,
          double tol)
        {
            if (tol < 0.003)
                tol = 0.003;
            double yy;
            double xx = yy = 0.0;
            int kArray = 999999;
            doubleArray(xLin, ref kArray);
            doubleArray(yLin, ref kArray);
            if (k2[kLineInput] > kArray)
            {
                int num1 = (int)MessageBox.Show("Индекс массива SymbolTrans");
            }
            else
            {
                for (int i1 = 1; i1 <= kLineTopo; ++i1)
                {
                    if (nTopoCode[i1] <= 0)
                    {
                        int i2 = kl1[i1];
                        int num2 = kl2[i1];
                        if (radLine[i1] == 0.0)
                        {
                            xx = 0.5 * (xTopo[i2] + xTopo[i2 + 1]);
                            yy = 0.5 * (yTopo[i2] + yTopo[i2 + 1]);
                        }
                        if (radLine[i1] > 0.0)
                        {
                            int i3 = (i2 + num2) / 2;
                            xx = xTopo[i3];
                            yy = yTopo[i3];
                        }
                        int num3 = 0;
                        double num4 = 9999999.9;
                        for (int i4 = 1; i4 <= kLineInput; ++i4)
                        {
                            int num5 = k1[i4];
                            int num6 = k2[i4];
                            double dist;
                            if (rRadLine[i4] == 0.0)
                            {
                                for (int i5 = num5 + 1; i5 <= num6; ++i5)
                                {
                                    double x1 = xLin[i5 - 1];
                                    double y1 = yLin[i5 - 1];
                                    double x2 = xLin[i5];
                                    double y2 = yLin[i5];
                                    int ip;
                                    DistPnt(xx, yy, x1, y1, x2, y2, out dist, out ip, out double _, out double _);
                                    if (ip > 0 && num4 > dist)
                                    {
                                        num4 = dist;
                                        num3 = nLineCode[i4];
                                    }
                                }
                            }
                            if (rRadLine[i4] > 0.0)
                            {
                                for (int i6 = num5; i6 <= num6; ++i6)
                                {
                                    double num7 = xLin[i6] - xx;
                                    double num8 = yLin[i6] - yy;
                                    dist = Math.Sqrt(num7 * num7 + num8 * num8);
                                    if (num4 > dist)
                                    {
                                        num4 = dist;
                                        num3 = nLineCode[i4];
                                    }
                                }
                            }
                        }
                        if (num3 != 0)
                            nTopoCode[i1] = num3;
                    }
                }
            }
        }

        public static void Print_CancelLine(
          PrintPageEventArgs e,
          double sPixInch,
          int iScaleMap,
          double[] xCorner,
          double[] yCorner,
          int kLine,
          int[] k1,
          int[] k2,
          double[] xLin,
          double[] yLin,
          double[] rRad,
          int[] nWork,
          int[] nWork1,
          int[] nWork2,
          double[] xWork1,
          double[] yWork1,
          double[] xWork2,
          double[] yWork2,
          double[] xta,
          double[] yta,
          double[] xd,
          double[] yd,
          double[] xit,
          double[] yit,
          int iColorPrint,
          int ix,
          int iy)
        {
            double num1 = 0.01 * (double)iScaleMap;
            if (kLine == 0)
                return;
            Pen pen1 = new Pen(Color.Black);
            pen1.Width = 2f;
            Pen pen2 = new Pen(Color.DarkGreen);
            pen2.Width = 2f;
            int kp = -1;
            for (int i = 1; i <= 5; ++i)
            {
                ++kp;
                xit[kp] = xCorner[i];
                yit[kp] = yCorner[i];
            }
            for (int i1 = 1; i1 <= kLine; ++i1)
            {
                int num2 = k1[i1];
                int num3 = k2[i1];
                int k = -1;
                for (int i2 = num2; i2 <= num3; ++i2)
                {
                    ++k;
                    xta[k] = xLin[i2];
                    yta[k] = yLin[i2];
                }
                double rad = rRad[i1];
                double yrd;
                double xrd = yrd = 0.0;
                int kl;
                ClipLine(kp, xit, yit, k, xta, yta, rad, xrd, yrd, out kl, nWork1, nWork2, xWork1, yWork1, nWork, xWork2, yWork2);
                if (kl >= 0 && kl > -1)
                {
                    for (int i3 = 0; i3 <= kl; ++i3)
                    {
                        int num4 = nWork1[i3];
                        int num5 = nWork2[i3];
                        int i4 = -1;
                        for (int i5 = num4; i5 <= num5; ++i5)
                        {
                            double num6 = xWork1[i5] - xCorner[2];
                            double num7 = yWork1[i5] - yCorner[2];
                            int int32_1 = Convert.ToInt32(10.0 * num6 / num1 / sPixInch);
                            int int32_2 = Convert.ToInt32(10.0 * num7 / num1 / sPixInch);
                            int num8 = ix + int32_1;
                            int num9 = iy - int32_2;
                            ++i4;
                            xd[i4] = (double)num8;
                            yd[i4] = (double)num9;
                        }
                        if (rRad[i1] == 0.0)
                        {
                            for (int i6 = 1; i6 <= i4; ++i6)
                            {
                                int int32_3 = Convert.ToInt32(xd[i6 - 1]);
                                int int32_4 = Convert.ToInt32(yd[i6 - 1]);
                                int int32_5 = Convert.ToInt32(xd[i6]);
                                int int32_6 = Convert.ToInt32(yd[i6]);
                                Point pt1 = new Point(int32_3, int32_4);
                                Point pt2 = new Point(int32_5, int32_6);
                                if (iColorPrint == 0)
                                {
                                    pen1.DashStyle = DashStyle.Dash;
                                    e.Graphics.DrawLine(pen1, pt1, pt2);
                                }
                                if (iColorPrint > 0)
                                {
                                    pen2.DashStyle = DashStyle.Dash;
                                    e.Graphics.DrawLine(pen2, pt1, pt2);
                                }
                            }
                        }
                        if (rRad[i1] > 0.0)
                        {
                            for (int i7 = 4; i7 <= i4; i7 += 6)
                            {
                                int int32_7 = Convert.ToInt32(xd[i7 - 4]);
                                int int32_8 = Convert.ToInt32(yd[i7 - 4]);
                                int int32_9 = Convert.ToInt32(xd[i7]);
                                int int32_10 = Convert.ToInt32(yd[i7]);
                                Point pt1 = new Point(int32_7, int32_8);
                                Point pt2 = new Point(int32_9, int32_10);
                                if (iColorPrint == 0)
                                    e.Graphics.DrawLine(pen1, pt1, pt2);
                                if (iColorPrint > 0)
                                    e.Graphics.DrawLine(pen2, pt1, pt2);
                            }
                        }
                    }
                }
            }
        }

        public static void PolyItemDraw(
          PaintEventArgs e,
          string fitemPoly,
          int hItem,
          int kItemPoly,
          int[] hItemPoly,
          SolidBrush[] brColor)
        {
            Graphics graphics = e.Graphics;
            int x1 = 10;
            int x2 = 10;
            int emSize1 = 8;
            SolidBrush solidBrush1 = new SolidBrush(Color.Black);
            Pen pen = new Pen(Color.Black, 1f);
            Font font1 = new Font("Arial", (float)emSize1);
            Font font2 = new Font("Arial", (float)emSize1, FontStyle.Bold);
            SolidBrush solidBrush2 = new SolidBrush(Color.Black);
            if (kItemPoly <= 0)
                return;
            FileStream input = new FileStream(fitemPoly, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            try
            {
                for (int i1 = 1; i1 <= kItemPoly; ++i1)
                {
                    string s1 = binaryReader.ReadString();
                    int num1 = binaryReader.ReadInt32();
                    int y1 = hItemPoly[i1];
                    if (num1 == 0)
                    {
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        binaryReader.ReadInt32();
                        int num2 = binaryReader.ReadInt32();
                        int num3 = binaryReader.ReadInt32();
                        int num4 = num2 / 2;
                        if (num2 >= emSize1)
                            num4 = 0;
                        if (num3 > 0)
                        {
                            graphics.DrawString(s1, font1, (Brush)solidBrush2, (float)x1, (float)y1);
                            for (int i2 = 1; i2 <= num3; ++i2)
                            {
                                int num5 = binaryReader.ReadInt32();
                                int num6 = binaryReader.ReadInt32();
                                int i3 = binaryReader.ReadInt32();
                                SolidBrush solidBrush3 = brColor[i3];
                                int num7 = x2 + num5;
                                int y2 = y1 + num6 + num4;
                                graphics.FillRectangle((Brush)solidBrush3, num7 + 40, y2, 1, 1);
                            }
                        }
                    }
                    if (num1 > 0)
                    {
                        int emSize2 = binaryReader.ReadInt32();
                        int i4 = binaryReader.ReadInt32();
                        string s2 = binaryReader.ReadString();
                        Font font3 = new Font("Arial", (float)emSize2, FontStyle.Regular);
                        SolidBrush solidBrush4 = brColor[i4];
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        binaryReader.ReadInt32();
                        binaryReader.ReadInt32();
                        graphics.DrawString(s1, font1, (Brush)solidBrush2, (float)x1, (float)y1);
                        graphics.DrawString(s2, font3, (Brush)solidBrush4, (float)x2, (float)y1);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            binaryReader.Close();
            input.Close();
        }

        public static void Print_DrawText(
          PrintPageEventArgs e,
          string sText,
          int hText,
          int ixh,
          int iyh,
          int mColor,
          SolidBrush[] brColor)
        {
            if (sText == "")
                return;
            if (mColor == 0)
                mColor = 1;
            if (hText < 5)
                return;
            Graphics graphics = e.Graphics;
            Font font = new Font("Arial", (float)hText, FontStyle.Bold);
            SolidBrush solidBrush = brColor[mColor];
            graphics.DrawString(sText, font, (Brush)solidBrush, (float)ixh, (float)iyh);
        }

        public static void KeepLoadParts(
          int iParam,
          string fPntLine,
          ref int kp,
          double[] xp,
          double[] yp,
          int[] np,
          ref int kl,
          double[] xa,
          double[] ya,
          double[] xb,
          double[] yb,
          int[] nw,
          int[] nc)
        {
            if (iParam == 1)
            {
                if (File.Exists(fPntLine))
                    File.Delete(fPntLine);
                FileStream output = new FileStream(fPntLine, FileMode.CreateNew);
                BinaryWriter binaryWriter = new BinaryWriter((Stream)output);
                binaryWriter.Write(kp);
                if (kp > 0)
                {
                    for (int i = 1; i <= kp; ++i)
                    {
                        binaryWriter.Write(xp[i]);
                        binaryWriter.Write(yp[i]);
                        binaryWriter.Write(np[i]);
                    }
                }
                binaryWriter.Write(kl);
                if (kl > 0)
                {
                    for (int i = 1; i <= kl; ++i)
                    {
                        binaryWriter.Write(xa[i]);
                        binaryWriter.Write(ya[i]);
                        binaryWriter.Write(xb[i]);
                        binaryWriter.Write(yb[i]);
                        binaryWriter.Write(nw[i]);
                        binaryWriter.Write(nc[i]);
                    }
                }
                binaryWriter.Close();
                output.Close();
            }
            if (iParam != 2)
                return;
            kp = kl = 0;
            if (!File.Exists(fPntLine))
                return;
            FileStream input = new FileStream(fPntLine, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            try
            {
                kp = binaryReader.ReadInt32();
                if (kp > 0)
                {
                    for (int i = 1; i <= kp; ++i)
                    {
                        xp[i] = binaryReader.ReadDouble();
                        yp[i] = binaryReader.ReadDouble();
                        np[i] = binaryReader.ReadInt32();
                    }
                }
                kl = binaryReader.ReadInt32();
                if (kl <= 0)
                    return;
                for (int i = 1; i <= kl; ++i)
                {
                    xa[i] = binaryReader.ReadDouble();
                    ya[i] = binaryReader.ReadDouble();
                    xb[i] = binaryReader.ReadDouble();
                    yb[i] = binaryReader.ReadDouble();
                    nw[i] = binaryReader.ReadInt32();
                    nc[i] = binaryReader.ReadInt32();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            finally
            {
                binaryReader.Close();
                input.Close();
            }
        }

        public static void Print_Points(
          PrintPageEventArgs e,
          string fsymbPnt,
          double sPixInch,
          int iScaleMap,
          double[] xCorner,
          double[] yCorner,
          int kPnt,
          string[] pName,
          double[] xPnt,
          double[] yPnt,
          double[] zPnt,
          int iParam,
          double[] xPntInscr,
          double[] yPntInscr,
          int[] iHorVerPnt,
          int[] nCode1,
          int[] nCode2,
          int kSymbPnt,
          int[] numRec,
          int[] numbUser,
          int[] ixSqu,
          int[] iySqu,
          int[] nColor,
          int xPageBeg,
          int yPageBeg,
          SolidBrush[] brCol,
          Pen[] pnCol,
          int iBlack)
        {
            string sDscr = "";
            int k = -1;
            double[] x1 = new double[10];
            double[] y1 = new double[10];
            string sTxt = "";
            int num1;
            int iLong = num1 = 0;
            int iHei = num1;
            int iWid = num1;
            int kArray1 = 999999;
            doubleArray(xCorner, ref kArray1);
            doubleArray(yCorner, ref kArray1);
            if (kArray1 < 5)
            {
                int num2 = (int)MessageBox.Show("Индекс массива Points_PrevPrint");
            }
            else
            {
                int kArray2 = 999999;
                stringArray(pName, ref kArray2);
                doubleArray(xPnt, ref kArray2);
                doubleArray(yPnt, ref kArray2);
                doubleArray(zPnt, ref kArray2);
                doubleArray(xPntInscr, ref kArray2);
                doubleArray(yPntInscr, ref kArray2);
                intArray(iHorVerPnt, ref kArray2);
                if (kPnt > kArray2)
                {
                    int num3 = (int)MessageBox.Show("Индекс массива Points_PrevPrint");
                }
                else
                {
                    SolidBrush solidBrush1 = new SolidBrush(Color.Black);
                    SolidBrush iColor = new SolidBrush(Color.Black);
                    double num4 = 0.01 * (double)iScaleMap;
                    int num5 = 8;
                    Font font = new Font("Arial", (float)num5, FontStyle.Regular);
                    for (int i = 1; i <= 5; ++i)
                    {
                        ++k;
                        x1[k] = xCorner[i];
                        y1[k] = yCorner[i];
                    }
                    for (int i1 = 0; i1 <= kPnt; ++i1)
                    {
                        if (in_out(k, ref x1, ref y1, xPnt[i1], yPnt[i1]) > 0)
                        {
                            double num6 = xPnt[i1] - xCorner[2];
                            double num7 = yPnt[i1] - yCorner[2];
                            int int32_1 = Convert.ToInt32(10.0 * num6 / num4 / sPixInch);
                            int int32_2 = Convert.ToInt32(10.0 * num7 / num4 / sPixInch);
                            int x2 = xPageBeg + int32_1;
                            int num8 = yPageBeg - int32_2;
                            e.Graphics.FillRectangle((Brush)solidBrush1, x2 - 1, num8 - 1, 3, 3);
                            int nCodePnt = 0;
                            if (nCode1[i1] > 0)
                                nCodePnt = nCode1[i1];
                            if (nCodePnt > 0)
                            {
                                int kPix;
                                int mClr;
                                SelSymbPnt(fsymbPnt, nCodePnt, kSymbPnt, numRec, numbUser, out iLong, out iWid, out iHei, out sDscr, out kPix, ixSqu, iySqu, nColor, out sTxt, out mClr);
                                if (iLong == 0)
                                {
                                    SolidBrush solidBrush2 = new SolidBrush(Color.White);
                                    e.Graphics.FillRectangle((Brush)solidBrush2, x2 - 1, num8 - 1, 3, 3);
                                    for (int i2 = 1; i2 < kPix; ++i2)
                                    {
                                        int x3 = x2 + ixSqu[i2] - iWid / 2;
                                        int y2 = num8 + iySqu[i2] - iHei / 2;
                                        if (iBlack > 0)
                                        {
                                            int i3 = nColor[i2];
                                            SolidBrush solidBrush3 = brCol[i3];
                                            e.Graphics.FillRectangle((Brush)solidBrush3, x3, y2, 1, 1);
                                        }
                                        if (iBlack == 0)
                                        {
                                            SolidBrush solidBrush4 = new SolidBrush(Color.Black);
                                            e.Graphics.FillRectangle((Brush)solidBrush4, x3, y2, 1, 1);
                                        }
                                    }
                                }
                                if (iLong > 0)
                                {
                                    if (iBlack == 0)
                                        mClr = 1;
                                    Print_DrawText(e, sTxt, iHei, x2 - iWid, num8, mClr, brCol);
                                }
                            }
                            if (iParam == 0)
                            {
                                double num9 = xPntInscr[i1] - xCorner[2];
                                double num10 = yPntInscr[i1] - yCorner[2];
                                int int32_3 = Convert.ToInt32(10.0 * num9 / num4 / sPixInch);
                                int int32_4 = Convert.ToInt32(10.0 * num10 / num4 / sPixInch);
                                x2 = xPageBeg + int32_3;
                                num8 = yPageBeg - int32_4;
                                if (nCodePnt > 0)
                                {
                                    if (iHorVerPnt[i1] == 0)
                                        e.Graphics.DrawString(pName[i1], font, (Brush)solidBrush1, (float)(x2 + iWid / 2), (float)(num8 - num5 / 2));
                                    if (iHorVerPnt[i1] > 0)
                                        RotTextPrevPrint(e, pName[i1], x2, num8, num5, 270, iColor, 0);
                                }
                                if (nCodePnt == 0)
                                {
                                    if (iHorVerPnt[i1] == 0)
                                        e.Graphics.DrawString(pName[i1], font, (Brush)solidBrush1, (float)(x2 + num5 / 4), (float)(num8 - num5 + 2));
                                    if (iHorVerPnt[i1] > 0)
                                        RotTextPrevPrint(e, pName[i1], x2, num8, num5, 270, iColor, 0);
                                }
                            }
                            if (iParam > 0)
                            {
                                string str = string.Format("{0:F2}", (object)zPnt[i1]);
                                if (nCodePnt > 0)
                                {
                                    if (iHorVerPnt[i1] == 0)
                                        e.Graphics.DrawString(str, font, (Brush)solidBrush1, (float)(x2 + iWid / 2), (float)(num8 - num5 + 2));
                                    if (iHorVerPnt[i1] > 0)
                                        RotTextPrevPrint(e, str, x2, num8, num5, 270, iColor, 0);
                                }
                                if (nCodePnt == 0)
                                {
                                    if (iHorVerPnt[i1] == 0)
                                        e.Graphics.DrawString(str, font, (Brush)solidBrush1, (float)(x2 + num5 / 4), (float)(num8 - num5 + 2));
                                    if (iHorVerPnt[i1] > 0)
                                        RotTextPrevPrint(e, str, x2, num8, num5, 270, iColor, 0);
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void Print_Polygons(
          PrintPageEventArgs e,
          string fitemPoly,
          int kPoly,
          string[] namePoly,
          int[] kPol1,
          int[] kPol2,
          double[] xLab,
          double[] yLab,
          double[] arCalc,
          double[] arLeg,
          int[] nSymb,
          int[] iHorVer,
          double[] xPol,
          double[] yPol,
          int[] ki1,
          int[] ki2,
          double[] xi,
          double[] yi,
          int kSymbPoly,
          int[] np1Sign,
          int[] np2Sign,
          int[] nItem,
          int[] nBackCol,
          int[] npTxtCol,
          double[] hpFont,
          string[] sInscr,
          int[] nOneSymb,
          int[] ixSqu,
          int[] iySqu,
          int[] nColItem,
          SolidBrush[] brColor,
          Pen[] pnColor,
          double sPixInch,
          int iScaleMap,
          double[] xCorner,
          double[] yCorner,
          int xPrintBeg,
          int yPrintBeg,
          int iColorPrint,
          double[] xa,
          double[] ya,
          double[] xb,
          double[] yb,
          int[] nf,
          double[] xf,
          double[] yf)
        {
            Graphics graphics = e.Graphics;
            string sTxt = "";
            double num1 = 0.01 * (double)iScaleMap;
            double[] xExt = new double[10];
            double[] yExt = new double[10];
            int kExt = -1;
            if (kPoly <= 0)
                return;
            int kArray = 999999;
            stringArray(namePoly, ref kArray);
            intArray(kPol1, ref kArray);
            intArray(kPol2, ref kArray);
            intArray(nSymb, ref kArray);
            doubleArray(xLab, ref kArray);
            doubleArray(yLab, ref kArray);
            doubleArray(arCalc, ref kArray);
            doubleArray(arLeg, ref kArray);
            if (kPoly > kArray)
            {
                int num2 = (int)MessageBox.Show("Индекс массива Print_PolyDraw");
            }
            else
            {
                int num3 = kPol2[kPoly];
                kArray = 999999;
                doubleArray(xPol, ref kArray);
                doubleArray(yPol, ref kArray);
                if (num3 > kArray)
                {
                    int num4 = (int)MessageBox.Show("Индекс массива Print_PolyDraw");
                }
                else
                {
                    kArray = 999999;
                    doubleArray(xCorner, ref kArray);
                    doubleArray(yCorner, ref kArray);
                    if (kArray < 5)
                    {
                        int num5 = (int)MessageBox.Show("Индекс массива Print_PolyDraw");
                    }
                    else
                    {
                        for (int i = 1; i <= 5; ++i)
                        {
                            double num6 = xCorner[i] - xCorner[2];
                            double num7 = yCorner[i] - yCorner[2];
                            int int32_1 = Convert.ToInt32(10.0 * num6 / num1 / sPixInch);
                            int int32_2 = Convert.ToInt32(10.0 * num7 / num1 / sPixInch);
                            int num8 = xPrintBeg + int32_1;
                            int num9 = yPrintBeg - int32_2;
                            ++kExt;
                            xExt[kExt] = (double)num8;
                            yExt[kExt] = (double)num9;
                        }
                        for (int i1 = 1; i1 <= kPoly; ++i1)
                        {
                            int i2 = 0;
                            for (int i3 = 1; i3 <= kSymbPoly; ++i3)
                            {
                                if (np2Sign[i3] > 0 && np2Sign[i3] == nSymb[i1])
                                {
                                    i2 = np1Sign[i3];
                                    break;
                                }
                            }
                            if (i2 == 0)
                            {
                                for (int i4 = 1; i4 <= kSymbPoly; ++i4)
                                {
                                    if (np1Sign[i4] > 0 && np1Sign[i4] == nSymb[i1])
                                    {
                                        i2 = np1Sign[i4];
                                        break;
                                    }
                                }
                            }
                            int num10 = iHorVer[i1];
                            int nSelect = nItem[i2];
                            int num11 = kPol1[i1];
                            int num12 = kPol2[i1];
                            int k = -1;
                            for (int i5 = num11; i5 <= num12; ++i5)
                            {
                                ++k;
                                xa[k] = xPol[i5];
                                ya[k] = yPol[i5];
                            }
                            int i6 = 0;
                            int i7 = 0;
                            for (int i8 = 1; i8 <= kPoly; ++i8)
                            {
                                if (i1 != i8 && arCalc[i8] < arCalc[i1])
                                {
                                    int num13 = kPol1[i8];
                                    int num14 = kPol2[i8];
                                    int num15 = 0;
                                    for (int i9 = num13; i9 <= num14; ++i9)
                                    {
                                        if (in_out(k, ref xa, ref ya, xPol[i9], yPol[i9]) > 0)
                                        {
                                            double num16 = xPol[i9] - xCorner[2];
                                            double num17 = yPol[i9] - yCorner[2];
                                            int int32_3 = Convert.ToInt32(10.0 * num16 / num1 / sPixInch);
                                            int int32_4 = Convert.ToInt32(10.0 * num17 / num1 / sPixInch);
                                            int num18 = xPrintBeg + int32_3;
                                            int num19 = yPrintBeg - int32_4;
                                            ++num15;
                                            ++i6;
                                            xi[i6] = (double)num18;
                                            yi[i6] = (double)num19;
                                        }
                                    }
                                    if (num15 > 1)
                                    {
                                        ++i7;
                                        if (i7 == 1)
                                        {
                                            ki1[1] = 1;
                                            ki2[1] = num15;
                                        }
                                        if (i7 > 1)
                                        {
                                            ki1[i7] = ki2[i7 - 1] + 1;
                                            ki2[i7] = ki2[i7 - 1] + num15;
                                        }
                                    }
                                }
                            }
                            int kCent = -1;
                            for (int i10 = num11; i10 <= num12; ++i10)
                            {
                                double num20 = xPol[i10] - xCorner[2];
                                double num21 = yPol[i10] - yCorner[2];
                                int int32_5 = Convert.ToInt32(10.0 * num20 / num1 / sPixInch);
                                int int32_6 = Convert.ToInt32(10.0 * num21 / num1 / sPixInch);
                                int num22 = xPrintBeg + int32_5;
                                int num23 = yPrintBeg - int32_6;
                                ++kCent;
                                xa[kCent] = (double)num22;
                                ya[kCent] = (double)num23;
                            }
                            int kd = 0;
                            int kInt = 0;
                            PolyIntersect(kExt, xExt, yExt, kCent, xa, ya, out kd, xb, yb, out kInt, nf, xf, yf);
                            if (kInt >= 0)
                            {
                                Point[] points = new Point[kInt + 1];
                                for (int i11 = 0; i11 <= kInt; ++i11)
                                {
                                    points[i11].X = Convert.ToInt32(xf[i11]);
                                    points[i11].Y = Convert.ToInt32(yf[i11]);
                                }
                                int i12 = nBackCol[i2];
                                switch (i12)
                                {
                                    case 0:
                                    case 10:
                                        SolidBrush solidBrush1 = new SolidBrush(Color.White);
                                        graphics.FillPolygon((Brush)solidBrush1, points);
                                        break;
                                    default:
                                        if (iColorPrint != 0)
                                            break;
                                        goto case 0;
                                }
                                if (i12 == 1 && iColorPrint == 0)
                                {
                                    SolidBrush solidBrush2 = new SolidBrush(Color.Black);
                                    graphics.FillPolygon((Brush)solidBrush2, points);
                                }
                                if (i12 > 0 && i12 < 10 && iColorPrint > 0)
                                {
                                    SolidBrush solidBrush3 = brColor[i12];
                                    graphics.FillPolygon((Brush)solidBrush3, points);
                                }
                                if (nSelect != 0)
                                {
                                    int iWid;
                                    int iHei;
                                    int kPix;
                                    SelItemPoly(fitemPoly, nSelect, out int _, out iWid, out iHei, out kPix, ixSqu, iySqu, nColItem, out sTxt, out int _);
                                    int nDensity = nOneSymb[i2];
                                    FullPolySymb(kInt, xf, yf, nDensity, iHei, iWid, out kCent, xa, ya);
                                    if (kCent != 0)
                                    {
                                        for (int i13 = 1; i13 <= kCent; ++i13)
                                        {
                                            int num24 = Convert.ToInt32(xa[i13]) - iWid / 2;
                                            int num25 = Convert.ToInt32(ya[i13]) - iHei / 2;
                                            for (int i14 = 1; i14 <= kPix; ++i14)
                                            {
                                                int x = num24 + ixSqu[i14];
                                                int y = num25 + iySqu[i14];
                                                double xt = (double)x;
                                                double yt = (double)y;
                                                if (in_out(kInt, ref xf, ref yf, xt, yt) != 0)
                                                {
                                                    int i15 = nColItem[i14];
                                                    SolidBrush solidBrush4 = brColor[i15];
                                                    graphics.FillRectangle((Brush)solidBrush4, x, y, 1, 1);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void KeepTriang(
          string fileTrian,
          double x1,
          double y1,
          double x2,
          double y2,
          int kTre,
          int[] nTre,
          double[] xTre,
          double[] yTre,
          double[] zTre)
        {
            if (kTre < 4)
                return;
            if (File.Exists(fileTrian))
                File.Delete(fileTrian);
            FileStream output = new FileStream(fileTrian, FileMode.CreateNew);
            BinaryWriter binaryWriter = new BinaryWriter((Stream)output);
            binaryWriter.Write(x1);
            binaryWriter.Write(y1);
            binaryWriter.Write(x2);
            binaryWriter.Write(y2);
            binaryWriter.Write(kTre);
            for (int i = 1; i <= kTre; ++i)
            {
                binaryWriter.Write(nTre[i]);
                binaryWriter.Write(xTre[i]);
                binaryWriter.Write(yTre[i]);
                binaryWriter.Write(zTre[i]);
            }
            binaryWriter.Close();
            output.Close();
        }

        public static void LineSymbCoord(
          int xh,
          int yh,
          int xk,
          int yk,
          int kSymbLine,
          int hSymbLine,
          ref int[] x1Line,
          ref int[] y1Line,
          ref int[] x2Line,
          ref int[] y2Line,
          ref int[] xDescr,
          ref int[] yDescr,
          ref int[] x1Dens,
          ref int[] y1Dens,
          ref int[] x1Sign,
          ref int[] y1Sign,
          ref int[] x2Sign,
          ref int[] y2Sign,
          ref int[] n1Sign,
          ref int[] n2Sign,
          ref int[] iStyle1,
          ref int[] iStyle2,
          ref int[] iWidth1,
          ref int[] iWidth2,
          ref int[] nColLine,
          ref int[] nItem,
          ref int[] itemLoc,
          ref int[] nBaseSymb,
          ref string[] sInscr,
          ref double[] hInscr,
          ref int[] iColInscr,
          ref int[] iDensity)
        {
            int num1 = yh - hSymbLine;
            int kArray = 999999;
            intArray(x1Line, ref kArray);
            intArray(y1Line, ref kArray);
            intArray(x2Line, ref kArray);
            intArray(y2Line, ref kArray);
            if (kSymbLine > kArray)
            {
                int num2 = (int)MessageBox.Show("Индекс массива LineSymbCoord");
                kSymbLine = 0;
            }
            else
            {
                for (int i = 1; i <= kSymbLine; ++i)
                {
                    num1 += hSymbLine;
                    x1Line[i] = xh;
                    y1Line[i] = num1;
                    x2Line[i] = xk;
                    y2Line[i] = num1;
                    xDescr[i] = 140;
                    yDescr[i] = num1;
                    x1Dens[i] = 120;
                    y1Dens[i] = num1;
                    x1Sign[i] = 2;
                    y1Sign[i] = num1;
                    x2Sign[i] = 275;
                    y2Sign[i] = num1;
                    n1Sign[i] = i;
                    n2Sign[i] = i;
                    iStyle1[i] = 1;
                    iStyle2[i] = 1;
                    iWidth1[i] = 1;
                    iWidth2[i] = 1;
                    if (i == 2)
                    {
                        iStyle1[i] = 2;
                        iStyle2[i] = 2;
                        iWidth1[i] = 2;
                        iWidth2[i] = 2;
                    }
                    if (i == 3)
                    {
                        iStyle1[i] = 3;
                        iStyle2[i] = 3;
                    }
                    if (i == 4)
                    {
                        iStyle1[i] = 4;
                        iStyle2[i] = 4;
                    }
                    if (i == 5)
                    {
                        iStyle1[i] = 5;
                        iStyle2[i] = 5;
                    }
                    if (i == 6)
                    {
                        iStyle1[i] = 6;
                        iStyle2[i] = 6;
                    }
                    if (i == 7)
                    {
                        iWidth1[i] = 2;
                        iWidth2[i] = 2;
                        iStyle1[i] = 7;
                        iStyle2[i] = 7;
                    }
                    if (i == 8)
                    {
                        iStyle1[i] = 3;
                        iStyle2[i] = 1;
                        iWidth1[i] = 1;
                        iWidth2[i] = 1;
                    }
                    nColLine[i] = 1;
                    nItem[i] = 0;
                    itemLoc[i] = 2;
                    nBaseSymb[i] = i;
                    sInscr[i] = "abcd";
                    hInscr[i] = 2.0;
                    iColInscr[i] = 1;
                    iDensity[i] = 0;
                }
            }
        }

        public static void LineDraw(
          PaintEventArgs e,
          int kLine,
          int[] k1,
          int[] k2,
          double[] xLin,
          double[] yLin,
          double[] rRadLine,
          double scaleWin,
          double xBeg,
          double yBeg,
          int xWin,
          int yWin,
          Pen[] pnColor,
          int iPar)
        {
            Graphics graphics = e.Graphics;
            int num1;
            int yWin1 = num1 = 0;
            int xWin1 = num1;
            int yWin2 = num1;
            int xWin2 = num1;
            Pen pen = pnColor[iPar];
            pen.Width = 1f;
            if (iPar == 3)
                pen.Width = 2f;
            if (kLine <= 0)
                return;
            for (int i1 = 1; i1 <= kLine; ++i1)
            {
                int num2 = k1[i1];
                int num3 = k2[i1];
                if (rRadLine[i1] == 0.0)
                {
                    for (int i2 = num2 + 1; i2 <= num3; ++i2)
                    {
                        XYtoWIN(xLin[i2 - 1], yLin[i2 - 1], scaleWin, xBeg, yBeg, xWin, yWin, out xWin2, out yWin2);
                        if (xWin2 != 0 || yWin2 != 0)
                        {
                            XYtoWIN(xLin[i2], yLin[i2], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                            if (xWin1 != 0 || yWin1 != 0)
                            {
                                Point pt1 = new Point(xWin2, yWin2);
                                Point pt2 = new Point(xWin1, yWin1);
                                pen.DashStyle = DashStyle.Solid;
                                if (iPar == 3)
                                    pen.DashStyle = DashStyle.Dash;
                                graphics.DrawLine(pen, pt1, pt2);
                            }
                        }
                    }
                }
                if (rRadLine[i1] > 0.0 && iPar != 3)
                {
                    for (int i3 = num2 + 1; i3 <= num3; ++i3)
                    {
                        XYtoWIN(xLin[i3 - 1], yLin[i3 - 1], scaleWin, xBeg, yBeg, xWin, yWin, out xWin2, out yWin2);
                        if (xWin2 != 0 || yWin2 != 0)
                        {
                            XYtoWIN(xLin[i3], yLin[i3], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                            if (xWin1 != 0 || yWin1 != 0)
                            {
                                Point pt1 = new Point(xWin2, yWin2);
                                Point pt2 = new Point(xWin1, yWin1);
                                pen.DashStyle = DashStyle.Solid;
                                graphics.DrawLine(pen, pt1, pt2);
                            }
                        }
                    }
                }
                if (rRadLine[i1] > 0.0 && iPar == 3)
                {
                    for (int i4 = num2 + 4; i4 <= num3; i4 += 8)
                    {
                        XYtoWIN(xLin[i4 - 4], yLin[i4 - 4], scaleWin, xBeg, yBeg, xWin, yWin, out xWin2, out yWin2);
                        if (xWin2 != 0 || yWin2 != 0)
                        {
                            XYtoWIN(xLin[i4], yLin[i4], scaleWin, xBeg, yBeg, xWin, yWin, out xWin1, out yWin1);
                            if (xWin1 != 0 || yWin1 != 0)
                            {
                                Point pt1 = new Point(xWin2, yWin2);
                                Point pt2 = new Point(xWin1, yWin1);
                                graphics.DrawLine(pen, pt1, pt2);
                            }
                        }
                    }
                }
            }
        }

        public static void LastDelete(string fsymbPnt, string fPointPixel, ref int kSymbPnt)
        {
            if (kSymbPnt <= 1)
            {
                if (File.Exists(fsymbPnt))
                    File.Delete(fsymbPnt);
                kSymbPnt = 0;
            }
            else
            {
                if (!File.Exists(fPointPixel))
                    return;
                int num1 = kSymbPnt - 1;
                if (File.Exists(fsymbPnt))
                    File.Delete(fsymbPnt);
                FileStream output = new FileStream(fsymbPnt, FileMode.CreateNew);
                BinaryWriter binaryWriter = new BinaryWriter((Stream)output);
                FileStream input = new FileStream(fPointPixel, FileMode.Open, FileAccess.Read);
                BinaryReader binaryReader = new BinaryReader((Stream)input);
                try
                {
                    for (int i1 = 1; i1 <= num1; ++i1)
                    {
                        string str1 = binaryReader.ReadString();
                        int num2 = binaryReader.ReadInt32();
                        binaryWriter.Write(str1);
                        binaryWriter.Write(num2);
                        if (num2 == 0)
                        {
                            int num3 = binaryReader.ReadInt32();
                            string str2 = binaryReader.ReadString();
                            double num4 = binaryReader.ReadDouble();
                            double num5 = binaryReader.ReadDouble();
                            int num6 = binaryReader.ReadInt32();
                            int num7 = binaryReader.ReadInt32();
                            int num8 = binaryReader.ReadInt32();
                            binaryWriter.Write(num3);
                            binaryWriter.Write(str2);
                            binaryWriter.Write(num4);
                            binaryWriter.Write(num5);
                            binaryWriter.Write(num6);
                            binaryWriter.Write(num7);
                            binaryWriter.Write(num8);
                            if (num8 > 0)
                            {
                                for (int i2 = 1; i2 <= num8; ++i2)
                                {
                                    double num9 = binaryReader.ReadDouble();
                                    double num10 = binaryReader.ReadDouble();
                                    int num11 = binaryReader.ReadInt32();
                                    binaryWriter.Write(num9);
                                    binaryWriter.Write(num10);
                                    binaryWriter.Write(num11);
                                }
                            }
                            int num12 = binaryReader.ReadInt32();
                            binaryWriter.Write(num12);
                            if (num12 > 0)
                            {
                                for (int i3 = 1; i3 <= num12; ++i3)
                                {
                                    int num13 = binaryReader.ReadInt32();
                                    int num14 = binaryReader.ReadInt32();
                                    int num15 = binaryReader.ReadInt32();
                                    binaryWriter.Write(num13);
                                    binaryWriter.Write(num14);
                                    binaryWriter.Write(num15);
                                }
                            }
                        }
                        if (num2 > 0)
                        {
                            int num16 = binaryReader.ReadInt32();
                            int num17 = binaryReader.ReadInt32();
                            string str3 = binaryReader.ReadString();
                            int num18 = binaryReader.ReadInt32();
                            string str4 = binaryReader.ReadString();
                            double num19 = binaryReader.ReadDouble();
                            double num20 = binaryReader.ReadDouble();
                            int num21 = binaryReader.ReadInt32();
                            int num22 = binaryReader.ReadInt32();
                            binaryWriter.Write(num16);
                            binaryWriter.Write(num17);
                            binaryWriter.Write(str3);
                            binaryWriter.Write(num18);
                            binaryWriter.Write(str4);
                            binaryWriter.Write(num19);
                            binaryWriter.Write(num20);
                            binaryWriter.Write(num21);
                            binaryWriter.Write(num22);
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
                }
                binaryReader.Close();
                input.Close();
                binaryWriter.Close();
                output.Close();
                kSymbPnt = num1;
            }
        }

        public static void NameActNode(
          int kPnt,
          string[] namePnt,
          double[] xPnt,
          double[] yPnt,
          ref int kNode,
          ref string[] nameNode,
          ref double[] xNode,
          ref double[] yNode)
        {
            double num1;
            double num2 = num1 = 0.0;
            if (kNode == 0)
                return;
            for (int i = 1; i <= kNode; ++i)
                nameNode[i] = "no" + string.Format("{0}", (object)i);
            if (kPnt < 0)
                return;
            for (int i1 = 1; i1 <= kNode; ++i1)
            {
                for (int i2 = 0; i2 <= kPnt; ++i2)
                {
                    double num3 = xNode[i1] - xPnt[i2];
                    double num4 = yNode[i1] - yPnt[i2];
                    if (Math.Sqrt(num3 * num3 + num4 * num4) < 0.003)
                    {
                        nameNode[i1] = namePnt[i2];
                        break;
                    }
                }
            }
        }

        public static void LastLineItem(ref int kItemLine, string fitemLine, string fLinePixel)
        {
            if (kItemLine <= 1)
            {
                if (File.Exists(fitemLine))
                    File.Delete(fitemLine);
                kItemLine = 0;
            }
            else
            {
                if (!File.Exists(fLinePixel))
                    return;
                int num1 = kItemLine - 1;
                if (File.Exists(fitemLine))
                    File.Delete(fitemLine);
                FileStream output = new FileStream(fitemLine, FileMode.CreateNew);
                BinaryWriter binaryWriter = new BinaryWriter((Stream)output);
                FileStream input = new FileStream(fLinePixel, FileMode.Open, FileAccess.Read);
                BinaryReader binaryReader = new BinaryReader((Stream)input);
                try
                {
                    for (int i1 = 1; i1 <= num1; ++i1)
                    {
                        string str1 = binaryReader.ReadString();
                        int num2 = binaryReader.ReadInt32();
                        binaryWriter.Write(str1);
                        binaryWriter.Write(num2);
                        if (num2 == 0)
                        {
                            double num3 = binaryReader.ReadDouble();
                            double num4 = binaryReader.ReadDouble();
                            int num5 = binaryReader.ReadInt32();
                            int num6 = binaryReader.ReadInt32();
                            binaryWriter.Write(num3);
                            binaryWriter.Write(num4);
                            binaryWriter.Write(num5);
                            binaryWriter.Write(num6);
                            int num7 = binaryReader.ReadInt32();
                            binaryWriter.Write(num7);
                            if (num7 > 0)
                            {
                                for (int i2 = 1; i2 <= num7; ++i2)
                                {
                                    int num8 = binaryReader.ReadInt32();
                                    int num9 = binaryReader.ReadInt32();
                                    int num10 = binaryReader.ReadInt32();
                                    binaryWriter.Write(num8);
                                    binaryWriter.Write(num9);
                                    binaryWriter.Write(num10);
                                }
                            }
                        }
                        if (num2 > 0)
                        {
                            int num11 = binaryReader.ReadInt32();
                            int num12 = binaryReader.ReadInt32();
                            string str2 = binaryReader.ReadString();
                            double num13 = binaryReader.ReadDouble();
                            double num14 = binaryReader.ReadDouble();
                            int num15 = binaryReader.ReadInt32();
                            int num16 = binaryReader.ReadInt32();
                            binaryWriter.Write(num11);
                            binaryWriter.Write(num12);
                            binaryWriter.Write(str2);
                            binaryWriter.Write(num13);
                            binaryWriter.Write(num14);
                            binaryWriter.Write(num15);
                            binaryWriter.Write(num16);
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
                }
                binaryReader.Close();
                input.Close();
                binaryWriter.Close();
                output.Close();
                kItemLine = num1;
            }
        }

        public static void LineItemCopy(string fitemLine1, string fitemLine2)
        {
            if (!File.Exists(fitemLine1))
                return;
            FileStream input = new FileStream(fitemLine1, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            if (File.Exists(fitemLine2))
                File.Delete(fitemLine2);
            FileStream output = new FileStream(fitemLine2, FileMode.CreateNew);
            BinaryWriter binaryWriter = new BinaryWriter((Stream)output);
            try
            {
                string str1;
                while ((str1 = binaryReader.ReadString()) != null)
                {
                    int num1 = binaryReader.ReadInt32();
                    binaryWriter.Write(str1);
                    binaryWriter.Write(num1);
                    if (num1 == 0)
                    {
                        double num2 = binaryReader.ReadDouble();
                        double num3 = binaryReader.ReadDouble();
                        int num4 = binaryReader.ReadInt32();
                        int num5 = binaryReader.ReadInt32();
                        binaryWriter.Write(num2);
                        binaryWriter.Write(num3);
                        binaryWriter.Write(num4);
                        binaryWriter.Write(num5);
                        int num6 = binaryReader.ReadInt32();
                        binaryWriter.Write(num6);
                        if (num6 > 0)
                        {
                            for (int i = 1; i <= num6; ++i)
                            {
                                int num7 = binaryReader.ReadInt32();
                                int num8 = binaryReader.ReadInt32();
                                int num9 = binaryReader.ReadInt32();
                                binaryWriter.Write(num7);
                                binaryWriter.Write(num8);
                                binaryWriter.Write(num9);
                            }
                        }
                    }
                    if (num1 > 0)
                    {
                        int num10 = binaryReader.ReadInt32();
                        int num11 = binaryReader.ReadInt32();
                        string str2 = binaryReader.ReadString();
                        double num12 = binaryReader.ReadDouble();
                        double num13 = binaryReader.ReadDouble();
                        int num14 = binaryReader.ReadInt32();
                        int num15 = binaryReader.ReadInt32();
                        binaryWriter.Write(num10);
                        binaryWriter.Write(num11);
                        binaryWriter.Write(str2);
                        binaryWriter.Write(num12);
                        binaryWriter.Write(num13);
                        binaryWriter.Write(num14);
                        binaryWriter.Write(num15);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            finally
            {
                binaryReader.Close();
                input.Close();
                binaryWriter.Close();
                output.Close();
            }
        }

        public static void LineSymbolKeep(
          string fileSymbLine,
          int kSymbLine,
          int hSymbLine,
          string[] sSymbLine,
          int[] x1Line,
          int[] y1Line,
          int[] x2Line,
          int[] y2Line,
          int[] xDescr,
          int[] yDescr,
          int[] x1Dens,
          int[] y1Dens,
          int[] x1Sign,
          int[] y1Sign,
          int[] x2Sign,
          int[] y2Sign,
          int[] n1Sign,
          int[] n2Sign,
          int[] iStyle1,
          int[] iStyle2,
          int[] iWidth1,
          int[] iWidth2,
          int[] nColLine,
          int[] nItem,
          int[] itemLoc,
          int[] nBaseSymb,
          string[] sInscr,
          double[] hInscr,
          int[] iColInscr,
          int[] iDensity)
        {
            if (File.Exists(fileSymbLine))
                File.Delete(fileSymbLine);
            FileStream output = new FileStream(fileSymbLine, FileMode.CreateNew);
            BinaryWriter binaryWriter = new BinaryWriter((Stream)output);
            binaryWriter.Write(kSymbLine);
            binaryWriter.Write(hSymbLine);
            for (int i = 1; i <= kSymbLine; ++i)
            {
                binaryWriter.Write(sSymbLine[i]);
                binaryWriter.Write(x1Line[i]);
                binaryWriter.Write(y1Line[i]);
                binaryWriter.Write(x2Line[i]);
                binaryWriter.Write(y2Line[i]);
                binaryWriter.Write(xDescr[i]);
                binaryWriter.Write(yDescr[i]);
                binaryWriter.Write(x1Dens[i]);
                binaryWriter.Write(y1Dens[i]);
                binaryWriter.Write(x1Sign[i]);
                binaryWriter.Write(y1Sign[i]);
                binaryWriter.Write(x2Sign[i]);
                binaryWriter.Write(y2Sign[i]);
                binaryWriter.Write(n1Sign[i]);
                binaryWriter.Write(n2Sign[i]);
                binaryWriter.Write(iStyle1[i]);
                binaryWriter.Write(iStyle2[i]);
                binaryWriter.Write(iWidth1[i]);
                binaryWriter.Write(iWidth2[i]);
                binaryWriter.Write(nColLine[i]);
                binaryWriter.Write(nItem[i]);
                binaryWriter.Write(itemLoc[i]);
                binaryWriter.Write(nBaseSymb[i]);
                binaryWriter.Write(sInscr[i]);
                binaryWriter.Write(hInscr[i]);
                binaryWriter.Write(iColInscr[i]);
                binaryWriter.Write(iDensity[i]);
            }
            binaryWriter.Close();
            output.Close();
        }

        public static void LineSymbolLoad(
          string fSymbLine,
          out int kSymbLine,
          out int hSymbLine,
          string[] sSymbLine,
          int[] x1Line,
          int[] y1Line,
          int[] x2Line,
          int[] y2Line,
          int[] xDescr,
          int[] yDescr,
          int[] x1Dens,
          int[] y1Dens,
          int[] x1Sign,
          int[] y1Sign,
          int[] x2Sign,
          int[] y2Sign,
          int[] n1Sign,
          int[] n2Sign,
          int[] iStyle1,
          int[] iStyle2,
          int[] iWidth1,
          int[] iWidth2,
          int[] nColLine,
          int[] nItem,
          int[] itemLoc,
          int[] nBaseSymb,
          string[] sInscr,
          double[] hInscr,
          int[] iColInscr,
          int[] iDensity)
        {
            kSymbLine = 0;
            hSymbLine = 0;
            if (!File.Exists(fSymbLine))
                return;
            FileStream input = new FileStream(fSymbLine, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            try
            {
                kSymbLine = binaryReader.ReadInt32();
                hSymbLine = binaryReader.ReadInt32();
                for (int i = 1; i <= kSymbLine; ++i)
                {
                    sSymbLine[i] = binaryReader.ReadString();
                    x1Line[i] = binaryReader.ReadInt32();
                    y1Line[i] = binaryReader.ReadInt32();
                    x2Line[i] = binaryReader.ReadInt32();
                    y2Line[i] = binaryReader.ReadInt32();
                    xDescr[i] = binaryReader.ReadInt32();
                    yDescr[i] = binaryReader.ReadInt32();
                    x1Dens[i] = binaryReader.ReadInt32();
                    y1Dens[i] = binaryReader.ReadInt32();
                    x1Sign[i] = binaryReader.ReadInt32();
                    y1Sign[i] = binaryReader.ReadInt32();
                    x2Sign[i] = binaryReader.ReadInt32();
                    y2Sign[i] = binaryReader.ReadInt32();
                    n1Sign[i] = binaryReader.ReadInt32();
                    n2Sign[i] = binaryReader.ReadInt32();
                    iStyle1[i] = binaryReader.ReadInt32();
                    iStyle2[i] = binaryReader.ReadInt32();
                    iWidth1[i] = binaryReader.ReadInt32();
                    iWidth2[i] = binaryReader.ReadInt32();
                    nColLine[i] = binaryReader.ReadInt32();
                    nItem[i] = binaryReader.ReadInt32();
                    itemLoc[i] = binaryReader.ReadInt32();
                    nBaseSymb[i] = binaryReader.ReadInt32();
                    sInscr[i] = binaryReader.ReadString();
                    hInscr[i] = binaryReader.ReadDouble();
                    iColInscr[i] = binaryReader.ReadInt32();
                    iDensity[i] = binaryReader.ReadInt32();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            finally
            {
                binaryReader.Close();
                input.Close();
            }
        }

        public static void NameNode(
          int num,
          int kPnt,
          string[] namePnt,
          double[] xPnt,
          double[] yPnt,
          ref int kNode,
          ref string[] nameNode,
          ref double[] xNode,
          ref double[] yNode)
        {
            double num1;
            double num2 = num1 = 0.0;
            if (kNode == 0)
                return;
            for (int i1 = 1; i1 <= kNode; ++i1)
            {
                int num3 = 0;
                for (int i2 = 0; i2 <= kPnt; ++i2)
                {
                    double num4 = xNode[i1] - xPnt[i2];
                    double num5 = yNode[i1] - yPnt[i2];
                    if (Math.Sqrt(num4 * num4 + num5 * num5) < 0.003)
                    {
                        ++num3;
                        nameNode[i1] = namePnt[i2];
                        break;
                    }
                }
                if (num3 == 0)
                {
                    ++num;
                    nameNode[i1] = string.Format("{0}", (object)num);
                }
            }
        }

        public static void PointSymbolCopy(string fsymbPnt1, string fsymbPnt2)
        {
            if (!File.Exists(fsymbPnt1))
                return;
            FileStream input = new FileStream(fsymbPnt1, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            if (File.Exists(fsymbPnt2))
                File.Delete(fsymbPnt2);
            FileStream output = new FileStream(fsymbPnt2, FileMode.CreateNew);
            BinaryWriter binaryWriter = new BinaryWriter((Stream)output);
            try
            {
                string str1;
                while ((str1 = binaryReader.ReadString()) != null)
                {
                    int num1 = binaryReader.ReadInt32();
                    binaryWriter.Write(str1);
                    binaryWriter.Write(num1);
                    if (num1 == 0)
                    {
                        int num2 = binaryReader.ReadInt32();
                        string str2 = binaryReader.ReadString();
                        double num3 = binaryReader.ReadDouble();
                        double num4 = binaryReader.ReadDouble();
                        int num5 = binaryReader.ReadInt32();
                        int num6 = binaryReader.ReadInt32();
                        int num7 = binaryReader.ReadInt32();
                        binaryWriter.Write(num2);
                        binaryWriter.Write(str2);
                        binaryWriter.Write(num3);
                        binaryWriter.Write(num4);
                        binaryWriter.Write(num5);
                        binaryWriter.Write(num6);
                        binaryWriter.Write(num7);
                        if (num7 > 0)
                        {
                            for (int i = 1; i <= num7; ++i)
                            {
                                double num8 = binaryReader.ReadDouble();
                                double num9 = binaryReader.ReadDouble();
                                int num10 = binaryReader.ReadInt32();
                                binaryWriter.Write(num8);
                                binaryWriter.Write(num9);
                                binaryWriter.Write(num10);
                            }
                        }
                        int num11 = binaryReader.ReadInt32();
                        binaryWriter.Write(num11);
                        if (num11 > 0)
                        {
                            for (int i = 1; i <= num11; ++i)
                            {
                                int num12 = binaryReader.ReadInt32();
                                int num13 = binaryReader.ReadInt32();
                                int num14 = binaryReader.ReadInt32();
                                binaryWriter.Write(num12);
                                binaryWriter.Write(num13);
                                binaryWriter.Write(num14);
                            }
                        }
                    }
                    if (num1 > 0)
                    {
                        int num15 = binaryReader.ReadInt32();
                        int num16 = binaryReader.ReadInt32();
                        string str3 = binaryReader.ReadString();
                        int num17 = binaryReader.ReadInt32();
                        string str4 = binaryReader.ReadString();
                        double num18 = binaryReader.ReadDouble();
                        double num19 = binaryReader.ReadDouble();
                        int num20 = binaryReader.ReadInt32();
                        int num21 = binaryReader.ReadInt32();
                        binaryWriter.Write(num15);
                        binaryWriter.Write(num16);
                        binaryWriter.Write(str3);
                        binaryWriter.Write(num17);
                        binaryWriter.Write(str4);
                        binaryWriter.Write(num18);
                        binaryWriter.Write(num19);
                        binaryWriter.Write(num20);
                        binaryWriter.Write(num21);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            finally
            {
                binaryReader.Close();
                input.Close();
                binaryWriter.Close();
                output.Close();
            }
        }

        public static void PointSymbLoad(
          string fsymbPnt,
          out int kSymbPnt,
          int[] numRec,
          int[] numUser,
          int[] heiSymb)
        {
            kSymbPnt = 0;
            if (!File.Exists(fsymbPnt))
                return;
            FileStream input = new FileStream(fsymbPnt, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            try
            {
                string str;
                while ((str = binaryReader.ReadString()) != null)
                {
                    int int32 = Convert.ToInt32(str);
                    int num1 = binaryReader.ReadInt32();
                    if (num1 == 0)
                    {
                        int num2 = binaryReader.ReadInt32();
                        binaryReader.ReadString();
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        binaryReader.ReadInt32();
                        int num3 = binaryReader.ReadInt32();
                        int num4 = binaryReader.ReadInt32();
                        if (num4 > 0)
                        {
                            for (int i = 1; i <= num4; ++i)
                            {
                                binaryReader.ReadDouble();
                                binaryReader.ReadDouble();
                                binaryReader.ReadInt32();
                            }
                        }
                        int num5 = binaryReader.ReadInt32();
                        if (num5 > 0)
                        {
                            for (int i = 1; i <= num5; ++i)
                            {
                                binaryReader.ReadInt32();
                                binaryReader.ReadInt32();
                                binaryReader.ReadInt32();
                            }
                        }
                        ++kSymbPnt;
                        heiSymb[kSymbPnt] = num3;
                        numRec[kSymbPnt] = int32;
                        numUser[kSymbPnt] = num2;
                    }
                    if (num1 > 0)
                    {
                        int num6 = binaryReader.ReadInt32();
                        binaryReader.ReadInt32();
                        binaryReader.ReadString();
                        int num7 = binaryReader.ReadInt32();
                        binaryReader.ReadString();
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        binaryReader.ReadInt32();
                        binaryReader.ReadInt32();
                        ++kSymbPnt;
                        heiSymb[kSymbPnt] = num6;
                        numRec[kSymbPnt] = int32;
                        numUser[kSymbPnt] = num7;
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            finally
            {
                binaryReader.Close();
                input.Close();
            }
        }

        public static void PolyLastItem(ref int kItemPoly, string fitemPoly, string fPolyPixel)
        {
            if (kItemPoly <= 1)
            {
                if (File.Exists(fitemPoly))
                    File.Delete(fitemPoly);
                kItemPoly = 0;
            }
            else
            {
                if (!File.Exists(fPolyPixel))
                    return;
                int num1 = kItemPoly - 1;
                if (File.Exists(fitemPoly))
                    File.Delete(fitemPoly);
                FileStream output = new FileStream(fitemPoly, FileMode.CreateNew);
                BinaryWriter binaryWriter = new BinaryWriter((Stream)output);
                FileStream input = new FileStream(fPolyPixel, FileMode.Open, FileAccess.Read);
                BinaryReader binaryReader = new BinaryReader((Stream)input);
                try
                {
                    for (int i1 = 1; i1 <= num1; ++i1)
                    {
                        string str1 = binaryReader.ReadString();
                        int num2 = binaryReader.ReadInt32();
                        binaryWriter.Write(str1);
                        binaryWriter.Write(num2);
                        if (num2 == 0)
                        {
                            double num3 = binaryReader.ReadDouble();
                            double num4 = binaryReader.ReadDouble();
                            int num5 = binaryReader.ReadInt32();
                            int num6 = binaryReader.ReadInt32();
                            binaryWriter.Write(num3);
                            binaryWriter.Write(num4);
                            binaryWriter.Write(num5);
                            binaryWriter.Write(num6);
                            int num7 = binaryReader.ReadInt32();
                            binaryWriter.Write(num7);
                            if (num7 > 0)
                            {
                                for (int i2 = 1; i2 <= num7; ++i2)
                                {
                                    int num8 = binaryReader.ReadInt32();
                                    int num9 = binaryReader.ReadInt32();
                                    int num10 = binaryReader.ReadInt32();
                                    binaryWriter.Write(num8);
                                    binaryWriter.Write(num9);
                                    binaryWriter.Write(num10);
                                }
                            }
                        }
                        if (num2 > 0)
                        {
                            int num11 = binaryReader.ReadInt32();
                            int num12 = binaryReader.ReadInt32();
                            string str2 = binaryReader.ReadString();
                            double num13 = binaryReader.ReadDouble();
                            double num14 = binaryReader.ReadDouble();
                            int num15 = binaryReader.ReadInt32();
                            int num16 = binaryReader.ReadInt32();
                            binaryWriter.Write(num11);
                            binaryWriter.Write(num12);
                            binaryWriter.Write(str2);
                            binaryWriter.Write(num13);
                            binaryWriter.Write(num14);
                            binaryWriter.Write(num15);
                            binaryWriter.Write(num16);
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
                }
                binaryReader.Close();
                input.Close();
                binaryWriter.Close();
                output.Close();
                kItemPoly = num1;
            }
        }

        public static void PolySymbCoord(
          int yBegin,
          int hSymbol,
          int kPolySymb,
          ref int[] xSign1,
          ref int[] ySign1,
          ref int[] xSymbol,
          ref int[] ySymbol,
          ref int[] xItem,
          ref int[] yItem,
          ref int[] xDescr,
          ref int[] yDescr,
          ref int[] xSign2,
          ref int[] ySign2)
        {
            int num1 = yBegin - hSymbol;
            int kArray = 999999;
            intArray(xSymbol, ref kArray);
            intArray(ySymbol, ref kArray);
            if (kPolySymb > kArray)
            {
                int num2 = (int)MessageBox.Show("Индекс массива PolySymbCoord");
            }
            else
            {
                for (int i = 1; i <= kPolySymb; ++i)
                {
                    num1 += hSymbol;
                    xSign1[i] = 5;
                    ySign1[i] = num1;
                    xSymbol[i] = 30;
                    ySymbol[i] = num1;
                    xItem[i] = 80;
                    yItem[i] = num1;
                    xDescr[i] = 120;
                    yDescr[i] = num1;
                    xSign2[i] = 275;
                    ySign2[i] = num1;
                }
            }
        }

        public static void PolyItemCopy(string fitemPoly1, string fitemPoly2)
        {
            if (!File.Exists(fitemPoly1))
                return;
            FileStream input = new FileStream(fitemPoly1, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            if (File.Exists(fitemPoly2))
                File.Delete(fitemPoly2);
            FileStream output = new FileStream(fitemPoly2, FileMode.CreateNew);
            BinaryWriter binaryWriter = new BinaryWriter((Stream)output);
            try
            {
                string str1;
                while ((str1 = binaryReader.ReadString()) != null)
                {
                    int num1 = binaryReader.ReadInt32();
                    binaryWriter.Write(str1);
                    binaryWriter.Write(num1);
                    if (num1 == 0)
                    {
                        double num2 = binaryReader.ReadDouble();
                        double num3 = binaryReader.ReadDouble();
                        int num4 = binaryReader.ReadInt32();
                        int num5 = binaryReader.ReadInt32();
                        binaryWriter.Write(num2);
                        binaryWriter.Write(num3);
                        binaryWriter.Write(num4);
                        binaryWriter.Write(num5);
                        int num6 = binaryReader.ReadInt32();
                        binaryWriter.Write(num6);
                        if (num6 > 0)
                        {
                            for (int i = 1; i <= num6; ++i)
                            {
                                int num7 = binaryReader.ReadInt32();
                                int num8 = binaryReader.ReadInt32();
                                int num9 = binaryReader.ReadInt32();
                                binaryWriter.Write(num7);
                                binaryWriter.Write(num8);
                                binaryWriter.Write(num9);
                            }
                        }
                    }
                    if (num1 > 0)
                    {
                        int num10 = binaryReader.ReadInt32();
                        int num11 = binaryReader.ReadInt32();
                        string str2 = binaryReader.ReadString();
                        double num12 = binaryReader.ReadDouble();
                        double num13 = binaryReader.ReadDouble();
                        int num14 = binaryReader.ReadInt32();
                        int num15 = binaryReader.ReadInt32();
                        binaryWriter.Write(num10);
                        binaryWriter.Write(num11);
                        binaryWriter.Write(str2);
                        binaryWriter.Write(num12);
                        binaryWriter.Write(num13);
                        binaryWriter.Write(num14);
                        binaryWriter.Write(num15);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            finally
            {
                binaryReader.Close();
                input.Close();
                binaryWriter.Close();
                output.Close();
            }
        }

        public static void PolyDescription(
          out int kPolySymb,
          string[] symbPoly,
          int[] nSign1,
          int[] nItem,
          int[] nSign2,
          int[] nBackCol,
          int[] npTxtCol,
          double[] hpFont,
          string[] sInscr,
          int[] kOneSymb)
        {
            kPolySymb = 0;
            int kArray = 999999;
            stringArray(symbPoly, ref kArray);
            if (kArray < 9)
            {
                int num = (int)MessageBox.Show("Индекс массива DescribePoly");
            }
            else
            {
                symbPoly[1] = "User's description";
                nSign1[1] = 1;
                nItem[1] = 0;
                nSign2[1] = 1;
                nBackCol[1] = 10;
                kOneSymb[1] = 0;
                kPolySymb = 1;
            }
        }

        public static void PolySymbolKeep(
          string fileSymbPoly,
          int kPolySymb,
          int hSymbPoly,
          string[] sPolySymb,
          int[] npSign1,
          int[] xpSign1,
          int[] ypSign1,
          int[] xpSymb,
          int[] ypSymb,
          int[] npItem,
          int[] xpItem,
          int[] ypItem,
          int[] xpDescr,
          int[] ypDescr,
          int[] npSign2,
          int[] xpSign2,
          int[] ypSign2,
          int[] nBackCol,
          int[] nOneSymb)
        {
            if (File.Exists(fileSymbPoly))
                File.Delete(fileSymbPoly);
            FileStream output = new FileStream(fileSymbPoly, FileMode.CreateNew);
            BinaryWriter binaryWriter = new BinaryWriter((Stream)output);
            binaryWriter.Write(kPolySymb);
            binaryWriter.Write(hSymbPoly);
            for (int i = 1; i <= kPolySymb; ++i)
            {
                binaryWriter.Write(sPolySymb[i]);
                binaryWriter.Write(npSign1[i]);
                binaryWriter.Write(xpSign1[i]);
                binaryWriter.Write(ypSign1[i]);
                binaryWriter.Write(xpSymb[i]);
                binaryWriter.Write(ypSymb[i]);
                binaryWriter.Write(npItem[i]);
                binaryWriter.Write(xpItem[i]);
                binaryWriter.Write(ypItem[i]);
                binaryWriter.Write(xpDescr[i]);
                binaryWriter.Write(ypDescr[i]);
                binaryWriter.Write(npSign2[i]);
                binaryWriter.Write(xpSign2[i]);
                binaryWriter.Write(ypSign2[i]);
                binaryWriter.Write(nBackCol[i]);
                binaryWriter.Write(nOneSymb[i]);
            }
            binaryWriter.Close();
            output.Close();
        }

        public static void SymbolSelect(
          string fsymbPnt,
          int nSelect,
          out string sOrder,
          out string sUser,
          out string sDescript,
          out int iLong)
        {
            string str1 = "";
            string str2 = "";
            sOrder = "";
            sUser = "";
            sDescript = "";
            int num1 = 0;
            iLong = 0;
            int num2 = 0;
            if (!File.Exists(fsymbPnt))
                return;
            FileStream input = new FileStream(fsymbPnt, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            try
            {
                for (int i1 = 1; i1 <= nSelect; ++i1)
                {
                    str2 = binaryReader.ReadString();
                    num2 = binaryReader.ReadInt32();
                    if (num2 == 0)
                    {
                        num1 = binaryReader.ReadInt32();
                        str1 = binaryReader.ReadString();
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        binaryReader.ReadInt32();
                        binaryReader.ReadInt32();
                        int num3 = binaryReader.ReadInt32();
                        if (num3 > 0)
                        {
                            for (int i2 = 1; i2 <= num3; ++i2)
                            {
                                binaryReader.ReadDouble();
                                binaryReader.ReadDouble();
                                binaryReader.ReadInt32();
                            }
                        }
                        int num4 = binaryReader.ReadInt32();
                        if (num4 > 0)
                        {
                            for (int i3 = 1; i3 <= num4; ++i3)
                            {
                                binaryReader.ReadInt32();
                                binaryReader.ReadInt32();
                                binaryReader.ReadInt32();
                            }
                        }
                    }
                    if (num2 > 0)
                    {
                        binaryReader.ReadInt32();
                        binaryReader.ReadInt32();
                        binaryReader.ReadString();
                        num1 = binaryReader.ReadInt32();
                        str1 = binaryReader.ReadString();
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        binaryReader.ReadInt32();
                        binaryReader.ReadInt32();
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            binaryReader.Close();
            input.Close();
            sOrder = str2;
            sUser = string.Format("{0}", (object)num1);
            sDescript = str1;
            iLong = num2;
        }

        public static void SymbolUpdate(
          string fsymbPnt,
          string fPointPixel,
          int kSymbPnt,
          int nSel,
          string sDefault,
          int iLong,
          int iUser,
          string ssDescript)
        {
            if (!File.Exists(fPointPixel))
                return;
            if (File.Exists(fsymbPnt))
                File.Delete(fsymbPnt);
            FileStream output = new FileStream(fsymbPnt, FileMode.CreateNew);
            BinaryWriter binaryWriter = new BinaryWriter((Stream)output);
            FileStream input = new FileStream(fPointPixel, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            try
            {
                for (int i1 = 1; i1 <= kSymbPnt; ++i1)
                {
                    string str1 = binaryReader.ReadString();
                    int num1 = binaryReader.ReadInt32();
                    binaryWriter.Write(str1);
                    binaryWriter.Write(num1);
                    if (num1 == 0)
                    {
                        int num2 = binaryReader.ReadInt32();
                        string str2 = binaryReader.ReadString();
                        double num3 = binaryReader.ReadDouble();
                        double num4 = binaryReader.ReadDouble();
                        int num5 = binaryReader.ReadInt32();
                        int num6 = binaryReader.ReadInt32();
                        int num7 = binaryReader.ReadInt32();
                        if (i1 == nSel && iLong == 0)
                        {
                            num2 = iUser;
                            str2 = ssDescript;
                        }
                        binaryWriter.Write(num2);
                        binaryWriter.Write(str2);
                        binaryWriter.Write(num3);
                        binaryWriter.Write(num4);
                        binaryWriter.Write(num5);
                        binaryWriter.Write(num6);
                        binaryWriter.Write(num7);
                        if (num7 > 0)
                        {
                            for (int i2 = 1; i2 <= num7; ++i2)
                            {
                                double num8 = binaryReader.ReadDouble();
                                double num9 = binaryReader.ReadDouble();
                                int num10 = binaryReader.ReadInt32();
                                binaryWriter.Write(num8);
                                binaryWriter.Write(num9);
                                binaryWriter.Write(num10);
                            }
                        }
                        int num11 = binaryReader.ReadInt32();
                        binaryWriter.Write(num11);
                        if (num11 > 0)
                        {
                            for (int i3 = 1; i3 <= num11; ++i3)
                            {
                                int num12 = binaryReader.ReadInt32();
                                int num13 = binaryReader.ReadInt32();
                                int num14 = binaryReader.ReadInt32();
                                binaryWriter.Write(num12);
                                binaryWriter.Write(num13);
                                binaryWriter.Write(num14);
                            }
                        }
                    }
                    if (num1 > 0)
                    {
                        int num15 = binaryReader.ReadInt32();
                        int num16 = binaryReader.ReadInt32();
                        string str3 = binaryReader.ReadString();
                        int num17 = binaryReader.ReadInt32();
                        string str4 = binaryReader.ReadString();
                        double num18 = binaryReader.ReadDouble();
                        double num19 = binaryReader.ReadDouble();
                        int num20 = binaryReader.ReadInt32();
                        int num21 = binaryReader.ReadInt32();
                        if (i1 == nSel && iLong > 0)
                        {
                            num17 = iUser;
                            str4 = ssDescript;
                        }
                        binaryWriter.Write(num15);
                        binaryWriter.Write(num16);
                        binaryWriter.Write(str3);
                        binaryWriter.Write(num17);
                        binaryWriter.Write(str4);
                        binaryWriter.Write(num18);
                        binaryWriter.Write(num19);
                        binaryWriter.Write(num20);
                        binaryWriter.Write(num21);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            binaryReader.Close();
            input.Close();
            binaryWriter.Close();
            output.Close();
        }

        public static void VertexAddition(
          int kLine,
          int[] k1,
          int[] k2,
          double[] radLine,
          double[] xLin,
          double[] yLin,
          int kPnt,
          double[] xPnt,
          double[] yPnt,
          double[] zPnt,
          out int kVert,
          double[] xVert,
          double[] yVert,
          double[] zVert,
          double[] xr,
          double[] yr,
          double[] zr,
          int[] nr,
          double[] radDop,
          double[] xDop,
          double[] yDop,
          double[] zDop,
          double[] rDop,
          int[] nDop,
          int[] nDop1,
          int[] nDop2)
        {
            kVert = 0;
            int kArray = 999999;
            doubleArray(xVert, ref kArray);
            doubleArray(yVert, ref kArray);
            doubleArray(zVert, ref kArray);
            int num1 = kArray - 3;
            for (int i1 = 1; i1 <= kLine; ++i1)
            {
                int num2 = k1[i1];
                int num3 = k2[i1];
                int i2 = 0;
                for (int i3 = num2; i3 <= num3; ++i3)
                {
                    if (i2 > 0)
                    {
                        double num4 = xr[i2] - xLin[i3];
                        double num5 = yr[i2] - yLin[i3];
                        if (Math.Sqrt(num4 * num4 + num5 * num5) < 0.005)
                            continue;
                    }
                    ++i2;
                    xr[i2] = xLin[i3];
                    yr[i2] = yLin[i3];
                    zr[i2] = 0.0;
                }
                int i4 = 0;
                for (int i5 = 1; i5 <= i2; ++i5)
                {
                    for (int i6 = 0; i6 <= kPnt; ++i6)
                    {
                        double num6 = xr[i5] - xPnt[i6];
                        double num7 = yr[i5] - yPnt[i6];
                        if (Math.Sqrt(num6 * num6 + num7 * num7) < 0.003)
                        {
                            zr[i5] = zPnt[i6];
                            ++i4;
                            nr[i4] = i5;
                            break;
                        }
                    }
                }
                for (int i7 = 2; i7 <= i4; ++i7)
                {
                    int i8 = nr[i7 - 1];
                    int i9 = nr[i7];
                    int kVert1;
                    TriangLine(xr[i8], yr[i8], zr[i8], xr[i9], yr[i9], zr[i9], kPnt, xPnt, yPnt, zPnt, out kVert1, xDop, yDop, zDop, rDop, nDop1, nDop2);
                    if (radLine[i1] == 0.0 && kVert1 > 0)
                    {
                        for (int i10 = 1; i10 <= kVert1; ++i10)
                        {
                            ++kVert;
                            xVert[kVert] = xDop[i10];
                            yVert[kVert] = yDop[i10];
                            zVert[kVert] = zDop[i10];
                        }
                    }
                    if (radLine[i1] > 0.0 && kVert1 > 0)
                    {
                        for (int i11 = 1; i11 <= kVert1; ++i11)
                        {
                            double num8 = 9999999.9;
                            int i12 = 0;
                            for (int i13 = i8; i13 <= i9; ++i13)
                            {
                                double num9 = xDop[i11] - xr[i13];
                                double num10 = yDop[i11] - yr[i13];
                                double num11 = Math.Sqrt(num9 * num9 + num10 * num10);
                                if (num8 > num11)
                                {
                                    num8 = num11;
                                    i12 = i13;
                                }
                            }
                            ++kVert;
                            xVert[kVert] = xr[i12];
                            yVert[kVert] = yr[i12];
                            zVert[kVert] = zDop[i11];
                        }
                    }
                }
            }
        }

        public static void TriangLine(
          double xh,
          double yh,
          double zh,
          double xk,
          double yk,
          double zk,
          int kPnt,
          double[] xPnt,
          double[] yPnt,
          double[] zPnt,
          out int kVert,
          double[] xVert,
          double[] yVert,
          double[] zVert,
          double[] rVert,
          int[] neInd,
          int[] nfInd)
        {
            double[] x1 = new double[10];
            double[] y1 = new double[10];
            double[] x2 = new double[10];
            double[] y2 = new double[10];
            double num1 = 3.1415926;
            kVert = 0;
            double x3 = xk - xh;
            double y3 = yk - yh;
            double num2 = Math.Sqrt(x3 * x3 + y3 * y3);
            double num3 = Math.Atan2(y3, x3);
            if (num3 < 0.0)
                num3 += 2.0 * num1;
            double num4 = num3 - 0.5 * num1;
            if (num4 < 0.0)
                num4 += 2.0 * num1;
            double num5 = 0.5 * (xh + xk);
            double num6 = 0.5 * (yh + yk);
            double num7 = num5 - num2 * Math.Cos(num3);
            double num8 = num6 - num2 * Math.Sin(num3);
            double num9 = num5 + num2 * Math.Cos(num3);
            double num10 = num6 + num2 * Math.Sin(num3);
            double x1_1 = xh;
            double y1_1 = yh;
            double x2_1 = xk;
            double y2_1 = yk;
            x1[0] = x1_1;
            y1[0] = y1_1;
            x1[1] = x1_1 + 0.5 * num2 * Math.Cos(num4);
            y1[1] = y1_1 + 0.5 * num2 * Math.Sin(num4);
            x1[2] = x2_1 + 0.5 * num2 * Math.Cos(num4);
            y1[2] = y2_1 + 0.5 * num2 * Math.Sin(num4);
            x1[3] = x2_1;
            y1[3] = y2_1;
            x1[4] = x1_1;
            y1[4] = y1_1;
            int k1 = 4;
            x2[0] = x1_1;
            y2[0] = y1_1;
            x2[1] = x1_1 - 0.5 * num2 * Math.Cos(num4);
            y2[1] = y1_1 - 0.5 * num2 * Math.Sin(num4);
            x2[2] = x2_1 - 0.5 * num2 * Math.Cos(num4);
            y2[2] = y2_1 - 0.5 * num2 * Math.Sin(num4);
            x2[3] = x2_1;
            y2[3] = y2_1;
            x2[4] = x1_1;
            y2[4] = y1_1;
            int k2 = 4;
            int kfn;
            int ken = kfn = 0;
            int ip1;
            for (int i = 0; i <= kPnt; ++i)
            {
                double num11 = xPnt[i] - xh;
                double num12 = yPnt[i] - yh;
                if (Math.Sqrt(num11 * num11 + num12 * num12) >= 0.1)
                {
                    double num13 = xPnt[i] - xk;
                    double num14 = yPnt[i] - yk;
                    if (Math.Sqrt(num13 * num13 + num14 * num14) >= 0.1)
                    {
                        ip1 = in_out(k1, ref x1, ref y1, xPnt[i], yPnt[i]);
                        if (ip1 > 0)
                        {
                            ++ken;
                            neInd[ken] = i;
                        }
                        else
                        {
                            ip1 = in_out(k2, ref x2, ref y2, xPnt[i], yPnt[i]);
                            if (ip1 > 0)
                            {
                                ++kfn;
                                nfInd[kfn] = i;
                            }
                        }
                    }
                }
            }
            if (ken == 0 && kfn == 0)
                return;
            if (ken == 0 && kfn > 0)
            {
                double num15 = 0.5 * (xh + xk);
                double num16 = 0.5 * (yh + yk);
                double num17 = 0.5 * (zh + zk);
                for (int i1 = 1; i1 <= kfn; ++i1)
                {
                    double num18 = xk - xh;
                    double num19 = yk - yh;
                    double num20 = 0.5 * Math.Sqrt(num18 * num18 + num19 * num19);
                    int i2 = nfInd[i1];
                    double num21 = xPnt[i2] - num15;
                    double num22 = yPnt[i2] - num16;
                    if (Math.Sqrt(num21 * num21 + num22 * num22) < num20)
                    {
                        ++kVert;
                        xVert[kVert] = num15;
                        yVert[kVert] = num16;
                        zVert[kVert] = num17;
                        rVert[kVert] = num20;
                        break;
                    }
                }
            }
            else if (ken > 0 && kfn == 0)
            {
                double num23 = 0.5 * (xh + xk);
                double num24 = 0.5 * (yh + yk);
                double num25 = 0.5 * (zh + zk);
                for (int i3 = 1; i3 <= ken; ++i3)
                {
                    double num26 = xk - xh;
                    double num27 = yk - yh;
                    double num28 = 0.5 * Math.Sqrt(num26 * num26 + num27 * num27);
                    int i4 = neInd[i3];
                    double num29 = xPnt[i4] - num23;
                    double num30 = yPnt[i4] - num24;
                    if (Math.Sqrt(num29 * num29 + num30 * num30) < num28)
                    {
                        ++kVert;
                        xVert[kVert] = num23;
                        yVert[kVert] = num24;
                        zVert[kVert] = num25;
                        rVert[kVert] = num28;
                        break;
                    }
                }
            }
            else
            {
                double num31;
                double num32 = num31 = 0.0;
                double y1_2 = num31;
                double x1_2 = num31;
                double num33;
                double num34 = num33 = 0.0;
                double num35;
                double num36 = num35 = 0.0;
                int i5 = 0;
                if (ken > 0 && kfn > 0)
                {
                    i5 = ken;
                    for (int i6 = 1; i6 <= kfn; ++i6)
                    {
                        ++i5;
                        neInd[i5] = nfInd[i6];
                    }
                    for (int i7 = 1; i7 <= i5; ++i7)
                    {
                        int i8 = neInd[i7];
                        double dist;
                        DistPnt(xPnt[i8], yPnt[i8], xh, yh, xk, yk, out dist, out ip1, out x1_2, out y1_2);
                        int i1;
                        int i2;
                        PointBox(x1_2, y1_2, ken, neInd, kfn, nfInd, xPnt, yPnt, out i1, out i2);
                        double x3_1 = xPnt[i1];
                        double y3_1 = yPnt[i1];
                        double num37 = zPnt[i1];
                        double x4 = xPnt[i2];
                        double y4 = yPnt[i2];
                        double num38 = zPnt[i2];
                        int ip2 = 1;
                        TwoLine(x1_1, y1_1, x3_1, y3_1, x2_1, y2_1, x4, y4, out x1_2, out y1_2, ref ip2);
                        if (zh != 0.0 && zk != 0.0)
                        {
                            double num39 = x1_2 - xh;
                            double num40 = y1_2 - yh;
                            dist = Math.Sqrt(num39 * num39 + num40 * num40);
                            num32 = zh + dist * (zk - zh) / num2;
                        }
                        if (num37 != 0.0 && num38 != 0.0 && num32 == 0.0)
                        {
                            double num41 = x4 - x3_1;
                            double num42 = y4 - y3_1;
                            double num43 = Math.Sqrt(num41 * num41 + num42 * num42);
                            double num44 = x1_2 - x3_1;
                            double num45 = y1_2 - y3_1;
                            dist = Math.Sqrt(num44 * num44 + num45 * num45);
                            num32 = num37 + dist * (num38 - num37) / num43;
                        }
                        ip1 = 0;
                        if (kVert > 0)
                        {
                            for (int i9 = 1; i9 <= kVert; ++i9)
                            {
                                double num46 = xVert[i9] - x1_2;
                                double num47 = yVert[i9] - y1_2;
                                dist = Math.Sqrt(num46 * num46 + num47 * num47);
                                if (dist < 0.1)
                                {
                                    ++ip1;
                                    break;
                                }
                            }
                        }
                        if (ip1 == 0)
                        {
                            double num48 = x1_2 - xh;
                            double num49 = y1_2 - yh;
                            ++kVert;
                            xVert[kVert] = x1_2;
                            yVert[kVert] = y1_2;
                            zVert[kVert] = num32;
                            rVert[kVert] = Math.Sqrt(num48 * num48 + num49 * num49);
                        }
                    }
                }
                if (kVert > 1)
                {
                    for (int i10 = 1; i10 < kVert; ++i10)
                    {
                        for (int i11 = i10 + 1; i11 <= kVert; ++i11)
                        {
                            if (rVert[i10] > rVert[i11])
                            {
                                x1_2 = xVert[i10];
                                double num50 = yVert[i10];
                                double num51 = zVert[i10];
                                double num52 = rVert[i10];
                                xVert[i10] = xVert[i11];
                                yVert[i10] = yVert[i11];
                                zVert[i10] = zVert[i11];
                                rVert[i10] = rVert[i11];
                                xVert[i11] = x1_2;
                                yVert[i11] = num50;
                                zVert[i11] = num51;
                                rVert[i11] = num52;
                            }
                        }
                    }
                }
                if (kVert > 1)
                {
                    for (int i12 = 2; i12 <= kVert; ++i12)
                    {
                        double num53 = xVert[i12] - xVert[i12 - 1];
                        double num54 = yVert[i12] - yVert[i12 - 1];
                        double num55 = Math.Sqrt(num53 * num53 + num54 * num54);
                        x1_2 = 0.5 * (xVert[i12] + xVert[i12 - 1]);
                        double num56 = 0.5 * (yVert[i12] + yVert[i12 - 1]);
                        double num57 = 0.5 * (zVert[i12] + zVert[i12 - 1]);
                        for (int i13 = 1; i13 <= i5; ++i13)
                        {
                            int i14 = neInd[i13];
                            double num58 = xPnt[i14] - x1_2;
                            double num59 = yPnt[i14] - num56;
                            if (Math.Sqrt(num58 * num58 + num59 * num59) <= 0.5 * num55)
                            {
                                ++kVert;
                                xVert[kVert] = x1_2;
                                yVert[kVert] = num56;
                                zVert[kVert] = num57;
                                rVert[kVert] = rVert[i12 - 1] + 0.5 * num55;
                                break;
                            }
                        }
                    }
                }
                double num60 = xk - xVert[kVert];
                double num61 = yk - yVert[kVert];
                double num62 = Math.Sqrt(num60 * num60 + num61 * num61);
                x1_2 = 0.5 * (xk + xVert[kVert]);
                double num63 = 0.5 * (yk + yVert[kVert]);
                double num64 = 0.5 * (zk + zVert[kVert]);
                for (int i15 = 1; i15 <= i5; ++i15)
                {
                    int i16 = neInd[i15];
                    double num65 = xPnt[i16] - x1_2;
                    double num66 = yPnt[i16] - num63;
                    if (Math.Sqrt(num65 * num65 + num66 * num66) <= 0.5 * num62)
                    {
                        ++kVert;
                        xVert[kVert] = x1_2;
                        yVert[kVert] = num63;
                        zVert[kVert] = num64;
                        rVert[kVert] = rVert[kVert - 1] + 0.5 * num62;
                        break;
                    }
                }
                double num67 = xVert[1] - xh;
                double num68 = yVert[1] - yh;
                double num69 = Math.Sqrt(num67 * num67 + num68 * num68);
                x1_2 = 0.5 * (xh + xVert[1]);
                double num70 = 0.5 * (yh + yVert[1]);
                double num71 = 0.5 * (zh + zVert[1]);
                for (int i17 = 1; i17 <= i5; ++i17)
                {
                    int i18 = neInd[i17];
                    double num72 = xPnt[i18] - x1_2;
                    double num73 = yPnt[i18] - num70;
                    if (Math.Sqrt(num72 * num72 + num73 * num73) <= 0.5 * num69)
                    {
                        ++kVert;
                        xVert[kVert] = x1_2;
                        yVert[kVert] = num70;
                        zVert[kVert] = num71;
                        rVert[kVert] = 0.5 * num69;
                    }
                }
            }
        }

        public static void PointBox(
            double x1,
            double y1,
            int ken,
            int[] neInd,
            int kfn,
            int[] nfInd,
            double[] xPnt,
            double[] yPnt,
            out int i1,
            out int i2)
        {
            i1 = i2 = 0;
            double num1 = 9999999.9;
            for (int index1 = 1; index1 <= ken; ++index1)
            {
                int index2 = neInd[index1];
                double num2 = xPnt[index2] - x1;
                double num3 = yPnt[index2] - y1;
                double num4 = Math.Sqrt(num2 * num2 + num3 * num3);
                if (num1 > num4)
                {
                    num1 = num4;
                    i1 = index2;
                }
            }
            double num5 = 9999999.9;
            for (int index3 = 1; index3 <= kfn; ++index3)
            {
                int index4 = nfInd[index3];
                double num6 = xPnt[index4] - x1;
                double num7 = yPnt[index4] - y1;
                double num8 = Math.Sqrt(num6 * num6 + num7 * num7);
                if (num5 > num8)
                {
                    num5 = num8;
                    i2 = index4;
                }
            }
        }

        public static void PhotoCorrect(
          int km,
          int[] nm,
          double[] xm,
          double[] ym,
          double xo,
          double yo,
          int kMet,
          int k,
          ref double[] x,
          ref double[] y,
          out int iCond)
        {
            int[] nt1 = new int[11];
            int[] nt2 = new int[11];
            int[] l = new int[11];
            int[] m = new int[11];
            double[] a1 = new double[11];
            double[] a2 = new double[11];
            double[] b1 = new double[11];
            double[] b2 = new double[11];
            double[] a3 = new double[101];
            double[] a4 = new double[101];
            double[] numArray1 = new double[11];
            double[] numArray2 = new double[11];
            double[] xt1 = new double[11];
            double[] yt1 = new double[11];
            double[] xt2 = new double[11];
            double[] yt2 = new double[11];
            double[] dv1 = new double[11];
            double[] dv2 = new double[11];
            iCond = 0;
            int iParam = 1;
            int kArray1 = 999999;
            doubleArray(xm, ref kArray1);
            doubleArray(ym, ref kArray1);
            intArray(nm, ref kArray1);
            if (km > kArray1)
            {
                int num = (int)MessageBox.Show("Индекс массива PhotoCorrect");
                iCond = -99;
            }
            else
            {
                int kArray2 = 999999;
                doubleArray(x, ref kArray2);
                doubleArray(y, ref kArray2);
                if (k > kArray2)
                {
                    int num = (int)MessageBox.Show("Индекс массива PhotoCorrect");
                    iCond = -99;
                }
                else
                {
                    int kMark1;
                    int iprz1;
                    MonoMark(kMet, x, y, out kMark1, ref nt1, ref xt1, ref yt1, out iprz1);
                    int kMark2;
                    int iprz2;
                    MonoMark(km, xm, ym, out kMark2, ref nt2, ref xt2, ref yt2, out iprz2);
                    if (kMark1 < 4 || kMark2 < 4)
                        iCond = -1;
                    else if (kMark1 != 4 && kMark1 != 8)
                        iCond = -2;
                    else if (kMark2 != 4 && kMark2 != 8)
                    {
                        iCond = -2;
                    }
                    else
                    {
                        if (iprz1 != iprz2)
                        {
                            if (kMark1 == kMark2)
                            {
                                iCond = -3;
                                return;
                            }
                            if (iprz1 == 1 && iprz2 == 8)
                            {
                                int num = 4;
                                numArray1[1] = xt2[5];
                                numArray2[1] = yt2[5];
                                numArray1[2] = xt2[6];
                                numArray2[2] = yt2[6];
                                numArray1[3] = xt2[7];
                                numArray2[3] = yt2[7];
                                numArray1[4] = xt2[8];
                                numArray2[4] = yt2[8];
                                kMark2 = 4;
                                for (int i = 1; i <= num; ++i)
                                {
                                    nt2[i] = i;
                                    xt2[i] = numArray1[i];
                                    yt2[i] = numArray2[i];
                                }
                            }
                            if (iprz1 == 8 && iprz2 == 1)
                            {
                                int num = 4;
                                numArray1[1] = xt1[5];
                                numArray2[1] = yt1[5];
                                numArray1[2] = xt1[6];
                                numArray2[2] = yt1[6];
                                numArray1[3] = xt1[7];
                                numArray2[3] = yt1[7];
                                numArray1[4] = xt1[8];
                                numArray2[4] = yt1[8];
                                kMark1 = 4;
                                for (int i = 1; i <= num; ++i)
                                {
                                    nt1[i] = i;
                                    xt1[i] = numArray1[i];
                                    yt1[i] = numArray2[i];
                                }
                            }
                            if (iprz1 == 8 && iprz2 == 4)
                                kMark1 = 4;
                        }
                        double x1 = xt1[1];
                        double y1 = yt1[1];
                        double x2 = xt1[2];
                        double y2 = yt1[2];
                        double x3 = xt1[3];
                        double y3 = yt1[3];
                        double x4 = xt1[4];
                        double y4 = yt1[4];
                        double num1 = 0.0;
                        double num2 = 0.0;
                        int ip = 1;
                        TwoLine(x1, y1, x3, y3, x2, y2, x4, y4, out num1, out num2, ref ip);
                        for (int i = 1; i <= k; ++i)
                        {
                            x[i] = x[i] - num1;
                            y[i] = y[i] - num2;
                        }
                        for (int i = 1; i <= kMark1; ++i)
                        {
                            xt1[i] = xt1[i] - num1;
                            yt1[i] = yt1[i] - num2;
                        }
                        for (int i = 1; i <= 100; ++i)
                        {
                            a3[i] = 0.0;
                            a4[i] = 0.0;
                        }
                        for (int i = 1; i <= 10; ++i)
                        {
                            a1[i] = 0.0;
                            a2[i] = 0.0;
                        }
                        for (int i = 1; i <= kMark1; ++i)
                        {
                            dv1[i] = xt1[i] - xt2[i] + xo;
                            dv2[i] = yt1[i] - yt2[i] + yo;
                        }
                        int nEqua = kMark1 - 1;
                        int nDeg;
                        FactNorm(nEqua, kMark1, xt1, yt1, dv1, ref a3, ref a1, out nDeg, iParam);
                        FactNorm(nEqua, kMark1, xt1, yt1, dv2, ref a4, ref a2, out nDeg, iParam);
                        for (int i = 1; i <= nDeg; ++i)
                        {
                            b1[i] = -a1[i];
                            b2[i] = -a2[i];
                        }
                        double d;
                        Minv(ref a3, nDeg, out d, ref l, ref m);
                        Gmprd(a3, b1, ref a1, nDeg, nDeg, 1);
                        Minv(ref a4, nDeg, out d, ref l, ref m);
                        Gmprd(a4, b2, ref a2, nDeg, nDeg, 1);
                        for (int i = 1; i <= k; ++i)
                        {
                            double x5 = x[i];
                            double y5 = y[i];
                            CoorPnt(nDeg, x5, y5, a1, out num1, iParam);
                            x[i] = x[i] + num1 + xo;
                            CoorPnt(nDeg, x5, y5, a2, out num2, iParam);
                            y[i] = y[i] + num2 + yo;
                        }
                        for (int i = 1; i <= kMark1; ++i)
                        {
                            double x6 = xt1[i];
                            double y6 = yt1[i];
                            CoorPnt(nDeg, x6, y6, a1, out num1, iParam);
                            xt1[i] = xt1[i] + num1 + xo;
                            CoorPnt(nDeg, x6, y6, a2, out num2, iParam);
                            yt1[i] = yt1[i] + num2 + yo;
                        }
                        for (int i = 1; i <= kMark1; ++i)
                        {
                            dv1[i] = xt1[i] - xt2[i] + xo;
                            dv2[i] = yt1[i] - yt2[i] + yo;
                        }
                    }
                }
            }
        }

        public static void RadialDist(
          double[] rDist,
          double[] dDist,
          double xp,
          double yp,
          out double x,
          out double y)
        {
            x = xp;
            y = yp;
            double num1 = Math.Sqrt(xp * xp + yp * yp);
            for (int i = 2; i <= 20; ++i)
            {
                if (num1 > rDist[i - 1] && num1 <= rDist[i])
                {
                    double num2 = 0.001 * dDist[i - 1];
                    double num3 = (0.001 * dDist[i] - num2) * num1 / (rDist[i] - rDist[i - 1]);
                    double num4 = xp * num3 / num1;
                    double num5 = yp * num3 / num1;
                    x = xp - num4;
                    y = yp - num5;
                    break;
                }
            }
        }

        public static void EarthCurv(
          double xp,
          double yp,
          double foc,
          double hs,
          double hp,
          out double x,
          out double y)
        {
            double num1 = 6372.2;
            double num2 = 0.001 * (hs - hp);
            x = xp;
            y = yp;
            double num3 = Math.Sqrt(xp * xp + yp * yp);
            double num4 = num2 * num3 * num3 * num3 / (2.0 * num1 * foc * foc);
            double num5 = xp * num4 / num3;
            double num6 = yp * num4 / num3;
            x = xp - num5;
            y = yp - num6;
        }

        public static void Refraction(
          double xp,
          double yp,
          double foc,
          double hs,
          double hp,
          out double x,
          out double y)
        {
            x = xp;
            y = yp;
            double num1 = 0.001 * hs;
            double num2 = 0.001 * hp;
            double num3 = Math.Sqrt(xp * xp + yp * yp);
            double num4 = 1E-06 * (2410.0 * num1 / (num1 * num1 - 6.0 * num1 + 250.0) - 2410.0 * num2 * num2 / ((num2 * num2 - 6.0 * num2 + 250.0) * num1)) * (num3 + num3 * num3 * num3 / (foc * foc));
            double num5 = xp * num4 / num3;
            double num6 = yp * num4 / num3;
            x = xp + num5;
            y = yp + num6;
        }

        public static void AbsOrient(
          int kGeo,
          string[] nameGeo,
          double[] xGeo,
          double[] yGeo,
          double[] zGeo,
          int kPnt,
          string[] namePnt,
          double[] xPnt,
          double[] yPnt,
          double[] zPnt,
          ref string[] dopName,
          ref double[] xDop,
          ref double[] yDop,
          ref string[] fotoName,
          ref double[] xFoto,
          ref double[] yFoto,
          ref double[] zFoto,
          out int kFin,
          ref string[] nameFin,
          ref double[] xFin,
          ref double[] yFin,
          ref double[] zFin)
        {
            int[] numArray1 = new int[10];
            int[] numArray2 = new int[10];
            int[] numArray3 = new int[10];
            double[] numArray4 = new double[10];
            double[] numArray5 = new double[10];
            double[] numArray6 = new double[10];
            int kFot = 0;
            int i1 = 0;
            kFin = 0;
            int num1 = 0;
            int kArray1 = 999999;
            stringArray(nameGeo, ref kArray1);
            doubleArray(xGeo, ref kArray1);
            doubleArray(yGeo, ref kArray1);
            doubleArray(zGeo, ref kArray1);
            if (kGeo > kArray1)
            {
                int num2 = (int)MessageBox.Show("Индекс массива AbsOrient");
            }
            else
            {
                int kArray2 = 999999;
                stringArray(namePnt, ref kArray2);
                doubleArray(xPnt, ref kArray2);
                doubleArray(yPnt, ref kArray2);
                doubleArray(zPnt, ref kArray2);
                if (kPnt > kArray2)
                {
                    int num3 = (int)MessageBox.Show("Индекс массива AbsOrient");
                }
                else
                {
                    int kArray3 = 999999;
                    stringArray(fotoName, ref kArray3);
                    doubleArray(xFoto, ref kArray3);
                    doubleArray(yFoto, ref kArray3);
                    doubleArray(zFoto, ref kArray3);
                    if (kPnt > kArray3)
                    {
                        int num4 = (int)MessageBox.Show("Индекс массива AbsOrient");
                    }
                    else
                    {
                        kArray3 = 999999;
                        stringArray(dopName, ref kArray3);
                        doubleArray(xDop, ref kArray3);
                        doubleArray(yDop, ref kArray3);
                        if (kPnt > kArray3)
                        {
                            int num5 = (int)MessageBox.Show("Индекс массива AbsOrient");
                        }
                        else
                        {
                            kArray3 = 999999;
                            stringArray(nameFin, ref kArray3);
                            doubleArray(xFin, ref kArray3);
                            doubleArray(yFin, ref kArray3);
                            doubleArray(zFin, ref kArray3);
                            int i2 = 0;
                            for (int i3 = 1; i3 <= 5; ++i3)
                            {
                                if (i3 == 5)
                                {
                                    numArray4[1] = numArray5[1] + numArray6[1];
                                    numArray4[2] = numArray5[2] + numArray6[2];
                                    numArray4[3] = numArray5[3] + numArray6[3];
                                    numArray4[4] = numArray5[4] + numArray6[4];
                                    double num6 = 9999999.9;
                                    for (int i4 = 1; i4 <= 4; ++i4)
                                    {
                                        if (numArray4[i4] < num6)
                                        {
                                            num6 = numArray4[i4];
                                            num1 = numArray1[i4];
                                            i1 = i4;
                                        }
                                    }
                                    break;
                                }
                                kFot = kPnt;
                                for (int i5 = 1; i5 <= kPnt; ++i5)
                                {
                                    fotoName[i5] = namePnt[i5];
                                    xFoto[i5] = xPnt[i5];
                                    yFoto[i5] = yPnt[i5];
                                    zFoto[i5] = zPnt[i5];
                                }
                                if (i3 == 1)
                                    GeoOrient(kGeo, nameGeo, xGeo, yGeo, zGeo, kFot, ref fotoName, ref xFoto, ref yFoto, ref zFoto, ref dopName, ref xDop, ref yDop);
                                if (i3 == 2)
                                    GeoOrient(kGeo, nameGeo, yGeo, xGeo, zGeo, kFot, ref fotoName, ref xFoto, ref yFoto, ref zFoto, ref dopName, ref xDop, ref yDop);
                                if (i3 == 3)
                                    GeoOrient(kGeo, nameGeo, xGeo, yGeo, zGeo, kFot, ref fotoName, ref yFoto, ref xFoto, ref zFoto, ref dopName, ref xDop, ref yDop);
                                if (i3 == 4)
                                    GeoOrient(kGeo, nameGeo, yGeo, xGeo, zGeo, kFot, ref fotoName, ref yFoto, ref xFoto, ref zFoto, ref dopName, ref xDop, ref yDop);
                                for (int i6 = 1; i6 <= kFot; ++i6)
                                {
                                    ++i2;
                                    if (i2 > kArray3)
                                    {
                                        int num7 = (int)MessageBox.Show("Индекс массива AbsOrient");
                                        return;
                                    }
                                    nameFin[i2] = fotoName[i6];
                                    xFin[i2] = xFoto[i6];
                                    yFin[i2] = yFoto[i6];
                                    zFin[i2] = zFoto[i6];
                                }
                                double num8 = 0.0;
                                double num9 = 0.0;
                                for (int i7 = 1; i7 <= kGeo; ++i7)
                                {
                                    for (int i8 = 1; i8 <= kFot; ++i8)
                                    {
                                        if (nameGeo[i7] == fotoName[i8])
                                        {
                                            if (xGeo[i7] != 0.0 || yGeo[i7] != 0.0)
                                            {
                                                double num10 = xFoto[i8] - xGeo[i7];
                                                double num11 = yFoto[i8] - yGeo[i7];
                                                num8 += Math.Sqrt(num10 * num10 + num11 * num11);
                                                double num12 = yFoto[i8] - xGeo[i7];
                                                double num13 = xFoto[i8] - yGeo[i7];
                                                num9 += Math.Sqrt(num12 * num12 + num13 * num13);
                                                break;
                                            }
                                            break;
                                        }
                                    }
                                }
                                double num14 = 0.0;
                                double num15 = 0.0;
                                for (int i9 = 1; i9 <= kGeo; ++i9)
                                {
                                    for (int i10 = 1; i10 <= kFot; ++i10)
                                    {
                                        if (nameGeo[i9] == fotoName[i10])
                                        {
                                            if (xGeo[i9] != 0.0 || yGeo[i9] != 0.0)
                                            {
                                                if (num8 < num9)
                                                {
                                                    double num16 = xFoto[i10] - xGeo[i9];
                                                    double num17 = yFoto[i10] - yGeo[i9];
                                                    num14 += Math.Sqrt(num16 * num16 + num17 * num17);
                                                }
                                                if (num9 < num8)
                                                {
                                                    double num18 = yFoto[i10] - xGeo[i9];
                                                    double num19 = xFoto[i10] - yGeo[i9];
                                                    num14 += Math.Sqrt(num18 * num18 + num19 * num19);
                                                }
                                            }
                                            if (zGeo[i9] != 0.0)
                                            {
                                                double num20 = zFoto[i10] - zGeo[i9];
                                                num15 += Math.Sqrt(num20 * num20);
                                                break;
                                            }
                                            break;
                                        }
                                    }
                                }
                                numArray5[i3] = num14;
                                numArray6[i3] = num15;
                                numArray1[i3] = 1;
                                if (num9 < num8)
                                    numArray1[i3] = 2;
                            }
                            numArray2[1] = 1;
                            numArray3[1] = kFot;
                            for (int i11 = 2; i11 <= 4; ++i11)
                            {
                                numArray2[i11] = numArray3[i11 - 1] + 1;
                                numArray3[i11] = numArray3[i11 - 1] + kFot;
                            }
                            int num21 = numArray2[i1];
                            int num22 = numArray3[i1];
                            int i12 = 0;
                            for (int i13 = num21; i13 <= num22; ++i13)
                            {
                                ++i12;
                                nameFin[i12] = nameFin[i13];
                                if (num1 == 1)
                                {
                                    xFin[i12] = xFin[i13];
                                    yFin[i12] = yFin[i13];
                                }
                                if (num1 == 2)
                                {
                                    double num23 = yFin[i13];
                                    yFin[i12] = xFin[i13];
                                    xFin[i12] = num23;
                                }
                                zFin[i12] = zFin[i13];
                            }
                            kFin = i12;
                        }
                    }
                }
            }
        }

        public static void DifCoord(
          int kGeo,
          string[] geoName,
          double[] xGeo,
          double[] yGeo,
          double[] zGeo,
          int kFin,
          string[] nameFin,
          double[] xFin,
          double[] yFin,
          double[] zFin,
          out int kDif,
          ref string[] sName,
          ref double[] sDx,
          ref double[] sDy,
          ref double[] sDz,
          ref double[] sDif)
        {
            kDif = 0;
            int kArray1 = 999999;
            stringArray(geoName, ref kArray1);
            doubleArray(xGeo, ref kArray1);
            doubleArray(yGeo, ref kArray1);
            doubleArray(zGeo, ref kArray1);
            if (kGeo > kArray1)
            {
                int num1 = (int)MessageBox.Show("Индекс массива DifCoord");
            }
            else
            {
                int kArray2 = 999999;
                stringArray(nameFin, ref kArray2);
                doubleArray(xFin, ref kArray2);
                doubleArray(yFin, ref kArray2);
                doubleArray(zFin, ref kArray2);
                if (kFin > kArray2)
                {
                    int num2 = (int)MessageBox.Show("Индекс массива DifCoord");
                }
                else
                {
                    int kArray3 = 999999;
                    stringArray(sName, ref kArray3);
                    doubleArray(sDx, ref kArray3);
                    doubleArray(sDy, ref kArray3);
                    doubleArray(sDz, ref kArray3);
                    doubleArray(sDif, ref kArray3);
                    int i1 = 0;
                    for (int i2 = 1; i2 <= kGeo; ++i2)
                    {
                        for (int i3 = 1; i3 <= kFin; ++i3)
                        {
                            if (geoName[i2] == nameFin[i3])
                            {
                                if (xGeo[i2] != 0.0 && yGeo[i2] != 0.0 && zGeo[i2] != 0.0)
                                {
                                    double num3 = xFin[i3] - xGeo[i2];
                                    double num4 = yFin[i3] - yGeo[i2];
                                    double num5 = zFin[i3] - zGeo[i2];
                                    ++i1;
                                    if (i1 > kArray3)
                                    {
                                        int num6 = (int)MessageBox.Show("Индекс массива DifCoord");
                                        return;
                                    }
                                    sName[i1] = geoName[i2];
                                    if (num3 == 0.0)
                                        num3 = 0.0001;
                                    if (num4 == 0.0)
                                        num4 = 0.0001;
                                    if (num5 == 0.0)
                                        num5 = 0.0001;
                                    sDx[i1] = num3;
                                    sDy[i1] = num4;
                                    sDz[i1] = num5;
                                    sDif[i1] = Math.Sqrt(num3 * num3 + num4 * num4 + num5 * num5);
                                }
                                if (xGeo[i2] != 0.0 && yGeo[i2] != 0.0 && zGeo[i2] == 0.0)
                                {
                                    double num7 = xFin[i3] - xGeo[i2];
                                    double num8 = yFin[i3] - yGeo[i2];
                                    ++i1;
                                    if (i1 > kArray3)
                                    {
                                        int num9 = (int)MessageBox.Show("Индекс массива DifCoord");
                                        return;
                                    }
                                    sName[i1] = geoName[i2];
                                    if (num7 == 0.0)
                                        num7 = 0.0001;
                                    if (num8 == 0.0)
                                        num8 = 0.0001;
                                    sDx[i1] = num7;
                                    sDy[i1] = num8;
                                    sDz[i1] = 0.0;
                                    sDif[i1] = Math.Sqrt(num7 * num7 + num8 * num8);
                                }
                                if (xGeo[i2] == 0.0 && yGeo[i2] == 0.0 && zGeo[i2] != 0.0)
                                {
                                    double num10 = zFin[i3] - zGeo[i2];
                                    ++i1;
                                    if (i1 > kArray3)
                                    {
                                        int num11 = (int)MessageBox.Show("Индекс массива DifCoord");
                                        return;
                                    }
                                    sName[i1] = geoName[i2];
                                    sDx[i1] = 0.0;
                                    sDy[i1] = 0.0;
                                    if (num10 == 0.0)
                                        num10 = 0.0001;
                                    sDz[i1] = num10;
                                    sDif[i1] = Math.Sqrt(num10 * num10);
                                }
                            }
                        }
                    }
                    kDif = i1;
                }
            }
        }

        public static void MiddleCoord(
          int kFin,
          ref string[] nameFin,
          ref double[] xFin,
          ref double[] yFin,
          ref double[] zFin,
          out int kPnt,
          ref string[] namePnt,
          ref double[] xPnt,
          ref double[] yPnt,
          ref double[] zPnt,
          ref int[] ind)
        {
            kPnt = 0;
            int kArray1 = 999999;
            stringArray(nameFin, ref kArray1);
            doubleArray(xFin, ref kArray1);
            doubleArray(yFin, ref kArray1);
            doubleArray(zFin, ref kArray1);
            intArray(ind, ref kArray1);
            if (kFin > kArray1)
            {
                int num1 = (int)MessageBox.Show("Индекс массива MiddleCoord");
            }
            else
            {
                int kArray2 = 999999;
                stringArray(namePnt, ref kArray2);
                doubleArray(xPnt, ref kArray2);
                doubleArray(yPnt, ref kArray2);
                doubleArray(zPnt, ref kArray2);
                int i1 = 0;
                for (int i2 = 1; i2 <= kFin; ++i2)
                {
                    if (xFin[i2] != -1.0 || yFin[i2] != -1.0 || zFin[i2] != -1.0)
                    {
                        double num2 = xFin[i2];
                        double num3 = yFin[i2];
                        double num4 = zFin[i2];
                        int num5 = 1;
                        int i3 = 0;
                        if (i2 < kFin)
                        {
                            for (int i4 = i2 + 1; i4 <= kFin; ++i4)
                            {
                                if (nameFin[i2] == nameFin[i4])
                                {
                                    ++num5;
                                    num2 += xFin[i4];
                                    num3 += yFin[i4];
                                    num4 += zFin[i4];
                                    ++i3;
                                    ind[i3] = i4;
                                }
                            }
                        }
                        double num6 = num2 / (double)num5;
                        double num7 = num3 / (double)num5;
                        double num8 = num4 / (double)num5;
                        ++i1;
                        if (i1 > kArray2)
                        {
                            int num9 = (int)MessageBox.Show("Индекс массива MiddleCoord");
                            return;
                        }
                        namePnt[i1] = nameFin[i2];
                        xPnt[i1] = num6;
                        yPnt[i1] = num7;
                        zPnt[i1] = num8;
                        if (i3 > 0)
                        {
                            for (int i5 = 1; i5 <= i3; ++i5)
                            {
                                int i6 = ind[i5];
                                xFin[i6] = -1.0;
                                yFin[i6] = -1.0;
                                zFin[i6] = -1.0;
                            }
                        }
                    }
                }
                for (int i7 = 1; i7 <= i1; ++i7)
                {
                    nameFin[i7] = namePnt[i7];
                    xFin[i7] = xPnt[i7];
                    yFin[i7] = yPnt[i7];
                    zFin[i7] = zPnt[i7];
                }
                kPnt = i1;
            }
        }

        public static void Polynom(
          int iParam,
          int kGeo,
          string[] nameGeo,
          double[] xGeo,
          double[] yGeo,
          double[] zGeo,
          int kFin,
          ref string[] nameFin,
          ref double[] xFin,
          ref double[] yFin,
          ref double[] zFin,
          ref double[] xFot,
          ref double[] yFot,
          ref double[] zFot,
          ref double[] dxDop,
          ref double[] dyDop,
          ref double[] dzDop,
          ref double[] xDop,
          ref double[] yDop,
          ref double[] zDop,
          ref double[] xAdd,
          ref double[] yAdd)
        {
            double[] b = new double[10];
            int kArray1 = 999999;
            stringArray(nameGeo, ref kArray1);
            doubleArray(xGeo, ref kArray1);
            doubleArray(yGeo, ref kArray1);
            doubleArray(zGeo, ref kArray1);
            if (kGeo > kArray1)
            {
                int num1 = (int)MessageBox.Show("Индекс массива Polynom");
            }
            else
            {
                int kArray2 = 999999;
                stringArray(nameFin, ref kArray2);
                doubleArray(xFin, ref kArray2);
                doubleArray(yFin, ref kArray2);
                doubleArray(zFin, ref kArray2);
                doubleArray(xFot, ref kArray2);
                doubleArray(yFot, ref kArray2);
                doubleArray(zFot, ref kArray2);
                doubleArray(xDop, ref kArray2);
                doubleArray(yDop, ref kArray2);
                doubleArray(zDop, ref kArray2);
                doubleArray(dxDop, ref kArray2);
                doubleArray(dyDop, ref kArray2);
                doubleArray(dzDop, ref kArray2);
                doubleArray(xAdd, ref kArray2);
                doubleArray(yAdd, ref kArray2);
                if (kFin > kArray2)
                {
                    int num2 = (int)MessageBox.Show("Индекс массива Polynom");
                }
                else
                {
                    for (int i = 1; i <= kFin; ++i)
                    {
                        xDop[i] = xFin[i];
                        yDop[i] = yFin[i];
                        zDop[i] = zFin[i];
                    }
                    int kxy;
                    double xc;
                    double yc;
                    int kz;
                    double zc;
                    int mm;
                    if (iParam == 1)
                    {
                        xyzCenter(kGeo, nameGeo, xGeo, yGeo, zGeo, kFin, ref nameFin, ref xFin, ref yFin, ref zFin, out kxy, out xc, out yc, ref xFot, ref yFot, ref dxDop, ref dyDop, out kz, out zc, ref xAdd, ref yAdd, ref zFot, ref dzDop);
                        for (int i = 1; i <= kxy; ++i)
                        {
                            xFot[i] = xFot[i] - xc;
                            yFot[i] = yFot[i] - yc;
                        }
                        int iParam1 = 1;
                        PolyFact(kxy, xFot, yFot, dxDop, out mm, ref b, iParam1);
                        PolyCoor(kFin, 1, ref xFin, ref yFin, ref zFin, xc, yc, xc, mm, b, iParam1);
                        double num3 = 0.0;
                        for (int i1 = 1; i1 <= kGeo; ++i1)
                        {
                            for (int i2 = 1; i2 <= kFin; ++i2)
                            {
                                if (nameGeo[i1] == nameFin[i2])
                                {
                                    if (xGeo[i1] != 0.0 && yGeo[i1] != 0.0)
                                    {
                                        double num4 = xFin[i2] - xGeo[i1];
                                        num3 += Math.Abs(num4);
                                        break;
                                    }
                                    break;
                                }
                            }
                        }
                        xyzCenter(kGeo, nameGeo, xGeo, yGeo, zGeo, kFin, ref nameFin, ref xDop, ref yDop, ref zDop, out kxy, out xc, out yc, ref xFot, ref yFot, ref dxDop, ref dyDop, out kz, out zc, ref xAdd, ref yAdd, ref zFot, ref dzDop);
                        for (int i = 1; i <= kxy; ++i)
                        {
                            xFot[i] = xFot[i] - xc;
                            yFot[i] = yFot[i] - yc;
                        }
                        int iParam2 = 2;
                        PolyFact(kxy, xFot, yFot, dxDop, out mm, ref b, iParam2);
                        PolyCoor(kFin, 1, ref xDop, ref yDop, ref zDop, xc, yc, xc, mm, b, iParam2);
                        double num5 = 0.0;
                        for (int i3 = 1; i3 <= kGeo; ++i3)
                        {
                            for (int i4 = 1; i4 <= kFin; ++i4)
                            {
                                if (nameGeo[i3] == nameFin[i4])
                                {
                                    if (xGeo[i3] != 0.0 && yGeo[i3] != 0.0)
                                    {
                                        double num6 = xDop[i4] - xGeo[i3];
                                        num5 += Math.Abs(num6);
                                        break;
                                    }
                                    break;
                                }
                            }
                        }
                        if (num5 < num3)
                        {
                            for (int i = 1; i <= kFin; ++i)
                            {
                                xFin[i] = xDop[i];
                                yFin[i] = yDop[i];
                                zFin[i] = zDop[i];
                            }
                        }
                        for (int i = 1; i <= kFin; ++i)
                        {
                            xDop[i] = xFin[i];
                            yDop[i] = yFin[i];
                            zDop[i] = zFin[i];
                        }
                        xyzCenter(kGeo, nameGeo, xGeo, yGeo, zGeo, kFin, ref nameFin, ref xFin, ref yFin, ref zFin, out kxy, out xc, out yc, ref xFot, ref yFot, ref dxDop, ref dyDop, out kz, out zc, ref xAdd, ref yAdd, ref zFot, ref dzDop);
                        for (int i = 1; i <= kxy; ++i)
                        {
                            xFot[i] = xFot[i] - xc;
                            yFot[i] = yFot[i] - yc;
                        }
                        int iParam3 = 1;
                        PolyFact(kxy, xFot, yFot, dyDop, out mm, ref b, iParam3);
                        PolyCoor(kFin, 2, ref xFin, ref yFin, ref zFin, xc, yc, yc, mm, b, iParam3);
                        double num7 = 0.0;
                        for (int i5 = 1; i5 <= kGeo; ++i5)
                        {
                            for (int i6 = 1; i6 <= kFin; ++i6)
                            {
                                if (nameGeo[i5] == nameFin[i6])
                                {
                                    if (xGeo[i5] != 0.0 && yGeo[i5] != 0.0)
                                    {
                                        double num8 = yFin[i6] - yGeo[i5];
                                        num7 += Math.Abs(num8);
                                        break;
                                    }
                                    break;
                                }
                            }
                        }
                        xyzCenter(kGeo, nameGeo, xGeo, yGeo, zGeo, kFin, ref nameFin, ref xDop, ref yDop, ref zDop, out kxy, out xc, out yc, ref xFot, ref yFot, ref dxDop, ref dyDop, out kz, out zc, ref xAdd, ref yAdd, ref zFot, ref dzDop);
                        for (int i = 1; i <= kxy; ++i)
                        {
                            xFot[i] = xFot[i] - xc;
                            yFot[i] = yFot[i] - yc;
                        }
                        int iParam4 = 2;
                        PolyFact(kxy, xFot, yFot, dyDop, out mm, ref b, iParam4);
                        PolyCoor(kFin, 2, ref xDop, ref yDop, ref zDop, xc, yc, yc, mm, b, iParam4);
                        double num9 = 0.0;
                        for (int i7 = 1; i7 <= kGeo; ++i7)
                        {
                            for (int i8 = 1; i8 <= kFin; ++i8)
                            {
                                if (nameGeo[i7] == nameFin[i8])
                                {
                                    if (xGeo[i7] != 0.0 && yGeo[i7] != 0.0)
                                    {
                                        double num10 = yDop[i8] - yGeo[i7];
                                        num9 += Math.Abs(num10);
                                        break;
                                    }
                                    break;
                                }
                            }
                        }
                        if (num9 < num7)
                        {
                            for (int i = 1; i <= kFin; ++i)
                            {
                                xFin[i] = xDop[i];
                                yFin[i] = yDop[i];
                                zFin[i] = zDop[i];
                            }
                        }
                    }
                    for (int i = 1; i <= kFin; ++i)
                    {
                        xDop[i] = xFin[i];
                        yDop[i] = yFin[i];
                        zDop[i] = zFin[i];
                    }
                    if (iParam != 3)
                        return;
                    xyzCenter(kGeo, nameGeo, xGeo, yGeo, zGeo, kFin, ref nameFin, ref xFin, ref yFin, ref zFin, out kxy, out xc, out yc, ref xFot, ref yFot, ref dxDop, ref dyDop, out kz, out zc, ref xAdd, ref yAdd, ref zFot, ref dzDop);
                    int iParam5 = 1;
                    for (int i = 1; i <= kz; ++i)
                    {
                        xAdd[i] = xAdd[i] - xc;
                        yAdd[i] = yAdd[i] - yc;
                    }
                    PolyFact(kz, xAdd, yAdd, dzDop, out mm, ref b, iParam5);
                    PolyCoor(kFin, 3, ref xFin, ref yFin, ref zFin, xc, yc, zc, mm, b, iParam5);
                    double num11 = 0.0;
                    for (int i9 = 1; i9 <= kGeo; ++i9)
                    {
                        for (int i10 = 1; i10 <= kFin; ++i10)
                        {
                            if (nameGeo[i9] == nameFin[i10])
                            {
                                if (zGeo[i9] != 0.0)
                                {
                                    double num12 = zFin[i10] - zGeo[i9];
                                    num11 += Math.Abs(num12);
                                    break;
                                }
                                break;
                            }
                        }
                    }
                    xyzCenter(kGeo, nameGeo, xGeo, yGeo, zGeo, kFin, ref nameFin, ref xDop, ref yDop, ref zDop, out kxy, out xc, out yc, ref xFot, ref yFot, ref dxDop, ref dyDop, out kz, out zc, ref xAdd, ref yAdd, ref zFot, ref dzDop);
                    for (int i = 1; i <= kz; ++i)
                    {
                        xAdd[i] = xAdd[i] - xc;
                        yAdd[i] = yAdd[i] - yc;
                    }
                    int iParam6 = 2;
                    PolyFact(kz, xAdd, yAdd, dzDop, out mm, ref b, iParam6);
                    PolyCoor(kFin, 3, ref xDop, ref yDop, ref zDop, xc, yc, zc, mm, b, iParam6);
                    double num13 = 0.0;
                    for (int i11 = 1; i11 <= kGeo; ++i11)
                    {
                        for (int i12 = 1; i12 <= kFin; ++i12)
                        {
                            if (nameGeo[i11] == nameFin[i12])
                            {
                                if (zGeo[i11] != 0.0)
                                {
                                    double num14 = zDop[i12] - zGeo[i11];
                                    num13 += Math.Abs(num14);
                                    break;
                                }
                                break;
                            }
                        }
                    }
                    if (num13 >= num11)
                        return;
                    for (int i = 1; i <= kFin; ++i)
                    {
                        xFin[i] = xDop[i];
                        yFin[i] = yDop[i];
                        zFin[i] = zDop[i];
                    }
                }
            }
        }

        public static void InverseResection(
          double fk,
          int kt,
          ref double[] x,
          ref double[] y,
          ref double[] z,
          double[] xt,
          double[] yt,
          ref double e1,
          ref double e2,
          ref double e3,
          ref double xs,
          ref double ys,
          ref double zs,
          out double ee1,
          out double ee2,
          out double ee3,
          out double xss,
          out double yss,
          out double zss,
          out int kpr)
        {
            double[] numArray1 = new double[10];
            double[] numArray2 = new double[10];
            double[] a = new double[40];
            int[] l = new int[10];
            int[] m = new int[10];
            ee1 = ee2 = ee3 = xss = yss = zss = 0.0;
            kpr = 0;
            int kArray = 999999;
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            doubleArray(z, ref kArray);
            doubleArray(xt, ref kArray);
            doubleArray(xt, ref kArray);
            if (kt > kArray)
            {
                int num1 = (int)MessageBox.Show("Индекс массива InverseResection");
            }
            else
            {
                double num2 = 0.0;
                double num3 = 0.0;
                for (int i = 1; i <= kt; ++i)
                {
                    num2 += x[i];
                    num3 += y[i];
                }
                double num4 = num2 / (double)kt;
                double num5 = num3 / (double)kt;
                for (int i = 1; i <= kt; ++i)
                {
                    x[i] = x[i] - num4;
                    y[i] = y[i] - num5;
                }
                xs -= num4;
                ys -= num5;
                ee1 = 0.0;
                ee2 = 0.0;
                ee3 = 0.0;
                xss = xs;
                yss = ys;
                zss = zs;
                kpr = 0;
                for (int i1 = 1; i1 <= 20; ++i1)
                {
                    kpr = i1;
                    for (int i2 = 1; i2 <= 9; ++i2)
                        numArray2[i2] = 0.0;
                    for (int i3 = 1; i3 <= 39; ++i3)
                        a[i3] = 0.0;
                    double a1;
                    double a2;
                    double a3;
                    double b1;
                    double b2;
                    double b3;
                    double c1;
                    double c2;
                    double c3;
                    DirCosin(e1, e2, e3, out a1, out a2, out a3, out b1, out b2, out b3, out c1, out c2, out c3);
                    for (int i4 = 1; i4 <= kt; ++i4)
                    {
                        double num6 = x[i4] - xs;
                        double num7 = y[i4] - ys;
                        double num8 = z[i4] - zs;
                        double num9 = a1 * num6 + b1 * num7 + c1 * num8;
                        double num10 = a3 * num6 + b3 * num7 + c3 * num8;
                        double num11 = -fk * num9 / num10;
                        double num12 = a2 * num6 + b2 * num7 + c2 * num8;
                        double num13 = -fk * num12 / num10;
                        numArray1[1] = (a1 * fk + a3 * xt[i4]) / num10;
                        numArray1[2] = (b1 * fk + b3 * xt[i4]) / num10;
                        numArray1[3] = (c1 * fk + c3 * xt[i4]) / num10;
                        double num14 = fk * (c1 * num6 - a1 * num8) / num10;
                        double num15 = xt[i4] * (c3 * num6 - a3 * num8) / num10;
                        numArray1[4] = num14 + num15;
                        double num16 = Math.Sin(e3);
                        double num17 = Math.Cos(e2);
                        double num18 = Math.Sin(e2);
                        double num19 = num18 / num17;
                        double num20 = num7 * b3 * num18 / (num10 * num17);
                        double num21 = num7 * num17 / num10;
                        numArray1[5] = -fk * num16 + xt[i4] * (num18 - num20 + num21);
                        numArray1[6] = yt[i4];
                        double w1 = num11 - xt[i4];
                        FormMatrix(numArray1, ref a, w1, ref numArray2, 6, 0.01);
                        numArray1[1] = (a2 * fk + a3 * yt[i4]) / num10;
                        numArray1[2] = (b2 * fk + b3 * yt[i4]) / num10;
                        numArray1[3] = (c2 * fk + c3 * yt[i4]) / num10;
                        double num22 = fk * (c2 * num6 - a2 * num8) / num10;
                        double num23 = yt[i4] * (c3 * num6 - a3 * num8) / num10;
                        numArray1[4] = num22 + num23;
                        double num24 = Math.Cos(e3);
                        double num25 = Math.Cos(e2);
                        double num26 = Math.Sin(e2);
                        double num27 = num26 / num25;
                        double num28 = num7 * b3 * num26 / (num10 * num25);
                        double num29 = num7 * num25 / num10;
                        numArray1[5] = -fk * num24 + yt[i4] * (num26 - num28 + num29);
                        numArray1[6] = -xt[i4];
                        double w2 = num13 - yt[i4];
                        FormMatrix(numArray1, ref a, w2, ref numArray2, 6, 0.01);
                    }
                    for (int i5 = 1; i5 <= 6; ++i5)
                        numArray1[i5] = -numArray2[i5];
                    Minv(ref a, 6, out double _, ref l, ref m);
                    Gmprd(a, numArray1, ref numArray2, 6, 6, 1);
                    xs += numArray2[1];
                    ys += numArray2[2];
                    zs += numArray2[3];
                    e1 += numArray2[4];
                    e2 += numArray2[5];
                    e3 += numArray2[6];
                    int num30 = 0;
                    for (int i6 = 1; i6 <= 3; ++i6)
                    {
                        if (Math.Abs(numArray2[i6]) > 0.001)
                        {
                            num30 = 1;
                            break;
                        }
                    }
                    if (num30 <= 0)
                    {
                        int num31 = 0;
                        for (int i7 = 4; i7 <= 6; ++i7)
                        {
                            if (Math.Abs(numArray2[i7]) > 2E-05)
                            {
                                num31 = 1;
                                break;
                            }
                        }
                        if (num31 == 0)
                            break;
                    }
                }
                xs += num4;
                ys += num5;
                ee1 = e1;
                ee2 = e2;
                ee3 = e3;
                xss = xs;
                yss = ys;
                zss = zs;
                for (int i = 1; i <= kt; ++i)
                {
                    x[i] = x[i] + num4;
                    y[i] = y[i] + num5;
                }
            }
        }

        public static void DirectResection(
          double fk,
          double xs1,
          double ys1,
          double zs1,
          double e1,
          double e2,
          double e3,
          double xs2,
          double ys2,
          double zs2,
          double f1,
          double f2,
          double f3,
          int kt,
          double[] xl,
          double[] yl,
          double[] xp,
          double[] yp,
          ref double[] x,
          ref double[] y,
          ref double[] z)
        {
            int kArray = 999999;
            doubleArray(xl, ref kArray);
            doubleArray(yl, ref kArray);
            doubleArray(xp, ref kArray);
            doubleArray(yp, ref kArray);
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            doubleArray(z, ref kArray);
            if (kt > kArray)
            {
                int num1 = (int)MessageBox.Show("Индекс массива DirectResection");
            }
            else
            {
                double num2 = xs2 - xs1;
                double num3 = zs2 - zs1;
                double a1_1;
                double a2_1;
                double a3_1;
                double b1;
                double b2;
                double b3;
                double c1_1;
                double c2_1;
                double c3_1;
                DirCosin(e1, e2, e3, out a1_1, out a2_1, out a3_1, out b1, out b2, out b3, out c1_1, out c2_1, out c3_1);
                double a1_2;
                double a2_2;
                double a3_2;
                double c1_2;
                double c2_2;
                double c3_2;
                DirCosin(f1, f2, f3, out a1_2, out a2_2, out a3_2, out double _, out double _, out double _, out c1_2, out c2_2, out c3_2);
                for (int i = 1; i <= kt; ++i)
                {
                    double num4 = c1_1 * xl[i] + c2_1 * yl[i] - c3_1 * fk;
                    double num5 = a1_1 * xl[i] + a2_1 * yl[i] - a3_1 * fk;
                    double num6 = -fk * num5 / num4;
                    double num7 = b1 * xl[i] + b2 * yl[i] - b3 * fk;
                    double num8 = -fk * num7 / num4;
                    double num9 = c1_2 * xp[i] + c2_2 * yp[i] - c3_2 * fk;
                    double num10 = a1_2 * xp[i] + a2_2 * yp[i] - a3_2 * fk;
                    double num11 = -fk * num10 / num9;
                    double num12 = (num2 * fk + num11 * num3) / (fk * (num6 - num11));
                    x[i] = xs1 + num12 * num6;
                    y[i] = ys1 + num12 * num8;
                    z[i] = zs1 - num12 * fk;
                }
            }
        }

        public static void Relative(
          double fk,
          int kt,
          double[] xl,
          double[] yl,
          double[] xp,
          double[] yp,
          out double ee1,
          out double ee3,
          out double ee4,
          out double ee5,
          out double ee6,
          double[] ql,
          out double qp,
          out double qm)
        {
            double num1 = ee1 = ee3 = ee4 = ee5 = ee6 = 0.0;
            qp = 0.0;
            qm = 0.0;
            int kArray = 999999;
            doubleArray(xl, ref kArray);
            doubleArray(yl, ref kArray);
            doubleArray(xp, ref kArray);
            doubleArray(yp, ref kArray);
            doubleArray(ql, ref kArray);
            if (kt > kArray)
            {
                int num2 = (int)MessageBox.Show("Индекс массива Relative");
            }
            else
            {
                for (int i1 = 1; i1 <= 10; ++i1)
                {
                    double e1 = 0.0;
                    double w = 0.0;
                    double e3 = 0.0;
                    double e4 = 0.0;
                    double e5 = 0.0;
                    double e6 = 0.0;
                    RelItems(kt, xl, yl, xp, yp, fk, ref e1, ref e4, ref e5, ref e3, ref e6);
                    ee1 = e1;
                    ee3 = e3;
                    ee4 = e4;
                    ee5 = e5;
                    ee6 = e6;
                    double b1_1;
                    double b2_1;
                    double b3_1;
                    double c1_1;
                    double c2_1;
                    double c3_1;
                    DirCosin(e1, w, e3, out double _, out double _, out double _, out b1_1, out b2_1, out b3_1, out c1_1, out c2_1, out c3_1);
                    double b1_2;
                    double b2_2;
                    double b3_2;
                    double c1_2;
                    double c2_2;
                    double c3_2;
                    DirCosin(e4, e5, e6, out double _, out double _, out double _, out b1_2, out b2_2, out b3_2, out c1_2, out c2_2, out c3_2);
                    double num3 = 0.0;
                    for (int i2 = 1; i2 <= kt; ++i2)
                    {
                        double num4 = xl[i2];
                        double num5 = yl[i2];
                        double num6 = xp[i2];
                        double num7 = yp[i2];
                        double num8 = b1_1 * num4 + b2_1 * num5 - b3_1 * fk;
                        double num9 = c1_1 * num4 + c2_1 * num5 - c3_1 * fk;
                        double num10 = b1_2 * num6 + b2_2 * num7 - b3_2 * fk;
                        double num11 = c1_2 * num6 + c2_2 * num7 - c3_2 * fk;
                        ql[i2] = fk * (num10 / num11 - num8 / num9);
                        num3 += ql[i2] * ql[i2];
                    }
                    double num12 = Math.Sqrt(num3 / (double)(kt - 1));
                    if (i1 == 1)
                    {
                        qp = num12;
                        qm = num12;
                    }
                    if (i1 > 1)
                        qm = num12;
                    int num13 = 0;
                    for (int i3 = 1; i3 <= kt; ++i3)
                    {
                        if (Math.Abs(ql[i3]) > 0.003)
                        {
                            ++num13;
                            break;
                        }
                    }
                    if (num13 == 0)
                        break;
                    Parallax(kt, ql, ref yp);
                }
            }
        }

        public static void Ftmod(
          int j,
          double fk,
          double bas,
          double e1,
          double e2,
          double e3,
          double e4,
          double e5,
          double e6,
          int kq,
          double[] xl,
          double[] yl,
          double[] xp,
          double[] yp,
          ref double[] xBase,
          ref double[] yBase,
          ref double[] zBase,
          ref double[] xPhot,
          ref double[] yPhot,
          ref double[] zPhot,
          ref double[] factCos)
        {
            double[] r1 = new double[10];
            double[] r2 = new double[10];
            double num1;
            double c3_1 = num1 = 0.0;
            double c2_1 = num1;
            double c1_1 = num1;
            double b3_1 = num1;
            double b2_1 = num1;
            double b1_1 = num1;
            double a3_1 = num1;
            double a2_1 = num1;
            double a1_1 = num1;
            int kArray = 999999;
            doubleArray(xl, ref kArray);
            doubleArray(yl, ref kArray);
            doubleArray(xp, ref kArray);
            doubleArray(yp, ref kArray);
            doubleArray(xPhot, ref kArray);
            doubleArray(yPhot, ref kArray);
            doubleArray(zPhot, ref kArray);
            if (kq > kArray)
            {
                int num2 = (int)MessageBox.Show("Индекс массива Ftmod");
            }
            else
            {
                int i1 = 9 * j - 8;
                if (j == 1)
                    DirCosin(e1, e2, e3, out a1_1, out a2_1, out a3_1, out b1_1, out b2_1, out b3_1, out c1_1, out c2_1, out c3_1);
                if (j > 1)
                {
                    int i2 = 9 * (j - 1) - 8;
                    a1_1 = factCos[i2];
                    a2_1 = factCos[i2 + 1];
                    a3_1 = factCos[i2 + 2];
                    b1_1 = factCos[i2 + 3];
                    b2_1 = factCos[i2 + 4];
                    b3_1 = factCos[i2 + 5];
                    c1_1 = factCos[i2 + 6];
                    c2_1 = factCos[i2 + 7];
                    c3_1 = factCos[i2 + 8];
                }
                Factors(e1, e2, e3, e4, e5, e6, a1_1, a2_1, a3_1, b1_1, b2_1, b3_1, c1_1, c2_1, c3_1, ref r1, ref r2);
                double num3 = Math.Atan2(r1[4], r1[1]);
                double num4 = Math.Asin(r1[7]);
                double a1_2;
                double a2_2;
                double a3_2;
                double b1_2;
                double b2_2;
                double b3_2;
                double c1_2;
                double c2_2;
                double c3_2;
                DirCosin(Math.Atan2(-r2[3], r2[9]), Math.Asin(-r2[6]), Math.Atan2(r2[4], r2[5]), out a1_2, out a2_2, out a3_2, out b1_2, out b2_2, out b3_2, out c1_2, out c2_2, out c3_2);
                factCos[i1] = a1_2;
                factCos[i1 + 1] = a2_2;
                factCos[i1 + 2] = a3_2;
                factCos[i1 + 3] = b1_2;
                factCos[i1 + 4] = b2_2;
                factCos[i1 + 5] = b3_2;
                factCos[i1 + 6] = c1_2;
                factCos[i1 + 7] = c2_2;
                factCos[i1 + 8] = c3_2;
                xBase[j] = bas * Math.Cos(num4) * Math.Cos(num3);
                yBase[j] = bas * Math.Cos(num4) * Math.Sin(num3);
                zBase[j] = bas * Math.Sin(num4);
                for (int i3 = 1; i3 <= kq; ++i3)
                {
                    double num5 = xl[i3];
                    double num6 = yl[i3];
                    double num7 = xp[i3];
                    double num8 = yp[i3];
                    double num9 = factCos[i1];
                    double num10 = factCos[i1 + 1];
                    double num11 = factCos[i1 + 2];
                    double num12 = factCos[i1 + 6];
                    double num13 = factCos[i1 + 7];
                    double num14 = factCos[i1 + 8];
                    double num15 = c1_1 * num5 + c2_1 * num6 - c3_1 * fk;
                    double num16 = a1_1 * num5 + a2_1 * num6 - a3_1 * fk;
                    double num17 = -fk * num16 / num15;
                    double num18 = b1_1 * num5 + b2_1 * num6 - b3_1 * fk;
                    double num19 = -fk * num18 / num15;
                    double num20 = num12 * num7 + num13 * num8 - num14 * fk;
                    double num21 = num9 * num7 + num10 * num8 - num11 * fk;
                    double num22 = -fk * num21 / num20;
                    double num23 = (xBase[j] + num22 * zBase[j] / fk) / (num17 - num22);
                    xPhot[i3] = num23 * num17;
                    yPhot[i3] = num23 * num19;
                    zPhot[i3] = -num23 * fk;
                }
            }
        }

        public static void Basis(
          double xs1,
          double ys1,
          double zs1,
          out double xs2,
          out double ys2,
          out double zs2,
          double xBas,
          double yBas,
          double zBas,
          double fScale,
          int i1,
          int i2,
          double[] xMod,
          double[] yMod,
          double[] zMod,
          ref double[] xStrip,
          ref double[] yStrip,
          ref double[] zStrip)
        {
            xs2 = ys2 = zs2 = 0.0;
            int kArray = 999999;
            doubleArray(xMod, ref kArray);
            doubleArray(yMod, ref kArray);
            doubleArray(zMod, ref kArray);
            doubleArray(xStrip, ref kArray);
            doubleArray(yStrip, ref kArray);
            doubleArray(zStrip, ref kArray);
            if (i2 > kArray)
            {
                int num = (int)MessageBox.Show("Индекс массива Basis");
            }
            else
            {
                xs2 = xs1 + xBas * fScale;
                ys2 = ys1 + yBas * fScale;
                zs2 = zs1 + zBas * fScale;
                for (int i = i1; i <= i2; ++i)
                {
                    xStrip[i] = xs1 + fScale * xMod[i];
                    yStrip[i] = ys1 + fScale * yMod[i];
                    zStrip[i] = zs1 + fScale * zMod[i];
                }
            }
        }

        public static void BaseDefine(
          int kPnt,
          string[] namePnt,
          double[] xPnt,
          double[] yPnt,
          double[] zPnt,
          out int kStrp,
          ref int[] ks,
          ref int[] ks1,
          ref int[] ks2,
          ref string[] sName,
          ref double[] xs,
          ref double[] ys,
          ref double[] zs)
        {
            kStrp = 0;
            int num1 = 0;
            int i1 = 0;
            int i2 = 0;
            int kArray1 = 999999;
            stringArray(namePnt, ref kArray1);
            doubleArray(xPnt, ref kArray1);
            doubleArray(yPnt, ref kArray1);
            doubleArray(zPnt, ref kArray1);
            if (kPnt > kArray1)
            {
                int num2 = (int)MessageBox.Show("Индекс массива BaseDefine");
            }
            else
            {
                int kArray2 = 999999;
                stringArray(sName, ref kArray2);
                doubleArray(xs, ref kArray2);
                doubleArray(ys, ref kArray2);
                doubleArray(zs, ref kArray2);
                for (int i3 = 1; i3 <= kPnt; ++i3)
                {
                    string str = namePnt[i3];
                    if (str.IndexOf('-') == 0)
                    {
                        ++i1;
                        if (i1 > kArray2)
                            return;
                        sName[i1] = str.Trim('-');
                        xs[i1] = xPnt[i3];
                        ys[i1] = yPnt[i3];
                        zs[i1] = zPnt[i3];
                        ++num1;
                    }
                    else if (num1 > 0)
                    {
                        ++i2;
                        ks[i2] = num1;
                        num1 = 0;
                    }
                }
                if (num1 > 0)
                {
                    ++i2;
                    ks[i2] = num1;
                }
                kStrp = i2;
                if (i2 == 0)
                    return;
                ks1[1] = 1;
                ks2[1] = ks[1];
                if (i2 <= 1)
                    return;
                for (int i4 = 2; i4 <= i2; ++i4)
                {
                    ks1[i4] = ks2[i4 - 1] + 1;
                    ks2[i4] = ks2[i4 - 1] + ks[i4];
                }
            }
        }

        public static void ModelPrecise(
     int i1,
     int i2,
     int i3,
     int i4,
     ref string[] fotoName,
     ref double[] xft,
     ref double[] yft,
     ref double[] zft,
     ref double xs2,
     ref double ys2,
     ref double zs2)
        {
            double[] numArray1 = new double[5];
            double[] b1 = new double[5];
            double[] b2 = new double[5];
            double[] numArray2 = new double[5];
            double[] numArray3 = new double[5];
            double[] numArray4 = new double[5];
            double[] a1 = new double[10];
            double[] a2 = new double[10];
            double[] a3 = new double[10];
            int[] l = new int[5];
            int[] m = new int[5];
            int kArray = 999999;
            DllClass1.stringArray(fotoName, ref kArray);
            DllClass1.doubleArray(xft, ref kArray);
            DllClass1.doubleArray(yft, ref kArray);
            DllClass1.doubleArray(zft, ref kArray);
            if (i4 > kArray)
            {
                int num1 = (int)MessageBox.Show("Index array ModelPrecise");
            }
            else
            {
                for (int index = 1; index <= 3; ++index)
                {
                    numArray3[index] = 0.0;
                    numArray4[index] = 0.0;
                    numArray2[index] = 0.0;
                }
                for (int index = 1; index <= 9; ++index)
                {
                    a1[index] = 0.0;
                    a2[index] = 0.0;
                    a3[index] = 0.0;
                }
                for (int index1 = i1; index1 <= i2; ++index1)
                {
                    for (int index2 = i3; index2 <= i4; ++index2)
                    {
                        if (fotoName[index1] == fotoName[index2])
                        {
                            numArray1[1] = 1.0;
                            numArray1[2] = yft[index2];
                            double w1 = xft[index2] - xft[index1];
                            DllClass1.FormMatrix(numArray1, ref a3, w1, ref numArray2, 2, 0.1);
                            double w2 = yft[index2] - yft[index1];
                            DllClass1.FormMatrix(numArray1, ref a1, w2, ref numArray3, 2, 0.1);
                            double w3 = zft[index2] - zft[index1];
                            DllClass1.FormMatrix(numArray1, ref a2, w3, ref numArray4, 2, 0.1);
                            break;
                        }
                    }
                }
                for (int index = 1; index <= 2; ++index)
                {
                    numArray1[index] = -numArray2[index];
                    b1[index] = -numArray3[index];
                    b2[index] = -numArray4[index];
                }
                double d;
                DllClass1.Minv(ref a3, 2, out d, ref l, ref m);
                DllClass1.Gmprd(a3, numArray1, ref numArray2, 2, 2, 1);
                DllClass1.Minv(ref a1, 2, out d, ref l, ref m);
                DllClass1.Gmprd(a1, b1, ref numArray3, 2, 2, 1);
                DllClass1.Minv(ref a2, 2, out d, ref l, ref m);
                DllClass1.Gmprd(a2, b2, ref numArray4, 2, 2, 1);
                for (int index = i3; index <= i4; ++index)
                {
                    double num2 = xft[index];
                    double num3 = yft[index];
                    double num4 = zft[index];
                    double num5 = numArray2[1] + numArray2[2] * num3;
                    double num6 = numArray3[1] + numArray3[2] * num3;
                    double num7 = numArray4[1] + numArray4[2] * num3;
                    xft[index] = num2 + num5;
                    yft[index] = num3 + num6;
                    zft[index] = num4 + num7;
                }
                double num8 = xs2;
                double num9 = ys2;
                double num10 = zs2;
                double num11 = numArray2[1] + numArray2[2] * num9;
                double num12 = numArray3[1] + numArray3[2] * num9;
                double num13 = numArray4[1] + numArray4[2] * num9;
                xs2 = num8 + num11;
                ys2 = num9 + num12;
                zs2 = num10 + num13;
            }
        }

        public static void Fiducial(
          int iParam,
          int k,
          int kMark,
          ref double[] x,
          ref double[] y,
          ref double[] p,
          ref double[] q)
        {
            int[] nm = new int[10];
            double[] xm1 = new double[10];
            double[] ym1 = new double[10];
            double[] pm = new double[10];
            double[] qm = new double[10];
            int num1;
            int kLab = num1 = 0;
            double num2;
            double num3 = num2 = 0.0;
            double num4;
            double num5 = num4 = 0.0;
            double num6;
            double num7 = num6 = 0.0;
            double num8;
            double num9 = num8 = 0.0;
            double num10;
            double num11 = num10 = 0.0;
            int kArray = 999999;
            doubleArray(x, ref kArray);
            doubleArray(y, ref kArray);
            doubleArray(p, ref kArray);
            doubleArray(q, ref kArray);
            if (k > kArray)
            {
                int num12 = (int)MessageBox.Show("Индекс массива Fiducial");
            }
            else
            {
                double xm2;
                double ym2;
                double xm3;
                double ym3;
                if (kMark == 4 || kMark == 8)
                {
                    StereoMark(kMark, x, y, p, q, out kLab, ref nm, ref xm1, ref ym1, ref pm, ref qm);
                    double x1_1 = xm1[1];
                    double y1_1 = ym1[1];
                    double x1_2 = xm1[1] - pm[1];
                    double y1_2 = ym1[1] - qm[1];
                    if (iParam == 3)
                    {
                        y1_1 = ym1[1] + qm[1];
                        y1_2 = ym1[1];
                    }
                    double x2_1 = xm1[2];
                    double y2_1 = ym1[2];
                    double x2_2 = xm1[2] - pm[2];
                    double y2_2 = ym1[2] - qm[2];
                    if (iParam == 3)
                    {
                        y2_1 = ym1[2] + qm[2];
                        y2_2 = ym1[2];
                    }
                    double x3_1 = xm1[3];
                    double y3_1 = ym1[3];
                    double x3_2 = xm1[3] - pm[3];
                    double y3_2 = ym1[3] - qm[3];
                    if (iParam == 3)
                    {
                        y3_1 = ym1[3] + qm[3];
                        y3_2 = ym1[3];
                    }
                    double x4_1 = xm1[4];
                    double y4_1 = ym1[4];
                    double x4_2 = xm1[4] - pm[4];
                    double y4_2 = ym1[4] - qm[4];
                    if (iParam == 3)
                    {
                        y4_1 = ym1[4] + qm[4];
                        y4_2 = ym1[4];
                    }
                    xm2 = 0.0;
                    ym2 = 0.0;
                    int ip1 = 1;
                    TwoLine(x1_1, y1_1, x3_1, y3_1, x2_1, y2_1, x4_1, y4_1, out xm2, out ym2, ref ip1);
                    xm3 = 0.0;
                    ym3 = 0.0;
                    int ip2 = 1;
                    TwoLine(x1_2, y1_2, x3_2, y3_2, x2_2, y2_2, x4_2, y4_2, out xm3, out ym3, ref ip2);
                }
                else
                {
                    xm2 = 0.0;
                    ym2 = 0.0;
                    xm3 = 0.0;
                    ym3 = 0.0;
                }
                for (int i = 1; i <= k; ++i)
                {
                    p[i] = x[i] - p[i];
                    x[i] = x[i] - xm2;
                    p[i] = p[i] - xm3;
                    q[i] = y[i] - q[i];
                    y[i] = y[i] - ym2;
                    q[i] = q[i] - ym3;
                    if (iParam == 3)
                    {
                        double num13 = y[i];
                        double num14 = q[i];
                        y[i] = num13 + num14 - ym2;
                        q[i] = num13 - ym3;
                    }
                }
            }
        }

        public static void MonoMark(
          int kMet,
          double[] x,
          double[] y,
          out int kMark,
          ref int[] nt,
          ref double[] xt,
          ref double[] yt,
          out int iprz)
        {
            double[] numArray1 = new double[10];
            double[] numArray2 = new double[10];
            double num1;
            double num2 = num1 = 0.0;
            iprz = 0;
            double num3 = 9999999.9;
            double num4 = -9999999.9;
            for (int i = 1; i <= kMet; ++i)
            {
                if (x[i] < num3)
                    num3 = x[i];
                if (x[i] > num4)
                    num4 = x[i];
            }
            double num5 = (num4 - num3) / 4.0;
            int i1 = 0;
            for (int i2 = 1; i2 <= 3; ++i2)
            {
                if (i2 == 1)
                {
                    num2 = num3 - num5;
                    num1 = num3 + num5;
                }
                if (i2 == 2)
                {
                    num2 = num4 - num5;
                    num1 = num4 + num5;
                }
                if (i2 == 3)
                {
                    num2 = num3 + num5;
                    num1 = num4 - num5;
                }
                int i3 = 0;
                for (int i4 = 1; i4 <= kMet; ++i4)
                {
                    if (x[i4] > num2 && x[i4] < num1)
                    {
                        ++i3;
                        numArray1[i3] = x[i4];
                        numArray2[i3] = y[i4];
                    }
                }
                if (i3 == 1)
                {
                    iprz = 1;
                    if (i2 == 1)
                    {
                        i1 = 1;
                        nt[i1] = 1;
                        xt[i1] = numArray1[1];
                        yt[i1] = numArray2[1];
                    }
                    if (i2 == 2)
                    {
                        i1 = 2;
                        nt[i1] = 2;
                        xt[i1] = numArray1[1];
                        yt[i1] = numArray2[1];
                    }
                }
                if (i3 > 1)
                {
                    for (int i5 = 1; i5 < i3; ++i5)
                    {
                        for (int i6 = i5 + 1; i6 <= i3; ++i6)
                        {
                            if (numArray2[i5] > numArray2[i6])
                            {
                                double num6 = numArray1[i5];
                                double num7 = numArray2[i5];
                                numArray1[i5] = numArray1[i6];
                                numArray2[i5] = numArray2[i6];
                                numArray1[i6] = num6;
                                numArray2[i6] = num7;
                            }
                        }
                    }
                    if (i2 == 1)
                    {
                        if (i3 == 2)
                        {
                            iprz = 4;
                            nt[1] = 1;
                            xt[1] = numArray1[1];
                            yt[1] = numArray2[1];
                            i1 = 3;
                            nt[3] = 3;
                            xt[3] = numArray1[2];
                            yt[3] = numArray2[2];
                        }
                        if (i3 == 3)
                        {
                            iprz = 8;
                            nt[1] = 1;
                            xt[1] = numArray1[1];
                            yt[1] = numArray2[1];
                            i1 = 5;
                            nt[5] = 5;
                            xt[5] = numArray1[2];
                            yt[5] = numArray2[2];
                            nt[3] = 3;
                            xt[3] = numArray1[3];
                            yt[3] = numArray2[3];
                        }
                    }
                    if (i2 == 2)
                    {
                        if (i3 == 2)
                        {
                            nt[2] = 2;
                            xt[2] = numArray1[2];
                            yt[2] = numArray2[2];
                            i1 = 4;
                            nt[4] = 4;
                            xt[4] = numArray1[1];
                            yt[4] = numArray2[1];
                        }
                        if (i3 == 3)
                        {
                            nt[2] = 2;
                            xt[2] = numArray1[3];
                            yt[2] = numArray2[3];
                            i1 = 6;
                            nt[6] = 6;
                            xt[6] = numArray1[2];
                            yt[6] = numArray2[2];
                            nt[4] = 4;
                            xt[4] = numArray1[1];
                            yt[4] = numArray2[1];
                        }
                    }
                    if (i2 == 3 && i3 == 2)
                    {
                        if (i1 == 2)
                        {
                            nt[3] = 3;
                            xt[3] = numArray1[1];
                            yt[3] = numArray2[1];
                            i1 = 4;
                            nt[4] = 4;
                            xt[4] = numArray1[2];
                            yt[4] = numArray2[2];
                        }
                        if (i1 == 6)
                        {
                            nt[7] = 7;
                            xt[7] = numArray1[1];
                            yt[7] = numArray2[1];
                            i1 = 8;
                            nt[8] = 8;
                            xt[8] = numArray1[2];
                            yt[8] = numArray2[2];
                        }
                    }
                }
            }
            kMark = i1;
        }

        public static void FactNorm(
          int nEqua,
          int k,
          double[] x,
          double[] y,
          double[] dv,
          ref double[] aa,
          ref double[] b,
          out int nDeg,
          int iParam)
        {
            double[] a = new double[10];
            int n = 0;
            for (int i = 1; i <= k; ++i)
            {
                double num1 = x[i];
                double num2 = y[i];
                if (iParam == 1)
                {
                    a[1] = 1.0;
                    a[2] = num1;
                    a[3] = num2;
                    a[4] = num1 * num1;
                    a[5] = num1 * num2;
                    a[6] = num2 * num2;
                    a[7] = num1 * num1 * num1;
                }
                if (iParam == 2)
                {
                    a[1] = 1.0;
                    a[2] = num2;
                    a[3] = num1;
                    a[4] = num2 * num2;
                    a[5] = num1 * num2;
                    a[6] = num1 * num1;
                    a[7] = num2 * num2 * num2;
                }
                n = nEqua;
                if (nEqua > 7)
                    n = 7;
                if (nEqua <= 1)
                    n = k >= 6 ? 5 : k - 1;
                FormMatrix(a, ref aa, dv[i], ref b, n, 1.0);
            }
            nDeg = n;
        }

        public static void CoorPnt(
          int nEqua,
          double x,
          double y,
          double[] a,
          out double xt,
          int iParam)
        {
            double[] numArray = new double[10];
            xt = 0.0;
            int kArray = 999999;
            doubleArray(a, ref kArray);
            if (nEqua > kArray)
            {
                int num1 = (int)MessageBox.Show("Индекс массива CoorPnt");
            }
            else
            {
                if (iParam == 1)
                {
                    numArray[1] = 1.0;
                    numArray[2] = x;
                    numArray[3] = y;
                    numArray[4] = x * x;
                    numArray[5] = x * y;
                    numArray[6] = y * y;
                    numArray[7] = x * x * x;
                }
                if (iParam == 2)
                {
                    numArray[1] = 1.0;
                    numArray[2] = y;
                    numArray[3] = x;
                    numArray[4] = y * y;
                    numArray[5] = x * y;
                    numArray[6] = x * x;
                    numArray[7] = y * y * y;
                }
                double num2 = 0.0;
                for (int i = 1; i <= nEqua; ++i)
                    num2 += a[i] * numArray[i];
                xt = num2;
            }
        }

        public static void GeoOrient(
          int kGeo,
          string[] nameGeo,
          double[] xGeo,
          double[] yGeo,
          double[] zGeo,
          int kFot,
          ref string[] fotoName,
          ref double[] xFoto,
          ref double[] yFoto,
          ref double[] zFoto,
          ref string[] dopName,
          ref double[] xDop,
          ref double[] yDop)
        {
            double[] pFact = new double[10];
            TransItems(kGeo, nameGeo, xGeo, yGeo, zGeo, kFot, fotoName, xFoto, yFoto, zFoto, out int _, ref dopName, ref xDop, ref yDop, ref pFact);
            double xo = pFact[1];
            double yo = pFact[2];
            double zo = pFact[3];
            double xof = pFact[4];
            double yof = pFact[5];
            double zof = pFact[6];
            double rcp = pFact[7];
            double num = pFact[8];
            double ee1;
            double ee2;
            double ee3;
            double xcc;
            double ycc;
            double zcc;
            double rsp;
            AbsItems(kGeo, nameGeo, xGeo, yGeo, zGeo, kFot, fotoName, xFoto, yFoto, zFoto, rcp, xo, yo, zo, xof, yof, zof, out ee1, out ee2, out ee3, out xcc, out ycc, out zcc, out rsp);
            AbsOrient2(kFot, ref xFoto, ref yFoto, ref zFoto, xcc, ycc, zcc, xof, yof, zof, rsp, ee1, ee2, ee3);
        }

        public static void xyzCenter(
          int kGeo,
          string[] nameGeo,
          double[] xGeo,
          double[] yGeo,
          double[] zGeo,
          int kFin,
          ref string[] nameFin,
          ref double[] xFin,
          ref double[] yFin,
          ref double[] zFin,
          out int kxy,
          out double xc,
          out double yc,
          ref double[] xFot,
          ref double[] yFot,
          ref double[] dxDop,
          ref double[] dyDop,
          out int kz,
          out double zc,
          ref double[] xDop,
          ref double[] yDop,
          ref double[] zFot,
          ref double[] dzDop)
        {
            double num1 = 0.0;
            double num2 = 0.0;
            double num3 = 0.0;
            int i1 = 0;
            int i2 = 0;
            for (int i3 = 1; i3 <= kGeo; ++i3)
            {
                for (int i4 = 1; i4 <= kFin; ++i4)
                {
                    if (nameGeo[i3] == nameFin[i4])
                    {
                        if (xGeo[i3] != 0.0 && yGeo[i3] != 0.0 && zGeo[i3] != 0.0)
                        {
                            ++i1;
                            xFot[i1] = xFin[i4];
                            yFot[i1] = yFin[i4];
                            dxDop[i1] = xFin[i4] - xGeo[i3];
                            dyDop[i1] = yFin[i4] - yGeo[i3];
                            num1 += xFin[i4];
                            num2 += yFin[i4];
                            ++i2;
                            xDop[i2] = xFin[i4];
                            yDop[i2] = yFin[i4];
                            zFot[i2] = zFin[i4];
                            dzDop[i2] = zFin[i4] - zGeo[i3];
                            num3 += zFin[i4];
                        }
                        if (xGeo[i3] != 0.0 && yGeo[i3] != 0.0 && zGeo[i3] == 0.0)
                        {
                            ++i1;
                            xFot[i1] = xFin[i4];
                            yFot[i1] = yFin[i4];
                            dxDop[i1] = xFin[i4] - xGeo[i3];
                            dyDop[i1] = yFin[i4] - yGeo[i3];
                            num1 += xFin[i4];
                            num2 += yFin[i4];
                        }
                        if (xGeo[i3] == 0.0 && yGeo[i3] == 0.0 && zGeo[i3] != 0.0)
                        {
                            ++i2;
                            xDop[i2] = xFin[i4];
                            yDop[i2] = yFin[i4];
                            zFot[i2] = zFin[i4];
                            dzDop[i2] = zFin[i4] - zGeo[i3];
                            num3 += zFin[i4];
                            break;
                        }
                        break;
                    }
                }
            }
            kxy = i1;
            kz = i2;
            xc = num1 / (double)i1;
            yc = num2 / (double)i1;
            zc = num3 / (double)i2;
        }

        public static void PolyFact(
          int kp,
          double[] xp,
          double[] yp,
          double[] dz,
          out int mm,
          ref double[] b,
          int iParam)
        {
            int[] l = new int[10];
            int[] m = new int[10];
            double[] a = new double[51];
            double[] b1 = new double[10];
            for (int i = 1; i <= 50; ++i)
                a[i] = 0.0;
            for (int i = 1; i <= 7; ++i)
                b[i] = 0.0;
            int nDeg;
            FactNorm(0, kp, xp, yp, dz, ref a, ref b, out nDeg, iParam);
            for (int i = 1; i <= nDeg; ++i)
                b1[i] = -b[i];
            Minv(ref a, nDeg, out double _, ref l, ref m);
            Gmprd(a, b1, ref b, nDeg, nDeg, 1);
            mm = nDeg;
        }

        public static void PolyCoor(
          int kf,
          int nRec,
          ref double[] xf,
          ref double[] yf,
          ref double[] zf,
          double xh,
          double yh,
          double zh,
          int m,
          double[] b,
          int iParam)
        {
            for (int i = 1; i <= kf; ++i)
            {
                double x = xf[i] - xh;
                double y = yf[i] - yh;
                double num = zf[i] - zh;
                double xt;
                CoorPnt(m, x, y, b, out xt, iParam);
                if (nRec == 1)
                    xf[i] = x + xt + xh;
                if (nRec == 2)
                    yf[i] = y + xt + yh;
                if (nRec == 3)
                    zf[i] = num + xt + zh;
            }
        }

        public static void DirCosin(
          double a,
          double w,
          double xp,
          out double a1,
          out double a2,
          out double a3,
          out double b1,
          out double b2,
          out double b3,
          out double c1,
          out double c2,
          out double c3)
        {
            double num1 = Math.Sin(a);
            double num2 = Math.Sin(w);
            double num3 = Math.Cos(a);
            double num4 = Math.Cos(w);
            double num5 = Math.Sin(xp);
            double num6 = Math.Cos(xp);
            a1 = num3 * num6 - num1 * num2 * num5;
            a2 = -num3 * num5 - num1 * num2 * num6;
            a3 = -num1 * num4;
            b1 = num4 * num5;
            b2 = num4 * num6;
            b3 = -num2;
            c1 = num1 * num6 + num3 * num2 * num5;
            c2 = -num1 * num5 + num3 * num2 * num6;
            c3 = num3 * num4;
        }

        public static void FormMatrix(
          double[] a,
          ref double[] aa,
          double w,
          ref double[] b,
          int n,
          double p)
        {
            int num = 1;
            for (int i1 = 1; i1 <= n; ++i1)
            {
                for (int i2 = 1; i2 <= n; ++i2)
                {
                    int i3 = i2 + num - 1;
                    aa[i3] = aa[i3] + a[i2] * a[i1] * p;
                }
                num += n;
                b[i1] = b[i1] + a[i1] * w * p;
            }
        }

        public static void RelItems(
          int k,
          double[] x1,
          double[] y1,
          double[] x2,
          double[] y2,
          double fk,
          ref double e1,
          ref double e4,
          ref double e5,
          ref double e3,
          ref double e6)
        {
            int[] l = new int[15];
            int[] m = new int[15];
            double[] numArray1 = new double[15];
            double[] a = new double[125];
            double[] numArray2 = new double[15];
            double w1 = 0.0;
            for (int i1 = 1; i1 <= 10; ++i1)
            {
                for (int i2 = 1; i2 <= 5; ++i2)
                    numArray2[i2] = 0.0;
                for (int i3 = 1; i3 <= 25; ++i3)
                    a[i3] = 0.0;
                double a1_1;
                double a2_1;
                double a3_1;
                double b1_1;
                double b2_1;
                double b3_1;
                double c1_1;
                double c2_1;
                double c3_1;
                DirCosin(e1, w1, e3, out a1_1, out a2_1, out a3_1, out b1_1, out b2_1, out b3_1, out c1_1, out c2_1, out c3_1);
                double a1_2;
                double a2_2;
                double a3_2;
                double b1_2;
                double b2_2;
                double b3_2;
                double c1_2;
                double c2_2;
                double c3_2;
                DirCosin(e4, e5, e6, out a1_2, out a2_2, out a3_2, out b1_2, out b2_2, out b3_2, out c1_2, out c2_2, out c3_2);
                double d;
                for (int i4 = 1; i4 <= k; ++i4)
                {
                    double num1 = a1_1 * x1[i4] + a2_1 * y1[i4] - a3_1 * fk;
                    double num2 = b1_1 * x1[i4] + b2_1 * y1[i4] - b3_1 * fk;
                    double num3 = c1_1 * x1[i4] + c2_1 * y1[i4] - c3_1 * fk;
                    double num4 = a1_2 * x2[i4] + a2_2 * y2[i4] - a3_2 * fk;
                    double num5 = b1_2 * x2[i4] + b2_2 * y2[i4] - b3_2 * fk;
                    double num6 = c1_2 * x2[i4] + c2_2 * y2[i4] - c3_2 * fk;
                    double num7 = b2_1 * x1[i4] - b1_1 * y1[i4];
                    double num8 = c2_1 * x1[i4] - c1_1 * y1[i4];
                    double num9 = b2_2 * x2[i4] - b1_2 * y2[i4];
                    double num10 = c2_2 * x2[i4] - c1_2 * y2[i4];
                    double num11 = num5 * Math.Cos(e4);
                    d = x2[i4] * Math.Sin(e6) - y2[i4] * Math.Cos(e6);
                    double num12 = b3_2 * d + fk * Math.Cos(e5);
                    numArray1[1] = -num1 * num5;
                    numArray1[2] = num4 * num2;
                    numArray1[3] = num2 * num11 - num3 * num12;
                    numArray1[4] = num7 * num6 - num8 * num5;
                    numArray1[5] = num10 * num2 - num3 * num9;
                    double w2 = num2 * num6 - num5 * num3;
                    FormMatrix(numArray1, ref a, w2, ref numArray2, 5, 1.0);
                }
                for (int i5 = 1; i5 <= 5; ++i5)
                    numArray1[i5] = -numArray2[i5];
                Minv(ref a, 5, out d, ref l, ref m);
                Gmprd(a, numArray1, ref numArray2, 5, 5, 1);
                e1 += numArray2[1];
                e4 += numArray2[2];
                e5 += numArray2[3];
                e3 += numArray2[4];
                e6 += numArray2[5];
                int num = 0;
                for (int i6 = 1; i6 <= 5; ++i6)
                {
                    if (Math.Abs(numArray2[i6]) > 3E-05)
                    {
                        ++num;
                        break;
                    }
                }
                if (num == 0)
                    break;
            }
        }

        public static void Parallax(int kt, double[] remPar, ref double[] y2)
        {
            double num = 0.0;
            int i1 = 0;
            for (int i2 = 1; i2 <= kt; ++i2)
            {
                if (Math.Abs(remPar[i2]) > Math.Abs(num))
                {
                    i1 = i2;
                    num = remPar[i2];
                }
            }
            if (i1 == 0)
                return;
            y2[i1] = y2[i1] + num;
        }

        public static void Factors(
          double e1,
          double e2,
          double e3,
          double e4,
          double e5,
          double e6,
          double f1,
          double f2,
          double f3,
          double f4,
          double f5,
          double f6,
          double f7,
          double f8,
          double f9,
          ref double[] r1,
          ref double[] r2)
        {
            double a1;
            double a2;
            double a3;
            double b1;
            double b2;
            double b3;
            double c1;
            double c2;
            double c3;
            DirCosin(e1, e2, e3, out a1, out a2, out a3, out b1, out b2, out b3, out c1, out c2, out c3);
            r1[1] = f1 * a1 + f2 * a2 + f3 * a3;
            r1[2] = f1 * b1 + f2 * b2 + f3 * b3;
            r1[3] = f1 * c1 + f2 * c2 + f3 * c3;
            r1[4] = f4 * a1 + f5 * a2 + f6 * a3;
            r1[5] = f4 * b1 + f5 * b2 + f6 * b3;
            r1[6] = f4 * c1 + f5 * c2 + f6 * c3;
            r1[7] = f7 * a1 + f8 * a2 + f9 * a3;
            r1[8] = f7 * b1 + f8 * b2 + f9 * b3;
            r1[9] = f7 * c1 + f8 * c2 + f9 * c3;
            DirCosin(e4, e5, e6, out a1, out a2, out a3, out b1, out b2, out b3, out c1, out c2, out c3);
            r2[1] = a1 * r1[1] + b1 * r1[2] + c1 * r1[3];
            r2[2] = a2 * r1[1] + b2 * r1[2] + c2 * r1[3];
            r2[3] = a3 * r1[1] + b3 * r1[2] + c3 * r1[3];
            r2[4] = a1 * r1[4] + b1 * r1[5] + c1 * r1[6];
            r2[5] = a2 * r1[4] + b2 * r1[5] + c2 * r1[6];
            r2[6] = a3 * r1[4] + b3 * r1[5] + c3 * r1[6];
            r2[7] = a1 * r1[7] + b1 * r1[8] + c1 * r1[9];
            r2[8] = a2 * r1[7] + b2 * r1[8] + c2 * r1[9];
            r2[9] = a3 * r1[7] + b3 * r1[8] + c3 * r1[9];
        }

        public static void StereoMark(
          int kMark,
          double[] x,
          double[] y,
          double[] p,
          double[] q,
          out int kLab,
          ref int[] nm,
          ref double[] xm,
          ref double[] ym,
          ref double[] pm,
          ref double[] qm)
        {
            double[] numArray1 = new double[10];
            double[] numArray2 = new double[10];
            double[] numArray3 = new double[10];
            double[] numArray4 = new double[10];
            int num1;
            int num2 = num1 = 0;
            double num3;
            double num4 = num3 = 0.0;
            double num5;
            double num6 = num5 = 0.0;
            double num7 = num5;
            double num8 = num5;
            double num9 = 9999999.9;
            double num10 = -9999999.9;
            for (int i = 1; i <= kMark; ++i)
            {
                if (x[i] < num9)
                    num9 = x[i];
                if (x[i] > num10)
                    num10 = x[i];
            }
            double num11 = (num10 - num9) / 4.0;
            int i1 = 0;
            for (int i2 = 1; i2 <= 3; ++i2)
            {
                if (i2 == 1)
                {
                    num8 = num9 - num11;
                    num7 = num9 + num11;
                }
                if (i2 == 2)
                {
                    num8 = num10 - num11;
                    num7 = num10 + num11;
                }
                if (i2 == 3)
                {
                    num8 = num9 + num11;
                    num7 = num10 - num11;
                }
                int i3 = 0;
                for (int i4 = 1; i4 <= kMark; ++i4)
                {
                    if (x[i4] > num8 && x[i4] < num7)
                    {
                        ++i3;
                        numArray1[i3] = x[i4];
                        numArray2[i3] = y[i4];
                        numArray3[i3] = p[i4];
                        numArray4[i3] = q[i4];
                    }
                }
                if (i3 == 1)
                {
                    if (i2 == 1)
                    {
                        i1 = 1;
                        nm[i1] = 1;
                        xm[i1] = numArray1[1];
                        ym[i1] = numArray2[1];
                        pm[i1] = numArray3[1];
                        qm[i1] = numArray4[1];
                    }
                    if (i2 == 2)
                    {
                        i1 = 2;
                        nm[i1] = 2;
                        xm[i1] = numArray1[1];
                        ym[i1] = numArray2[1];
                        pm[i1] = numArray3[1];
                        qm[i1] = numArray4[1];
                    }
                }
                if (i3 > 1)
                {
                    for (int i5 = 1; i5 < i3; ++i5)
                    {
                        for (int i6 = i5 + 1; i6 <= i3; ++i6)
                        {
                            if (numArray2[i5] > numArray2[i6])
                            {
                                double num12 = numArray1[i5];
                                double num13 = numArray2[i5];
                                double num14 = numArray3[i5];
                                double num15 = numArray4[i5];
                                numArray1[i5] = numArray1[i6];
                                numArray2[i5] = numArray2[i6];
                                numArray3[i5] = numArray3[i6];
                                numArray4[i5] = numArray4[i6];
                                numArray1[i6] = num12;
                                numArray2[i6] = num13;
                                numArray3[i6] = num14;
                                numArray4[i6] = num15;
                            }
                        }
                    }
                    if (i2 == 1)
                    {
                        if (i3 == 2)
                        {
                            nm[1] = 1;
                            xm[1] = numArray1[1];
                            ym[1] = numArray2[1];
                            pm[1] = numArray3[1];
                            qm[1] = numArray4[1];
                            i1 = 3;
                            nm[3] = 3;
                            xm[3] = numArray1[2];
                            ym[3] = numArray2[2];
                            pm[3] = numArray3[2];
                            qm[3] = numArray4[2];
                        }
                        if (i3 == 3)
                        {
                            nm[1] = 1;
                            xm[1] = numArray1[1];
                            ym[1] = numArray2[1];
                            pm[1] = numArray3[1];
                            qm[1] = numArray4[1];
                            i1 = 5;
                            nm[5] = 5;
                            xm[5] = numArray1[2];
                            ym[5] = numArray2[2];
                            pm[5] = numArray3[2];
                            qm[5] = numArray4[2];
                            nm[3] = 3;
                            xm[3] = numArray1[3];
                            ym[3] = numArray2[3];
                            pm[3] = numArray3[3];
                            qm[3] = numArray4[3];
                        }
                    }
                    if (i2 == 2)
                    {
                        if (i3 == 2)
                        {
                            nm[2] = 2;
                            xm[2] = numArray1[2];
                            ym[2] = numArray2[2];
                            pm[2] = numArray3[2];
                            qm[2] = numArray4[2];
                            i1 = 4;
                            nm[4] = 4;
                            xm[4] = numArray1[1];
                            ym[4] = numArray2[1];
                            pm[4] = numArray3[1];
                            qm[4] = numArray4[1];
                        }
                        if (i3 == 3)
                        {
                            nm[2] = 2;
                            xm[2] = numArray1[3];
                            ym[2] = numArray2[3];
                            pm[2] = numArray3[3];
                            qm[2] = numArray4[3];
                            i1 = 6;
                            nm[6] = 6;
                            xm[6] = numArray1[2];
                            ym[6] = numArray2[2];
                            pm[6] = numArray3[2];
                            qm[6] = numArray4[2];
                            nm[4] = 4;
                            xm[4] = numArray1[1];
                            ym[4] = numArray2[1];
                            pm[4] = numArray3[1];
                            qm[4] = numArray4[1];
                        }
                    }
                    if (i2 == 3 && i3 == 2)
                    {
                        if (i1 == 2)
                        {
                            nm[3] = 3;
                            xm[3] = numArray1[1];
                            ym[3] = numArray2[1];
                            pm[3] = numArray3[1];
                            qm[3] = numArray4[1];
                            i1 = 4;
                            nm[4] = 4;
                            xm[4] = numArray1[2];
                            ym[4] = numArray2[2];
                            pm[4] = numArray3[2];
                            qm[4] = numArray4[2];
                        }
                        if (i1 == 6)
                        {
                            nm[7] = 7;
                            xm[7] = numArray1[1];
                            ym[7] = numArray2[1];
                            pm[7] = numArray3[1];
                            qm[7] = numArray4[1];
                            i1 = 8;
                            nm[8] = 8;
                            xm[8] = numArray1[2];
                            ym[8] = numArray2[2];
                            pm[8] = numArray3[2];
                            qm[8] = numArray4[2];
                        }
                    }
                }
            }
            kLab = i1;
        }

        public static void TransItems(
          int kPnt,
          string[] namePnt,
          double[] xPnt,
          double[] yPnt,
          double[] zPnt,
          int kFot,
          string[] fotName,
          double[] xFot,
          double[] yFot,
          double[] zFot,
          out int kDop,
          ref string[] dopName,
          ref double[] dopScl,
          ref double[] dopAng,
          ref double[] pFact)
        {
            kDop = 0;
            double num1 = 0.0;
            double num2 = 0.0;
            double num3 = 0.0;
            double num4 = 0.0;
            double num5 = 0.0;
            double num6 = 0.0;
            double num7 = 0.0;
            double num8 = 0.0;
            double num9 = 0.0;
            double num10 = 0.0;
            for (int i1 = 1; i1 <= kPnt; ++i1)
            {
                for (int i2 = 1; i2 <= kFot; ++i2)
                {
                    if (namePnt[i1] == fotName[i2])
                    {
                        if (xPnt[i1] != 0.0 || yPnt[i1] != 0.0)
                        {
                            num3 += xPnt[i1];
                            num4 += yPnt[i1];
                            num6 += xFot[i2];
                            num7 += yFot[i2];
                            ++num9;
                        }
                        if (zPnt[i1] != 0.0)
                        {
                            num5 += zPnt[i1];
                            num8 += zFot[i2];
                            ++num10;
                            break;
                        }
                        break;
                    }
                }
            }
            double num11 = num3 / num9;
            double num12 = num4 / num9;
            double num13 = num5 / num10;
            double num14 = num6 / num9;
            double num15 = num7 / num9;
            double num16 = num8 / num10;
            int i3 = 0;
            for (int i4 = 1; i4 <= kPnt; ++i4)
            {
                for (int i5 = 1; i5 <= kFot; ++i5)
                {
                    if (namePnt[i4] == fotName[i5] && (xPnt[i4] != 0.0 || yPnt[i4] != 0.0))
                    {
                        double dy = xPnt[i4] - num11;
                        double dx = yPnt[i4] - num12;
                        double dxf = xFot[i5] - num14;
                        double dyf = yFot[i5] - num15;
                        double scale;
                        ScaleFact(dx, dy, dxf, dyf, out scale);
                        if (scale >= 0.001)
                        {
                            ++i3;
                            dopName[i3] = namePnt[i4];
                            dopAng[i3] = Fi(dx, dy, dxf, dyf);
                            dopScl[i3] = scale;
                        }
                    }
                }
            }
            for (int i6 = 1; i6 < i3; ++i6)
            {
                for (int i7 = i6 + 1; i7 <= i3; ++i7)
                {
                    if (dopScl[i6] > dopScl[i7])
                    {
                        string str = dopName[i6];
                        num1 = dopScl[i6];
                        num2 = dopAng[i6];
                        dopName[i6] = dopName[i7];
                        dopScl[i6] = dopScl[i7];
                        dopAng[i6] = dopAng[i7];
                        dopName[i7] = str;
                        dopScl[i7] = num1;
                        dopAng[i7] = num2;
                    }
                }
            }
            kDop = i3;
            if (i3 == 2)
            {
                num1 = 0.5 * (dopScl[1] + dopScl[2]);
                num2 = 0.5 * (dopAng[1] + dopAng[2]);
            }
            if (i3 > 2)
            {
                int i8 = i3 / 2;
                num1 = dopScl[i8];
                num2 = dopAng[i8];
            }
            pFact[1] = num11;
            pFact[2] = num12;
            pFact[3] = num13;
            pFact[4] = num14;
            pFact[5] = num15;
            pFact[6] = num16;
            pFact[7] = num1;
            pFact[8] = num2;
        }

        public static void AbsItems(
          int kPnt,
          string[] namePnt,
          double[] xPnt,
          double[] yPnt,
          double[] zPnt,
          int kFot,
          string[] fotName,
          double[] xFot,
          double[] yFot,
          double[] zFot,
          double rcp,
          double xo,
          double yo,
          double zo,
          double xof,
          double yof,
          double zof,
          out double ee1,
          out double ee2,
          out double ee3,
          out double xcc,
          out double ycc,
          out double zcc,
          out double rsp)
        {
            int[] l = new int[10];
            int[] m = new int[10];
            double[] a1 = new double[10];
            double[] a2 = new double[51];
            double[] numArray = new double[10];
            double[] b = new double[10];
            ee1 = 0.0;
            ee2 = 0.0;
            ee3 = 0.0;
            xcc = 0.0;
            ycc = 0.0;
            zcc = 0.0;
            rsp = 0.0;
            int kArray1 = 999999;
            stringArray(namePnt, ref kArray1);
            doubleArray(xPnt, ref kArray1);
            doubleArray(yPnt, ref kArray1);
            doubleArray(zPnt, ref kArray1);
            if (kPnt > kArray1)
            {
                int num1 = (int)MessageBox.Show("Индекс массива AbsItems");
            }
            else
            {
                int kArray2 = 999999;
                stringArray(namePnt, ref kArray2);
                doubleArray(xPnt, ref kArray2);
                doubleArray(yPnt, ref kArray2);
                doubleArray(zPnt, ref kArray2);
                if (kFot > kArray2)
                {
                    int num2 = (int)MessageBox.Show("Индекс массива AbsItems");
                }
                else
                {
                    double num3 = 0.0;
                    double num4 = 0.0;
                    double num5 = 0.0;
                    double num6 = xo;
                    double num7 = yo;
                    double num8 = zo;
                    int num9 = 0;
                    for (int i1 = 1; i1 <= 20; ++i1)
                    {
                        ++num9;
                        for (int i2 = 1; i2 <= 8; ++i2)
                            numArray[i2] = 0.0;
                        for (int i3 = 1; i3 <= 50; ++i3)
                            a2[i3] = 0.0;
                        double a1_1;
                        double a2_1;
                        double a3;
                        double b1;
                        double b2;
                        double b3;
                        double c1;
                        double c2;
                        double c3;
                        DirCosin(num3, num4, num5, out a1_1, out a2_1, out a3, out b1, out b2, out b3, out c1, out c2, out c3);
                        for (int i4 = 1; i4 <= kPnt; ++i4)
                        {
                            for (int i5 = 1; i5 <= kFot; ++i5)
                            {
                                if (namePnt[i4] == fotName[i5])
                                {
                                    if (xPnt[i4] != 0.0 || yPnt[i4] != 0.0)
                                    {
                                        double num10 = xPnt[i4] - num6;
                                        double num11 = yPnt[i4] - num7;
                                        double num12 = xFot[i5] - xof;
                                        double num13 = yFot[i5] - yof;
                                        double num14 = zFot[i5] - zof;
                                        a1[1] = -rcp * (c1 * num13 + c2 * num12 + c3 * num14);
                                        a1[2] = -rcp * Math.Sin(num3) * (b1 * num13 + b2 * num12 + b3 * num14);
                                        a1[3] = a2_1 * num13 * rcp - a1_1 * num12 * rcp;
                                        a1[4] = a1_1 * num13 + a2_1 * num12 + a3 * num14;
                                        a1[5] = 1.0;
                                        a1[6] = 0.0;
                                        a1[7] = 0.0;
                                        double w1 = a1[4] * rcp - num10 + num6;
                                        FormMatrix(a1, ref a2, w1, ref numArray, 7, 0.01);
                                        double num15 = Math.Sin(num4);
                                        double num16 = Math.Sin(num5);
                                        double num17 = Math.Cos(num5);
                                        double num18 = Math.Cos(num4);
                                        a1[1] = 0.0;
                                        a1[2] = -rcp * (num15 * num16 * num13 + num15 * num17 * num12 + num18 * num14);
                                        a1[3] = (b2 * num13 - b1 * num12) * rcp;
                                        a1[4] = b1 * num13 + b2 * num12 + b3 * num14;
                                        a1[5] = 0.0;
                                        a1[6] = 1.0;
                                        a1[7] = 0.0;
                                        double w2 = a1[4] * rcp - num11 + num7;
                                        FormMatrix(a1, ref a2, w2, ref numArray, 7, 0.01);
                                    }
                                    if (zPnt[i4] != 0.0)
                                    {
                                        double num19 = zPnt[i4] - num8;
                                        double num20 = xFot[i5] - xof;
                                        double num21 = yFot[i5] - yof;
                                        double num22 = zFot[i5] - zof;
                                        a1[1] = (a1_1 * num21 + a2_1 * num20 + a3 * num22) * rcp;
                                        a1[2] = a1[4] * rcp * Math.Cos(num3);
                                        a1[3] = (c2 * num21 - c1 * num20) * rcp;
                                        a1[4] = c1 * num21 + c2 * num20 + c3 * num22;
                                        a1[5] = 0.0;
                                        a1[6] = 0.0;
                                        a1[7] = 1.0;
                                        double w = a1[4] * rcp - num19 + num8;
                                        FormMatrix(a1, ref a2, w, ref numArray, 7, 0.01);
                                        break;
                                    }
                                    break;
                                }
                            }
                        }
                        for (int i6 = 1; i6 <= 7; ++i6)
                            b[i6] = -numArray[i6];
                        Minv(ref a2, 7, out double _, ref l, ref m);
                        Gmprd(a2, b, ref numArray, 7, 7, 1);
                        num3 += numArray[1];
                        num4 += numArray[2];
                        num5 += numArray[3];
                        rcp += numArray[4];
                        num6 += numArray[5];
                        num7 += numArray[6];
                        num8 += numArray[7];
                        int num23 = 0;
                        for (int i7 = 1; i7 <= 7; ++i7)
                        {
                            if (Math.Abs(numArray[i7]) > 5E-05)
                            {
                                ++num23;
                                break;
                            }
                        }
                        if (num23 == 0)
                            break;
                    }
                    ee1 = num3;
                    ee2 = num4;
                    ee3 = num5;
                    xcc = num6;
                    ycc = num7;
                    zcc = num8;
                    rsp = rcp;
                }
            }
        }

        public static void AbsOrient2(
          int kFot,
          ref double[] xFot,
          ref double[] yFot,
          ref double[] zFot,
          double xo,
          double yo,
          double zo,
          double xof,
          double yof,
          double zof,
          double rcp,
          double e1,
          double e2,
          double e3)
        {
            int kArray = 999999;
            doubleArray(xFot, ref kArray);
            doubleArray(yFot, ref kArray);
            doubleArray(zFot, ref kArray);
            if (kFot > kArray)
            {
                int num1 = (int)MessageBox.Show("Индекс массива AbsOrient2");
            }
            else
            {
                for (int i = 1; i <= kFot; ++i)
                {
                    double b = (xFot[i] - xof) * rcp;
                    double a = (yFot[i] - yof) * rcp;
                    double c = (zFot[i] - zof) * rcp;
                    double aa;
                    double bb;
                    double cc;
                    Trans(a, b, c, e1, e2, e3, out aa, out bb, out cc);
                    double num2 = bb;
                    double num3 = aa;
                    double num4 = cc;
                    xFot[i] = num3 + xo;
                    yFot[i] = num2 + yo;
                    zFot[i] = num4 + zo;
                }
            }
        }

        public static void ScaleFact(double dx, double dy, double dxf, double dyf, out double scale)
        {
            scale = 0.0;
            double num1 = Math.Sqrt(dx * dx + dy * dy);
            double num2 = Math.Sqrt(dxf * dxf + dyf * dyf);
            if (num1 < 0.01 || num2 < 0.01)
                return;
            scale = num1 / num2;
        }

        public static double Fi(double dx, double dy, double dxf, double dyf)
        {
            double num1 = 3.1415926;
            double num2 = Math.Atan2(dx, dy);
            double num3 = Math.Atan2(dxf, dyf) - num2;
            if (num3 < 0.0)
                num3 += 2.0 * num1;
            return num3;
        }

        public static void Trans(
          double a,
          double b,
          double c,
          double e1,
          double e2,
          double e3,
          out double aa,
          out double bb,
          out double cc)
        {
            double a1;
            double a2;
            double a3;
            double b1;
            double b2;
            double b3;
            double c1;
            double c2;
            double c3;
            DirCosin(e1, e2, e3, out a1, out a2, out a3, out b1, out b2, out b3, out c1, out c2, out c3);
            aa = a * a1 + b * a2 + c * a3;
            bb = a * b1 + b * b2 + c * b3;
            cc = a * c1 + b * c2 + c * c3;
        }

        public static void CameraStoreCopy(string fStore1, string fStore2)
        {
            if (!File.Exists(fStore1))
                return;
            string[] strArray1 = new string[50];
            string[] strArray2 = new string[50];
            string[] strArray3 = new string[50];
            string[] strArray4 = new string[150];
            string[] strArray5 = new string[150];
            FileStream input = new FileStream(fStore1, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            if (File.Exists(fStore2))
                File.Delete(fStore2);
            FileStream output = new FileStream(fStore2, FileMode.CreateNew);
            BinaryWriter binaryWriter = new BinaryWriter((Stream)output);
            try
            {
                string str1 = binaryReader.ReadString();
                binaryWriter.Write(str1);
                int int32_1 = Convert.ToInt32(str1);
                for (int i1 = 1; i1 <= int32_1; ++i1)
                {
                    string str2 = binaryReader.ReadString();
                    string str3 = binaryReader.ReadString();
                    string str4 = binaryReader.ReadString();
                    string str5 = binaryReader.ReadString();
                    string str6 = binaryReader.ReadString();
                    string str7 = binaryReader.ReadString();
                    string str8 = binaryReader.ReadString();
                    binaryWriter.Write(str2);
                    binaryWriter.Write(str3);
                    binaryWriter.Write(str4);
                    binaryWriter.Write(str5);
                    binaryWriter.Write(str6);
                    binaryWriter.Write(str7);
                    binaryWriter.Write(str8);
                    int int32_2 = Convert.ToInt32(str7);
                    int int32_3 = Convert.ToInt32(str8);
                    if (int32_2 > 0)
                    {
                        for (int i2 = 1; i2 <= int32_2; ++i2)
                        {
                            strArray1[i2] = binaryReader.ReadString();
                            strArray2[i2] = binaryReader.ReadString();
                            strArray3[i2] = binaryReader.ReadString();
                        }
                        for (int i3 = 1; i3 <= int32_2; ++i3)
                        {
                            binaryWriter.Write(strArray1[i3]);
                            binaryWriter.Write(strArray2[i3]);
                            binaryWriter.Write(strArray3[i3]);
                        }
                    }
                    if (int32_3 > 0)
                    {
                        for (int i4 = 1; i4 <= int32_3; ++i4)
                        {
                            strArray4[i4] = binaryReader.ReadString();
                            strArray5[i4] = binaryReader.ReadString();
                        }
                        for (int i5 = 1; i5 <= int32_3; ++i5)
                        {
                            binaryWriter.Write(strArray4[i5]);
                            binaryWriter.Write(strArray5[i5]);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            finally
            {
                input.Close();
                binaryReader.Close();
                output.Close();
                binaryWriter.Close();
            }
        }

        public static void FinalInput(
          int kLine1,
          int[] iCod1,
          double[] Rad1,
          int[] k11,
          int[] k12,
          double[] xLin1,
          double[] yLin1,
          int kLine2,
          int[] iCod2,
          double[] Rad2,
          int[] k21,
          int[] k22,
          double[] xLin2,
          double[] yLin2,
          double tol)
        {
            if (tol < 0.003)
                tol = 0.003;
            int num1;
            int ip = num1 = 0;
            double num2;
            double yp = num2 = 0.0;
            double xp = num2;
            double dist = num2;
            double num3;
            double num4 = num3 = 0.0;
            for (int i1 = 1; i1 <= kLine1; ++i1)
            {
                int num5 = k11[i1];
                int num6 = k12[i1];
                if (Rad1[i1] == 0.0)
                {
                    for (int i2 = num5 + 1; i2 <= num6; ++i2)
                    {
                        double x1 = xLin1[i2 - 1];
                        double y1 = yLin1[i2 - 1];
                        double x2 = xLin1[i2];
                        double y2 = yLin1[i2];
                        double num7 = 9999999.9;
                        int i3 = 0;
                        for (int i4 = 1; i4 <= kLine2; ++i4)
                        {
                            if (iCod1[i1] != iCod2[i4])
                            {
                                int num8 = k21[i4];
                                int num9 = k22[i4];
                                if (Rad2[i4] == 0.0)
                                {
                                    for (int i5 = num8 + 1; i5 <= num9; ++i5)
                                    {
                                        DistPnt(0.5 * (xLin2[i5 - 1] + xLin2[i5]), 0.5 * (yLin2[i5 - 1] + yLin2[i5]), x1, y1, x2, y2, out dist, out ip, out xp, out yp);
                                        if (ip > 0 && dist < num7)
                                        {
                                            num7 = dist;
                                            i3 = i4;
                                        }
                                    }
                                }
                            }
                        }
                        if (i3 > 0 && num7 <= tol)
                        {
                            iCod1[i1] = iCod2[i3];
                            break;
                        }
                    }
                }
            }
            for (int i6 = 1; i6 <= kLine1; ++i6)
            {
                int num10 = k11[i6];
                int num11 = k12[i6];
                if (Rad1[i6] > 0.0)
                {
                    int i7 = (num10 + num11) / 2;
                    double num12 = xLin1[i7];
                    double num13 = yLin1[i7];
                    double num14 = 9999999.9;
                    int i8 = 0;
                    for (int i9 = 1; i9 <= kLine2; ++i9)
                    {
                        if (iCod1[i6] != iCod2[i9])
                        {
                            int num15 = k21[i9];
                            int num16 = k22[i9];
                            if (Rad2[i9] > 0.0)
                            {
                                for (int i10 = num15; i10 <= num16; ++i10)
                                {
                                    double num17 = xLin2[i10] - num12;
                                    double num18 = yLin2[i10] - num13;
                                    double num19 = Math.Sqrt(num17 * num17 + num18 * num18);
                                    if (num19 < num14)
                                    {
                                        num14 = num19;
                                        i8 = i9;
                                    }
                                }
                            }
                        }
                    }
                    if (i8 > 0 && num14 <= tol)
                    {
                        iCod1[i6] = iCod2[i8];
                        break;
                    }
                }
            }
        }

        public static void SelItemProf(
     string fitemProf,
     int nSelect,
     out int iLong,
     out int iWid,
     out int iHei,
     out int kPix,
     int[] ixSqu,
     int[] iySqu,
     int[] nColor,
     out string sTxt,
     out int mClr)
        {
            iLong = 0;
            iWid = 0;
            iHei = 0;
            kPix = 0;
            mClr = 0;
            sTxt = "";
            if (nSelect == 0 || !File.Exists(fitemProf))
                return;
            FileStream input = new FileStream(fitemProf, FileMode.Open, FileAccess.Read);
            BinaryReader binaryReader = new BinaryReader((Stream)input);
            try
            {
                for (int index1 = 1; index1 <= nSelect; ++index1)
                {
                    binaryReader.ReadString();
                    iLong = binaryReader.ReadInt32();
                    if (iLong == 0)
                    {
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        iWid = binaryReader.ReadInt32();
                        iHei = binaryReader.ReadInt32();
                        kPix = binaryReader.ReadInt32();
                        if (kPix > 0)
                        {
                            for (int index2 = 1; index2 <= kPix; ++index2)
                            {
                                ixSqu[index2] = binaryReader.ReadInt32();
                                iySqu[index2] = binaryReader.ReadInt32();
                                nColor[index2] = binaryReader.ReadInt32();
                            }
                        }
                    }
                    if (iLong > 0)
                    {
                        binaryReader.ReadInt32();
                        mClr = binaryReader.ReadInt32();
                        sTxt = binaryReader.ReadString();
                        binaryReader.ReadDouble();
                        binaryReader.ReadDouble();
                        iWid = binaryReader.ReadInt32();
                        iHei = binaryReader.ReadInt32();
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Операция чтения завершилась неудачно, как и ожидалось.");
            }
            binaryReader.Close();
            input.Close();
        }
        public static void LineOpenMerge(
     double tol,
     int kLin1,
     ref int[] k1,
     ref int[] k2,
     ref double[] x1,
     ref double[] y1,
     out int kLin2,
     ref int[] kd1,
     ref int[] kd2,
     ref int[] kdd,
     ref double[] x2,
     ref double[] y2,
     ref int[] ni,
     ref double[] xp,
     ref double[] yp)
        {
            kLin2 = 0;
            int num1;
            int num2 = num1 = 0;
            int index1;
            int num3 = index1 = 0;
            double num4;
            double num5 = num4 = 0.0;
            if (tol < 0.003)
                tol = 0.003;
            int kArray1 = 999999;
            DllClass1.intArray(k1, ref kArray1);
            DllClass1.intArray(k2, ref kArray1);
            DllClass1.intArray(kd1, ref kArray1);
            DllClass1.intArray(kd2, ref kArray1);
            DllClass1.intArray(kdd, ref kArray1);
            if (kLin1 > kArray1)
            {
                int num6 = (int)MessageBox.Show("Index array LineOpenMerge");
            }
            else
            {
                int num7 = k2[kLin1];
                int kArray2 = 999999;
                DllClass1.intArray(ni, ref kArray2);
                DllClass1.doubleArray(x1, ref kArray2);
                DllClass1.doubleArray(y1, ref kArray2);
                DllClass1.doubleArray(x2, ref kArray2);
                DllClass1.doubleArray(y2, ref kArray2);
                DllClass1.doubleArray(xp, ref kArray2);
                DllClass1.doubleArray(yp, ref kArray2);
                if (num7 > kArray2)
                {
                    int num8 = (int)MessageBox.Show("Index array LineOpenMerge");
                }
                else
                {
                    num3 = 0;
                    for (int index2 = 1; index2 <= kLin1; ++index2)
                    {
                        int index3 = k1[index2];
                        int index4 = k2[index2];
                        int index5 = index1 + 1;
                        xp[index5] = x1[index3];
                        yp[index5] = y1[index3];
                        index1 = index5 + 1;
                        xp[index1] = x1[index4];
                        yp[index1] = y1[index4];
                    }
                    if (index1 == 0)
                        return;
                    for (int index6 = 1; index6 < index1; ++index6)
                    {
                        int num9 = 0;
                        for (int index7 = index6 + 1; index7 <= index1; ++index7)
                        {
                            if (xp[index7] != 0.0 || yp[index7] != 0.0)
                            {
                                double num10 = xp[index6] - xp[index7];
                                double num11 = yp[index6] - yp[index7];
                                if (Math.Sqrt(num10 * num10 + num11 * num11) < tol)
                                {
                                    ++num9;
                                    xp[index7] = 0.0;
                                    yp[index7] = 0.0;
                                }
                            }
                        }
                        if (num9 > 0)
                        {
                            xp[index6] = 0.0;
                            yp[index6] = 0.0;
                        }
                    }
                    int index8 = 0;
                    for (int index9 = 1; index9 <= index1; ++index9)
                    {
                        if (xp[index9] != 0.0 || yp[index9] != 0.0)
                        {
                            ++index8;
                            xp[index8] = xp[index9];
                            yp[index8] = yp[index9];
                        }
                    }
                    int num12 = index8;
                    int index10 = 0;
                    int index11 = 0;
                    for (int index12 = 1; index12 < num12; ++index12)
                    {
                        int num13 = 0;
                        if (index10 > 0)
                        {
                            double num14 = x2[index10] - xp[index12];
                            double num15 = y2[index10] - yp[index12];
                            if (Math.Sqrt(num14 * num14 + num15 * num15) < tol)
                                ++num13;
                        }
                        if (num13 <= 0)
                        {
                            int num16 = 0;
                            for (int index13 = 1; index13 <= kLin1; ++index13)
                            {
                                int num17 = 0;
                                for (int index14 = 1; index14 <= kLin1; ++index14)
                                {
                                    int num18 = 0;
                                    if (index11 > 0)
                                    {
                                        for (int index15 = 1; index15 <= index11; ++index15)
                                        {
                                            if (ni[index15] == index14)
                                            {
                                                ++num18;
                                                break;
                                            }
                                        }
                                    }
                                    if (num18 <= 0)
                                    {
                                        int index16 = k1[index14];
                                        int index17 = k2[index14];
                                        int num19 = 0;
                                        int num20 = 0;
                                        if (num16 > 0)
                                        {
                                            double num21 = x1[index16] - x2[index10];
                                            double num22 = y1[index16] - y2[index10];
                                            if (Math.Sqrt(num21 * num21 + num22 * num22) < tol)
                                                ++num19;
                                        }
                                        if (num16 == 0)
                                        {
                                            double num23 = x1[index16] - xp[index12];
                                            double num24 = y1[index16] - yp[index12];
                                            if (Math.Sqrt(num23 * num23 + num24 * num24) < tol)
                                                ++num20;
                                        }
                                        if (num19 > 0)
                                        {
                                            ++num17;
                                            ++index11;
                                            ni[index11] = index14;
                                            for (int index18 = index16 + 1; index18 <= index17; ++index18)
                                            {
                                                ++num16;
                                                ++index10;
                                                x2[index10] = x1[index18];
                                                y2[index10] = y1[index18];
                                            }
                                        }
                                        else if (num20 > 0)
                                        {
                                            ++num17;
                                            ++index11;
                                            ni[index11] = index14;
                                            for (int index19 = index16; index19 <= index17; ++index19)
                                            {
                                                ++num16;
                                                ++index10;
                                                x2[index10] = x1[index19];
                                                y2[index10] = y1[index19];
                                            }
                                        }
                                        else
                                        {
                                            int num25 = 0;
                                            int num26 = 0;
                                            if (num16 > 0)
                                            {
                                                double num27 = x1[index17] - x2[index10];
                                                double num28 = y1[index17] - y2[index10];
                                                if (Math.Sqrt(num27 * num27 + num28 * num28) < tol)
                                                    ++num25;
                                            }
                                            if (num16 == 0)
                                            {
                                                double num29 = x1[index17] - xp[index12];
                                                double num30 = y1[index17] - yp[index12];
                                                if (Math.Sqrt(num29 * num29 + num30 * num30) < tol)
                                                    ++num26;
                                            }
                                            if (num25 > 0)
                                            {
                                                ++num17;
                                                ++index11;
                                                ni[index11] = index14;
                                                int index20 = index17;
                                                for (int index21 = index16; index21 < index17; ++index21)
                                                {
                                                    ++num16;
                                                    ++index10;
                                                    --index20;
                                                    x2[index10] = x1[index20];
                                                    y2[index10] = y1[index20];
                                                }
                                            }
                                            else if (num26 > 0)
                                            {
                                                ++num17;
                                                ++index11;
                                                ni[index11] = index14;
                                                int index22 = index17 + 1;
                                                for (int index23 = index16; index23 <= index17; ++index23)
                                                {
                                                    ++num16;
                                                    ++index10;
                                                    --index22;
                                                    x2[index10] = x1[index22];
                                                    y2[index10] = y1[index22];
                                                }
                                            }
                                        }
                                    }
                                }
                                if (num17 == 0)
                                    break;
                            }
                            if (num16 > 1)
                            {
                                ++kLin2;
                                kdd[kLin2] = num16;
                            }
                        }
                    }
                    if (kLin2 == 0)
                        return;
                    kd1[1] = 1;
                    kd2[1] = kdd[1];
                    if (kLin2 <= 1)
                        return;
                    for (int index24 = 2; index24 <= kLin2; ++index24)
                    {
                        kd1[index24] = kd2[index24 - 1] + 1;
                        kd2[index24] = kd2[index24 - 1] + kdd[index24];
                    }
                }
            }
        }





    }
}







